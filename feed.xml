<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://jeonyoungho.github.io/</id><title>Youngho's Devlog</title><subtitle>Youngho's Devlog</subtitle> <updated>2025-08-20T22:03:01+09:00</updated> <author> <name>jeonyoungho</name> <uri>https://jeonyoungho.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://jeonyoungho.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="ko" href="https://jeonyoungho.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator> <rights> © 2025 jeonyoungho </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Kafka 메시지 전달 보장 방식</title><link href="https://jeonyoungho.github.io/posts/Kafka-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%A0%84%EB%8B%AC-%EB%B3%B4%EC%9E%A5-%EB%B0%A9%EC%8B%9D/" rel="alternate" type="text/html" title="Kafka 메시지 전달 보장 방식" /><published>2025-08-04T00:00:00+09:00</published> <updated>2025-08-06T21:03:29+09:00</updated> <id>https://jeonyoungho.github.io/posts/Kafka-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%A0%84%EB%8B%AC-%EB%B3%B4%EC%9E%A5-%EB%B0%A9%EC%8B%9D/</id> <content src="https://jeonyoungho.github.io/posts/Kafka-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%A0%84%EB%8B%AC-%EB%B3%B4%EC%9E%A5-%EB%B0%A9%EC%8B%9D/" /> <author> <name>jeonyoungho</name> </author> <category term="Backend" /> <category term="Kafka" /> <summary> 메시지 큐 시스템을 다룰 때 중요하게 고민해야되는 부분 중 하나는 ‘메시지의 중복과 유실 문제’이다. 이와 관련된 메시지 큐 시스템의 ‘메시지 전달 보장 방식’과 ‘Kafka 에서 각각 어떻게 지원하는지’에 대해 알아보자. 메시지 전달 보장 방식(Message Delivery Semantics) 메시지 전달 보장 방식은 다음과 같은 3가지가 존재한다. At most once: 메시지가 최대 한 번 전달됨을 보장 (중복은 발생하지 않지만, 유실이 있을 수 있음) At least once: 메시지가 최소 한 번 전달됨을 보장 (유실은 없지만, 중복이 있을 수 있음) Exactly once: 메시지가 정확히 한 번만 전달됨을 보장 (중복도 없고, 유실도 없음) 아래로 갈수록 데이터 무결... </summary> </entry> <entry><title>Kafka 리밸런싱 방식과 파티션 할당 전략</title><link href="https://jeonyoungho.github.io/posts/Kafka-%EB%A6%AC%EB%B0%B8%EB%9F%B0%EC%8B%B1-%EB%B0%A9%EC%8B%9D%EA%B3%BC-%ED%8C%8C%ED%8B%B0%EC%85%98-%ED%95%A0%EB%8B%B9-%EC%A0%84%EB%9E%B5/" rel="alternate" type="text/html" title="Kafka 리밸런싱 방식과 파티션 할당 전략" /><published>2025-07-23T00:00:00+09:00</published> <updated>2025-07-23T00:00:00+09:00</updated> <id>https://jeonyoungho.github.io/posts/Kafka-%EB%A6%AC%EB%B0%B8%EB%9F%B0%EC%8B%B1-%EB%B0%A9%EC%8B%9D%EA%B3%BC-%ED%8C%8C%ED%8B%B0%EC%85%98-%ED%95%A0%EB%8B%B9-%EC%A0%84%EB%9E%B5/</id> <content src="https://jeonyoungho.github.io/posts/Kafka-%EB%A6%AC%EB%B0%B8%EB%9F%B0%EC%8B%B1-%EB%B0%A9%EC%8B%9D%EA%B3%BC-%ED%8C%8C%ED%8B%B0%EC%85%98-%ED%95%A0%EB%8B%B9-%EC%A0%84%EB%9E%B5/" /> <author> <name>jeonyoungho</name> </author> <category term="Backend" /> <category term="Kafka" /> <summary> Kafka에서 리밸런싱이란 컨슈머 그룹 내 컨슈머들의 파티션 할당이 변경되는 과정을 의미하며, 주로 다음과 같은 4가지 상황에서 발생한다. 1) 컨슈머 그룹에 새로운 컨슈머 추가 2) 기존 컨슈머가 컨슈머 그룹에서 제거 3) 구독중인 토픽에 새로운 파티션 추가 4) 컨슈머가 구독하는 토픽 변경 리밸런싱은 주로 애플리케이션 배포 시 발생하는데, 이와 관련하여 Kafka 리밸런싱 방식과 파티션 할당 전략에 대해 알아보자. 리밸런싱 방식 리밸런싱은 ‘적극적 리밸런싱’과 ‘협력적 리밸런싱’ 두 가지 방식으로 나뉘어진다. 적극적 리밸런싱(Eager Rebalance) 적극적 리밸런싱은 리밸런싱이 발생할 때 모든 컨슈머가 브로커로부터 메시지 소비를 중단하고, 기존 할당된 파티션들을 재분배... </summary> </entry> <entry><title>Transactional Outbox 패턴</title><link href="https://jeonyoungho.github.io/posts/Transactional-Outbox-%ED%8C%A8%ED%84%B4/" rel="alternate" type="text/html" title="Transactional Outbox 패턴" /><published>2025-06-03T00:00:00+09:00</published> <updated>2025-06-08T16:06:40+09:00</updated> <id>https://jeonyoungho.github.io/posts/Transactional-Outbox-%ED%8C%A8%ED%84%B4/</id> <content src="https://jeonyoungho.github.io/posts/Transactional-Outbox-%ED%8C%A8%ED%84%B4/" /> <author> <name>jeonyoungho</name> </author> <category term="Backend" /> <category term="MSA" /> <summary> 이벤트 기반 아키텍처를 구현할때 고민해야될 포인트는 DB 트랜잭션과 이벤트(메시지) 발행의 원자성 보장이다. 이에 대한 해결 방법으로 Transactional Outbox 패턴에 대해 정리해보자. Transactional Outbox 패턴이란? 이벤트 기반 아키텍처를 적용할때 로컬 트랜잭션과 이벤트(메시지) 발행 간의 원자성 보장 문제를 해결하기 위한 패턴이다. DB와 메시지 브로커는 각각 독립적인 시스템으로 트랜잭션을 통합하는 것이 불가능하다. 예를 들어, 커머스 환경에서 Order 마이크로서비스에서 주문이 발생하면 메시지 브로커로 이벤트를 발행하고 Stock 마이크로서비스에서 관련된 상품의 재고를 차감한다고 가정해보자. 이때 Order 마이크로서비스에서 주문 생성 DB 트랜잭션은 성공했... </summary> </entry> <entry><title>데이터베이스 인덱스 조각화(Fragmentation)</title><link href="https://jeonyoungho.github.io/posts/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%A1%B0%EA%B0%81%ED%99%94/" rel="alternate" type="text/html" title="데이터베이스 인덱스 조각화(Fragmentation)" /><published>2025-05-31T00:00:00+09:00</published> <updated>2025-06-01T23:05:55+09:00</updated> <id>https://jeonyoungho.github.io/posts/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%A1%B0%EA%B0%81%ED%99%94/</id> <content src="https://jeonyoungho.github.io/posts/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%A1%B0%EA%B0%81%ED%99%94/" /> <author> <name>jeonyoungho</name> </author> <category term="Backend" /> <category term="Database" /> <summary> 데이터베이스 테이블의 인덱스를 활용한다해도 데이터가 계속 쌓이다보면 쿼리 속도가 느려질 수 있다. 이와 관련된 인덱스 조각화(Fragmentation) 문제와 해결 방법 및 이를 지연시킬 수 있는 방법에 대해 정리해보자. 1. 인덱스 조각화(Fragmentation)란? MySQL(MariaDB)에서 인덱스 페이지가 비효율적으로 배치되는 현상을 말한다. 인덱스 또한 물리적인 페이지로 관리되는데 인덱스로 관리되는 데이터의 양이 많아지다보면 여러 페이지로 나뉘어 관리되게 되고 이로 인해 옵티마이저가 여러 페이지를 찾다보니 속도가 저하되게 된다. 조각화가 발생하는 주요 원인은 다음과 같다. INSERT(삽입): 새로운 데이터를 삽입하며 기존 페이지 공간이 부족하면 새로운 페이지가 생성됨 UP... </summary> </entry> <entry><title>Kafka DeadLetter 관리</title><link href="https://jeonyoungho.github.io/posts/Kafka-DeadLetter-%EA%B4%80%EB%A6%AC/" rel="alternate" type="text/html" title="Kafka DeadLetter 관리" /><published>2025-05-11T00:00:00+09:00</published> <updated>2025-05-20T21:52:40+09:00</updated> <id>https://jeonyoungho.github.io/posts/Kafka-DeadLetter-%EA%B4%80%EB%A6%AC/</id> <content src="https://jeonyoungho.github.io/posts/Kafka-DeadLetter-%EA%B4%80%EB%A6%AC/" /> <author> <name>jeonyoungho</name> </author> <category term="Backend" /> <category term="Kafka" /> <summary> MSA 환경에서 이벤트 기반 아키텍처(EDA)를 적용할때 Kafka가 주로 사용되곤 한다. 카프카 Consumer 메시지 처리 실패시 dead-letter를 어떻게 관리하고 재시도 전략을 수립하면 좋을지 깊게 고찰해보자. (잘못된 내용 및 피드백은 코멘트로 남겨주시면 최대한 빠르게 확인해보겠습니다😃) 가장 간단하게는 spring-kafka에서 제공하는 DefaultErrorHandler와 DeadLetterPublishingRecoverer를 활용하여 재시도 전략을 고민해볼 수 있다. @Bean public DeadLetterPublishingRecoverer deadLetterPublishingRecoverer() { return new DeadLetterPublishingRecovere... </summary> </entry> </feed>
