[ { "title": "Kafka 메시지 전달 보장 방식", "url": "/posts/Kafka-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%A0%84%EB%8B%AC-%EB%B3%B4%EC%9E%A5-%EB%B0%A9%EC%8B%9D/", "categories": "Backend, Kafka", "tags": "kafka, at-least-once, at-most-once, exactly-once", "date": "2025-08-04 00:00:00 +0900", "snippet": "메시지 큐 시스템을 다룰 때 중요하게 고민해야되는 부분 중 하나는 ‘메시지의 중복과 유실 문제’이다.이와 관련된 메시지 큐 시스템의 ‘메시지 전달 보장 방식’과 ‘Kafka 에서 각각 어떻게 지원하는지’에 대해 알아보자.메시지 전달 보장 방식(Message Delivery Semantics)메시지 전달 보장 방식은 다음과 같은 3가지가 존재한다. At most once: 메시지가 최대 한 번 전달됨을 보장 (중복은 발생하지 않지만, 유실이 있을 수 있음) At least once: 메시지가 최소 한 번 전달됨을 보장 (유실..." }, { "title": "Kafka 리밸런싱 방식과 파티션 할당 전략", "url": "/posts/Kafka-%EB%A6%AC%EB%B0%B8%EB%9F%B0%EC%8B%B1-%EB%B0%A9%EC%8B%9D%EA%B3%BC-%ED%8C%8C%ED%8B%B0%EC%85%98-%ED%95%A0%EB%8B%B9-%EC%A0%84%EB%9E%B5/", "categories": "Backend, Kafka", "tags": "kafka, rebalancing", "date": "2025-07-23 00:00:00 +0900", "snippet": "Kafka에서 리밸런싱이란 컨슈머 그룹 내 컨슈머들의 파티션 할당이 변경되는 과정을 의미하며, 주로 다음과 같은 4가지 상황에서 발생한다. 1) 컨슈머 그룹에 새로운 컨슈머 추가 2) 기존 컨슈머가 컨슈머 그룹에서 제거 3) 구독중인 토픽에 새로운 파티션 추가 4) 컨슈머가 구독하는 토픽 변경리밸런싱은 주로 애플리케이션 배포 시 발생하는데, 이와 관련하여 Kafka 리밸런싱 방식과 파티션 할당 전략에 대해 알아보자.리밸런싱 방식리밸런싱은 ‘적극적 리밸런싱’과 ‘협력적 리밸런싱’ 두 가지 방식으로 나뉘어진다.적극적 리밸런..." }, { "title": "Transactional Outbox 패턴", "url": "/posts/Transactional-Outbox-%ED%8C%A8%ED%84%B4/", "categories": "Backend, MSA", "tags": "transactionaloutboxpattern, kafka, cdc, debezium", "date": "2025-06-03 00:00:00 +0900", "snippet": "이벤트 기반 아키텍처를 구현할때 고민해야될 포인트는 DB 트랜잭션과 이벤트(메시지) 발행의 원자성 보장이다.이에 대한 해결 방법으로 Transactional Outbox 패턴에 대해 정리해보자.Transactional Outbox 패턴이란?이벤트 기반 아키텍처를 적용할때 로컬 트랜잭션과 이벤트(메시지) 발행 간의 원자성 보장 문제를 해결하기 위한 패턴이다.DB와 메시지 브로커는 각각 독립적인 시스템으로 트랜잭션을 통합하는 것이 불가능하다.예를 들어, 커머스 환경에서 Order 마이크로서비스에서 주문이 발생하면 메시지 브로커로 ..." }, { "title": "데이터베이스 인덱스 조각화(Fragmentation)", "url": "/posts/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%A1%B0%EA%B0%81%ED%99%94/", "categories": "Backend, Database", "tags": "database, index", "date": "2025-05-31 00:00:00 +0900", "snippet": "데이터베이스 테이블의 인덱스를 활용한다해도 데이터가 계속 쌓이다보면 쿼리 속도가 느려질 수 있다.이와 관련된 인덱스 조각화(Fragmentation) 문제와 해결 방법 및 이를 지연시킬 수 있는 방법에 대해 정리해보자.1. 인덱스 조각화(Fragmentation)란?MySQL(MariaDB)에서 인덱스 페이지가 비효율적으로 배치되는 현상을 말한다.인덱스 또한 물리적인 페이지로 관리되는데 인덱스로 관리되는 데이터의 양이 많아지다보면 여러 페이지로 나뉘어 관리되게 되고 이로 인해 옵티마이저가 여러 페이지를 찾다보니 속도가 저하되게..." }, { "title": "Kafka DeadLetter 관리", "url": "/posts/Kafka-DeadLetter-%EA%B4%80%EB%A6%AC/", "categories": "Backend, Kafka", "tags": "kafka, deadletter", "date": "2025-05-11 00:00:00 +0900", "snippet": "MSA 환경에서 이벤트 기반 아키텍처(EDA)를 적용할때 Kafka가 주로 사용되곤 한다.카프카 Consumer 메시지 처리 실패시 dead-letter를 어떻게 관리하고 재시도 전략을 수립하면 좋을지 깊게 고찰해보자.(잘못된 내용 및 피드백은 코멘트로 남겨주시면 최대한 빠르게 확인해보겠습니다😃)가장 간단하게는 spring-kafka에서 제공하는 DefaultErrorHandler와 DeadLetterPublishingRecoverer를 활용하여 재시도 전략을 고민해볼 수 있다.@Beanpublic DeadLetterPubli..." }, { "title": "Redis 특징", "url": "/posts/Redis-%ED%8A%B9%EC%A7%95/", "categories": "Backend", "tags": "redis", "date": "2025-05-01 00:00:00 +0900", "snippet": "Redis는 Remote Dictionary Server를 뜻하며 key-value 기반의 인메모리 데이터 저장소이다.대용량 트래픽을 처리하기 위해 자주 사용되는 Redis의 대표적인 특징들을 알아보자.1. key-value 구조의 비관계형 데이터베이스RDB와는 다르게 관계가 없는 비정형 데이터를 관리한다.2. 싱글 스레드 기반Redis는 싱글 스레드 기반으로 동작하기에 동시성 이슈에 대한 고민이 필요 없게 된다. 즉 한 번에 하나의 명령이 처리되는 구조다.Redis의 자세한 동작 메커니즘은 여기에 자세히 정리되어 있다.3. ..." }, { "title": "Redis 동작 원리", "url": "/posts/Redis-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC/", "categories": "Backend", "tags": "redis, socket, io-multiplexing, eventloop", "date": "2025-05-01 00:00:00 +0900", "snippet": "Redis는 실무에서 캐싱, 동시성 문제 해결을 위한 분산 락, Rate Limit, 이벤트 Pub/Sub 모델 기반 브로드캐스팅 등 다양하게 활용되고 있다.인메모리(RAM) 기반의 key-value 구조로 하드디스크로부터 조회하는 것에 비해 뛰어난 조회 성능을 가지고 있다. 또한, 싱글 스레드 기반으로 하나의 명령씩 실행이 가능하기에 동시성 문제를 해결하는데 효과적이다.그렇다면 레디스는 내부적으로 어떻게 동작하며, 싱글 스레드 기반으로 높은 성능을 보장할 수 있는 것인지 알아보자.Redis 내부 동작 메커니즘출처: ByteB..." }, { "title": "MSA 환경에서의 분산 트랜잭션 관리", "url": "/posts/MSA-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C%EC%9D%98-%EB%B6%84%EC%82%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B4%80%EB%A6%AC/", "categories": "Backend, MSA", "tags": "msa, 2pc, saga", "date": "2025-04-10 00:00:00 +0900", "snippet": "MSA 환경에서 고민해야되는 포인트는 도메인별로 분산된 DB를 가질때의 트랜잭션 관리다.단일 DB에서 제공하는 트랜잭션을 활용할 수 없다보니 전체적인 데이터 일관성과 무결성을 보장하기 위한 고민이 필요하다.이를 해결하기 위한 대표적인 방식인 2PC 프로토콜(2Phase Commit)과 Saga Pattern에 대해 알아보자.2PC(2Phase Commit) 프로토콜MSA 가 대중화 되기 이전에 분산 데이터베이스 환경에서 데이터 일관성을 만족시키기 위해 널리 사용되었던 프로토콜 중 하나다.전체적인 흐름은 중간의 Coorinato..." }, { "title": "Spring Data JPA Batch Insert의 사실과 오해", "url": "/posts/JPA-Batch-Insert%EC%9D%98-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B4/", "categories": "Backend, JPA", "tags": "jpa, springdatajpa, batchinsert, mariadb", "date": "2025-02-25 00:00:00 +0900", "snippet": "SpringBoot + JPA + MariaDB(10.6 이상) 환경에서 JPA 엔티티 ID 생성 전략을 IDENDITY를 적용하면 batch insert를 사용할 수 없다는 내용은 구글링을 통해 쉽게 찾을수 있다. IDENTITY 전략은 auto-increment로 PK 값을 자동으로 DB 에 의존하여 채번하는 방식이다. JPA 엔티티를 persist 하려면 @Id로 지정한 필드에 값이 필요한데, IDENTITY 타입은 실제 DB에 insert를 해야만 값을 얻을 수 있기 때문에 batch 처리가 불가능하다.이를 해결하기..." }, { "title": "DB Lock 알아보기 1편", "url": "/posts/DB-Lock-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0-1%ED%8E%B8/", "categories": "Backend, Database", "tags": "database, lock", "date": "2025-02-22 00:00:00 +0900", "snippet": "제품을 운영하다보면 Deadlock found when trying to get lock, Lock wait timout exceeded와 같은 DB 동시성 이슈를 마주할 수 있게 된다. 보통 여러 트랜잭션이 동시에 동일 데이터에 대한 select, update 작업들을 수행할때 발생하게 되는데 이와 관련해서 DB Lock에 대해 정리해보고자 한다.락(Lock)이란?데이터베이스는 여러 사용자들이 같은 데이터를 동시에 접근하는 상황에서, 데이터 무결성과 일관성을 지키기 위해 락을 사용한다.즉, 여러 트랜잭션 간의 동시성을 제어하..." }, { "title": "Kafka 기반 대규모 데이터 동시성 최적화: Request-Reply 패턴 활용 사례", "url": "/posts/Kafka-%EA%B8%B0%EB%B0%98-%EB%8C%80%EA%B7%9C%EB%AA%A8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%8F%99%EC%8B%9C%EC%84%B1-%EC%B5%9C%EC%A0%81%ED%99%94-Request-Reply-%ED%8C%A8%ED%84%B4-%ED%99%9C%EC%9A%A9-%EC%82%AC%EB%A1%80/", "categories": "Backend", "tags": "woowacon24", "date": "2025-02-17 00:00:00 +0900", "snippet": " 우아콘24의 ‘Kafka 기반 대규모 데이터 동시성 최적화: Request-Reply 패턴 활용 사례’’ 에 대한 학습 내용을 정리하기 위한 목적의 TIL 포스팅입니다.🙆‍♂️도입 배경 주문이 급증하는 지역에 소수의 라이더가 존재한다고 가정했을때 고객들의 배송이 지연되는 현상이 발생하게 됨 이때 시스템에선 ‘주문수 대비 라이더가 너무 부족해!’ 라는 경고를 띄우게 됨 이 경고를 해결하고자 ‘주문 유입량 조절’이라는 기능을 사용함 주문량을 줄이기 위해 주문 배달 반경을 일시적으로 축소하는 것 ..." }, { "title": "[Java] Virtual Thread", "url": "/posts/virtual-thread/", "categories": "Backend, Java", "tags": "java", "date": "2025-02-08 00:00:00 +0900", "snippet": " 우아한 테크 세미나 ‘Java의 미래, Virtual Thread’ 학습 내용을 정리하기 위한 포스팅입니다😀1. 일반 Thread 모델일반 스레드 모델은 다음과 같은 특징을 가진다. 플랫폼 스레드 OS에 의해 스케줄링 커널 스레드와 1대1 매핑 작업 단위 Runnable애플리케이션은 커널 영역(OS), 유저 영역(JVM) 두 가지 영역을 통해 실행된다.커널 스레드와 플랫폼 스레드는 1대1로 매핑되며 이 두 사이를 통신하는 과정(유저 영역에서 커널 영역의 기능을 사용)은 JNI(Java Native Interface)..." }, { "title": "Start With Why 내용 정리", "url": "/posts/StartWithWhy-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC/", "categories": "책, StartWithWhy", "tags": "", "date": "2025-02-06 00:00:00 +0900", "snippet": " ‘Start With Why’ 책 내용을 정리하기 위한 목적의 포스팅입니다🙆‍♂️들어가며 진정한 리더는 사람들이 자발적으로 행동하도록 마음 깊이 열의를 준다. 성과보상이나 혜택 같은 외부 요인 없이 목적의식이나 소속감을 심어줄수 있다.1부 방향을 잃어버린 세상1장 - 우리는 착각에 빠져있다 우리는 ‘올바른’ 판단을 내리기 위해 자료를 수집하여 지식과 정보를 바탕으로 결정을 내리고자 한다. 하지만 그렇다고 무조건 올바른 결정이 되는 것은 아니다. 잘못된 가정이 결과로 이어질수도 있고, 아닐수도 있다. 직감이 좋은 결과를..." }, { "title": "첫 스프린트 리딩 회고", "url": "/posts/%EC%B2%AB-%EC%8A%A4%ED%94%84%EB%A6%B0%ED%8A%B8-%EB%A6%AC%EB%94%A9-%ED%9A%8C%EA%B3%A0/", "categories": "회고", "tags": "", "date": "2025-01-28 00:00:00 +0900", "snippet": "스프린트 리더 제의23년 10월 전사 조직 개편과 더불어 스프린트 리더(a.k.a 유닛장) 제의가 들어오게 되었다.구성원 및 상위 리더분들의 신뢰를 받고 있다는 생각들어 뿌듯하면서도, 두 가지 생각이 머릿속을 맴돌았다. 이전 스프린트 리더들을 옆에서 지켜보았을때 일반 스프린트 구성원들보다 많은 미팅 일정들로 실무 개발 시간이 줄어들텐데 지금 나의 연차와 경력에서 옳은 선택인 것일까? 스프린트 구성원일때보다 제품 성장 관점에서 더 많은 퍼포먼스를 내야할텐데 잘할수 있을까?주말 동안의 깊은 고민 끝에 내린 결론은 &#39;새로..." }, { "title": "스프링부트 Actuator 매트릭 데이터독 연동하기", "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-actuator-%EB%A7%A4%ED%8A%B8%EB%A6%AD-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%8F%85-%EC%97%B0%EB%8F%99%ED%95%98%EA%B8%B0/", "categories": "Backend", "tags": "springboot, actuator, datadog", "date": "2025-01-08 00:00:00 +0900", "snippet": "서버 모니터링 및 장애대응시 tomcat threadpool과 hikaricp 관련 메트릭은 중요한 요소다.(경험상 두 메트릭 지표 관련 장애를 몇번 겪었기에 더 뼈저리게 느끼고 있다)이번 포스팅에선 AWS ECS 환경에서 스프링부트의 actuator 를 활용하여 DataDog 에 커스텀 메트릭을 연동했던 트러블슈팅 과정을 기록하고자 한다.실제 적용된 접근 방법만 확인하고 싶으신분들은 ‘접근 방법3’으로 넘어가면 된다.접근 방법1 - Datadog Agent 의 Prometheus Scrape 활용하기위 방법은 실패하였다.스프..." }, { "title": "스프링부트3버전에서 존재하지 않는 리소스 요청시 예외가 발생하는 문제 해결기", "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B83%EB%B2%84%EC%A0%84%EC%97%90%EC%84%9C-%EC%A1%B4%EC%9E%AC%ED%95%98%EC%A7%80-%EC%95%8A%EB%8A%94-%EB%A6%AC%EC%86%8C%EC%8A%A4-%EC%9A%94%EC%B2%AD%EC%8B%9C-%EC%98%88%EC%99%B8%EA%B0%80-%EB%B0%9C%EC%83%9D%ED%95%98%EB%8A%94-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%EA%B8%B0/", "categories": "Spring", "tags": "spring, springboot", "date": "2025-01-03 00:00:00 +0900", "snippet": "spring boot3 버전 마이그레이션후로 ‘/favicon.ico/’ 요청에 대해 500 status 응답이 떨어지는 현상이 발생하였다. api 서버이기에 favicon을 별도 관리하지 않아 고객에게 이어지는 치명적인 상황은 아니었지만 제품운영 관점에서 에러로그가 너무 과도하게 찍히고있어, 실제 고객의 제품 사용 도중 발생한 오류들을 시스템적으로 더 잘 캐치해내기 어려워지다보니 해당 이슈를 해결하게 되었다.(Datadog을 모니터링툴로 사용하고 있다보니 로그 비용 문제도 있다)원인 분석 도중 spring boot 깃허브 레..." }, { "title": "DB Master&amp;Slave Replication", "url": "/posts/DB-Master&Slave-Replication/", "categories": "Backend, Database", "tags": "database, mysql, mariadb, masterslave, mha", "date": "2024-12-30 00:00:00 +0900", "snippet": "고가용성 시스템을 구축하려면 DB 이중화는 필수적인 요소이다.DB 이중화 방식에는 두 가지가 존재한다. Clustering: 여러 개의 DB를 수평적인 구조로 구축하는 방식, 동기 방식으로 노드들 간의 데이터를 동기화 Replication: 여러 개의 DB를 권한에 따라 수직적인 구조(Master-Slave)로 구축하는 방식, 비동기 방식으로 노드들 간의 데이터를 동기화좀 더 자세한 내용은 여기에 자세히 잘 정리되어 있으니 참고하면 좋다.Master &amp;amp; Slave ReplicationDB 이중화 방식중 가장 ..." }, { "title": "Service Mesh", "url": "/posts/Service-Mesh/", "categories": "Backend, MSA", "tags": "msa, servicemesh", "date": "2024-12-29 00:00:00 +0900", "snippet": "기존 모놀리틱 구조에서 MSA로 전환하면서 독립성 및 확장성과 같은 많은 이점을 얻은만큼, 아래와 같은 단점도 존재하였다. 서비스가 분산되어 있어, 서비스간 통신에 복잡성 증가 장애 추적 및 모니터링 어려움 Service Discovery: 호출되는 서비스의 논리적, 물리적 위치가 변경되었을때 호출하는 서비스가 찾기 어려움 Circuit Breaking: 호출되는 서비스에 문제가 있을때 다른 서비스로 전파되지 않도록 하기 위한 추가적인 노력 필요이러한 단점들을 극복하기 위해선 각 마이크로서비스들은 서비스간 내부 통신을 ..." }, { "title": "프로파일러로 시스템 성능 향상시키기", "url": "/posts/%ED%94%84%EB%A1%9C%ED%8C%8C%EC%9D%BC%EB%9F%AC%EB%A1%9C-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%84%B1%EB%8A%A5-%ED%96%A5%EC%83%81%EC%8B%9C%ED%82%A4%EA%B8%B0/", "categories": "Backend", "tags": "slash", "date": "2024-12-26 00:00:00 +0900", "snippet": " 토스 SLASH23 의 ‘프로파일러로 시스템 성능 향상시키기’’ 에 대한 학습 내용을 정리하기 위한 목적의 TIL 포스팅입니다.🙆‍♂️pinpoint MSA 환경에서 클라이언트 요청은 여러 서비스들을 통해 처리되곤하다보니 한 서버의 문제가 다른 서버로 영향을 미치게됨 pinpoint는 분산 트랜잭션 툴 서비스간 호출 확인 및 어느 코드가 얼머나 걸렸는지 알 수 있음 (datadog 처럼)힙덤프 분석으로 Old Gen 개선 사례 한 마이크로서비스에서 old generation 이 다른 서비스에 비해 빠르게 증가하였고,..." }, { "title": "지속 성장 가능한 코드를 만들어 가는 방법", "url": "/posts/%EC%A7%80%EC%86%8D-%EC%84%B1%EC%9E%A5-%EA%B0%80%EB%8A%A5%ED%95%9C-%EC%BD%94%EB%93%9C%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4-%EA%B0%80%EB%8A%94-%EB%B0%A9%EB%B2%95/", "categories": "Backend", "tags": "slash", "date": "2024-12-22 00:00:00 +0900", "snippet": " 토스 SLASH22 의 ‘지속 성장 가능한 코드를 만들어가는 방법’’ 에 대한 학습 내용을 정리하기 위한 목적의 TIL 포스팅입니다.🙆‍♂️ 햄버거 서비스의 생성자를 통해 해당 클래스가 어떤 클래스인지 암시적으로 들어냄. 너무 과한 의존성이 걸려있는게 아닌지 고민 필요 import 문을 기준으로 package, layer, module 세 가지 관점에서 어떤 구조가 지속 성장 가능한 코드인지 설명 예정Package 고정되지 않고 매우 유연해야할것 =&amp;gt; 현재 상황을 계속 점검하면서..." }, { "title": "멀티 모듈 구성", "url": "/posts/%EB%A9%80%ED%8B%B0-%EB%AA%A8%EB%93%88-%EA%B5%AC%EC%84%B1/", "categories": "Backend", "tags": "multimodule", "date": "2024-12-22 00:00:00 +0900", "snippet": "프로젝트를 멀티 모듈로 구성하는것은 아래와 같은 이점들을 챙길 수 있다. 1)계층간 의존성에 대한 제약을 두어 올바른 소프트웨어 아키텍처를 유지하기 위해(ex. api -&amp;gt; domain -&amp;gt; dao 식으로 단방향으로만 유지시키기 위해) =&amp;gt; 관심사의 분리를 통해 단방향으로만 의존하게함으로써 변경으로 인한 영향을 최소화시킬 수 있음 2)모듈간의 적절한 격리를 통해 추후 변경을 용이하게 만들기 위해 (ex. db 를 JPA 를 통해 접근하다 비즈니스 관점에서의 필..." }, { "title": "유용한 MSA 시스템 아키텍처 레퍼런스 모음", "url": "/posts/%EC%9C%A0%EC%9A%A9%ED%95%9C-MSA-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4-%EB%AA%A8%EC%9D%8C/", "categories": "Backend, MSA", "tags": "msa", "date": "2024-12-15 14:00:00 +0900", "snippet": "유용한 MSA 시스템 아키텍처 관련 레퍼런스들을 정리할 예정입니다🤳2200만 사용자를 위한 채팅 시스템 아키텍처 - 서호석 솔루션즈 아키텍트, AWS / 변규현 SW 엔지니어, 당근마켓 :: AWS Summit Korea 2022 - YouTube https://www.youtube.com/watch?v=lCxgddyxDyg&amp;amp;list=PL4S5XWeik_-a5myNy5BJyWoMrznU7DWMb&amp;amp;index=32토스ㅣSLASH 24 - 보상 트랜잭션으로 분산 환경에서도 안전하게 환전하기 https..." }, { "title": "AWS ECS", "url": "/posts/ECS/", "categories": "AWS", "tags": "aws, ecs, fargate, ec2", "date": "2024-12-14 00:00:00 +0900", "snippet": "ECS란?ECS 는 AWS 에서 제공하는 확장성이 뛰어나고 빠른 컨테이너 오케스트레이션 서비스이다. 이를 사용하여 클러스터에서 컨테이너를 실행, 중지 및 관리할 수 있다.ECS 구성 요소ECS 는 ECR, Task Definition, ECS Task, ECS Service, ECS Cluster 로 이루어진다. ECR: 컨테이너 이미지 저장소 Task Definition: 컨테이너를 실행하기 위해 정의한 설정 ECS Task: ECS Server(EC2 or Fargate)에 실제 실행되는 컨테이너 그룹(Docker 어..." }, { "title": "JSON 스키마 LLM 연동", "url": "/posts/JSON-%EC%8A%A4%ED%82%A4%EB%A7%88-LLM-%EC%97%B0%EB%8F%99/", "categories": "Backend", "tags": "llm", "date": "2024-12-13 00:00:00 +0900", "snippet": "LLM 기반 인터뷰 기능을 개발하면서 질문에 대한 사용자 답변이 지정된 평가 기준들에 부합하는지를 LLM 을 통해 피드백 받는 로직을 구현하면서 LLM 응답을 단순 텍스트 파싱처리외에 좀 더 안전하게 처리할 수 있는 방법이 없을까 고민하다 Structured Outputs(구조화된 출력)에 대해 알게 되었다.또한 이전까지 제품에서의 대부분은 LLM 기능은 응답을 텍스트로만 받아 파싱하여 처리하는 구조다보니 가끔 잘못된 형식을 응답받을때가 있어 애플리케이션 로직상에서 예외처리를 해줬었다.== prompt ===### Role##..." }, { "title": "AWS AMI &amp; EBS 를 활용한 백업", "url": "/posts/AMI-&-EBS-%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%B0%B1%EC%97%85/", "categories": "AWS", "tags": "aws, ec2, ami, ebs", "date": "2024-12-02 00:00:00 +0900", "snippet": "EC2 백업서버 관리에서 필수적인 요소중 하나는 백업이다. EC2 를 백업 및 복원하기 위해 사용할 수 있는 방법은 1)AMI 이미지를 통해 EC2 정보를 저장하거나 2)EBS 스냅샷에 데이터를 저장하는 방법이 있다.AMIAMI 란?출처: https://inpa.tistory.com/entry/AWS-📚-AMI-Snapshot-개념-백업-사용법-💯-정리#ami_와_snapshot_의_차이점AMI는 EC2 인스턴스를 실행하기 위한 정보를 모은 단위이다.즉 AMI란 서버에 필요한 운영체제, 저장공간 용향, CPU 프로세서 타입, ..." }, { "title": "[Java] ZonedDateTime vs OffsetDateTime", "url": "/posts/ZonedDateTime-vs-OffsetDateTime/", "categories": "Backend, Java", "tags": "java", "date": "2024-11-25 00:00:00 +0900", "snippet": "출처: https://jodmsoluth.tistory.com/5OffsetDateTime LocalDateTime(날짜 + 시간) + offset(UTC와의 차이) 을 포함한다. Instant와 같이 나노초 정밀도로 타임라인에 순간을 저장한다. ZoneId의 구현체인 ZoneOffset으로 offset(UTC와의 차이)을 나타낸다.ZonedDateTime OffsetDateTime(날짜 + 시간 + offset) + timezone(지역) 을 포함한다. ZoneId의 구현체인 ZoneRegion으로 타임존을 나타낸다..." }, { "title": "AWS 3Tier 구축", "url": "/posts/AWS-3Tier-%EA%B5%AC%EC%B6%95/", "categories": "AWS", "tags": "aws, 3tier", "date": "2024-11-20 00:00:00 +0900", "snippet": "AWS 3Tier 아키텍처란3-tier 아키텍처는 웹 애플리케이션을 3개의 논리적 및 물리적 계층으로 분할하는 가장 널리 사용되는 아키텍처 패턴입니다.계층 구성1. Presentation Tier 사용자가 직접 접근하는 인터페이스 계층 HTML, JavaScript, CSS 등으로 구성 데스크톱 애플리케이션, 모바일 앱, 웹페이지, IoT 장치 등 다양한 형식 지원2. Login(Application) Tier 비즈니스 로직이 실행되는 계층 데이터 처리 및 비즈니스 규칙 적용3. Data Tier 데이터 저장 및 관..." }, { "title": "만들면서 배우는 클린 아키텍처 내용 정리", "url": "/posts/%EB%A7%8C%EB%93%A4%EB%A9%B4%EC%84%9C-%EB%B0%B0%EC%9A%B0%EB%8A%94-%ED%81%B4%EB%A6%B0%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC/", "categories": "책, 만들면서배우는클린아키텍처", "tags": "cleanarchitecture", "date": "2024-11-11 00:00:00 +0900", "snippet": " ‘만들면서 배우는 클린 아키텍처’ 기술 서적을 읽고 학습 내용을 정리하기 위한 목적의 TIL 포스팅입니다🙆‍♂️ 예제코드는 깃허브 레포지토리를 참고해주세요.시작하기전 추천사 (객체지향의 사실과 오해 저자 조영호) 클린아키텍처의 핵심은 의존성 방향으로 비즈니스 로직이 외부 요소에 존재하지 않고 프레젠테이션 계층과 데이터 소스 계층이 도메인 계층에 의존하도록 만들어야 한다는 것이다. 애플리케이션은 비즈니스 관심사를 다루는 내부(inside)와 기술적인 관심사를 다루는 외부(outside)로 분해된다. 여기서 외부에 포함된 ..." }, { "title": "[디자인패턴] Visitor 패턴", "url": "/posts/Visitor%ED%8C%A8%ED%84%B4/", "categories": "CS, 디자인패턴, 행위패턴", "tags": "designpattern, visitor", "date": "2024-11-06 00:00:00 +0900", "snippet": "개요Visitor(방문자)패턴은 방문자와 방문 공간을 분리하여 방문 공간이 방문자를 맞이할 때, 이후에 대한 행동을 방문자에게 위임하는 패턴이다. 클래스 다이어그램은 아래 이미지와 같다.출처: https://brownbears.tistory.com/575예제아래 예제는 문서 변환 시스템에 적용한 예제이다.DocumentElement 인터페이스의 구체 클래스들은 실제 방문 공간이고 DocumentVisitor(MarkdownVisitor, HtmlExportVisitor, 방문자)에게 방문 공간을 맞이할때 수행할 책임들을 위임해..." }, { "title": "AWS TGC 내용 정리", "url": "/posts/AWS-TGC-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC/", "categories": "AWS", "tags": "aws, network, ecs, serverless, cicd", "date": "2024-10-22 00:00:00 +0900", "snippet": "2주차 세션: AWS 네트워크의 이해 S3 는 VPC에 종속적이지 않는다. RFC1918 (private IP 표준)에 따르면 사설망 내부 IP대역을 할당시 특정 대역 IP를 미리 사용하기로 약속한다. IP의 앞 구역을 몇자리를 고정할건지에 따라 사용할 IP대역이 결정되며 크게 3가지로 나뉘어진다. IP 대역 CIDR 10.0.0.0 10.255.255.255(10/8 prfix) 172.16.0.0 172.31.255.25..." }, { "title": "MySQL VARCHAR vs TEXT", "url": "/posts/MySQL-VARCHAR-vs-TEXT/", "categories": "Backend, Database", "tags": "database, mysql, mariadb", "date": "2024-09-23 00:00:00 +0900", "snippet": "글자수 제한이 큰 데이터를 저장해야하는 요구사항에 대해 데이터 모델링 작업을 진행하게 되었다.그러면서 mysql 의 varchar 타입과 text 타입의 차이점에 대한 차이점에 대해 정리하게 되었다.먼저 결론은 다음과 같다. 물론 DBMS 서버스펙이나 데이터 모델 그리고 유입되는 트래픽에 따라서 미치는 영향도가 다를수 있다는점을 감안해야 한다.VARCHAR 최대 길이가 (상대적으로) 크지 않은 경우 테이블 데이터를 읽을 때 항상 해당 컬럼이 필요한 경우 DBMS 서버의 메모리가 (상대적으로) 충분한 경우TEXT 최대 길..." }, { "title": "swagger 사용시 패키지가 다른 동일 클래스를 구별하지 못하는 이슈", "url": "/posts/swagger-%EC%82%AC%EC%9A%A9%EC%8B%9C-%ED%8C%A8%ED%82%A4%EC%A7%80%EA%B0%80-%EB%8B%A4%EB%A5%B8-%EB%8F%99%EC%9D%BC-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A5%BC-%EA%B5%AC%EB%B3%84%ED%95%98%EC%A7%80-%EB%AA%BB%ED%95%98%EB%8A%94-%EC%9D%B4%EC%8A%88/", "categories": "Spring", "tags": "spring, springboot, oas3, swagger", "date": "2024-08-26 00:00:00 +0900", "snippet": "자바/스프링부트 기반 애플리케이션에서 응답 모델 구현시 inner 클래스명이 겹치다보면swagger-ui 에서 클래스를 정확하게 구분하지 못하는 이슈가 생길수 있다.아래 출처 포스팅 내용처럼 use-fqn 옵션을 활용하면 Schema 가 패키지를 포함하여 관리되므로위와 같은 이슈를 해결할 수 있다. 자세한 내용은 출처 포스팅에 잘 정리되어 있어 참고하면 된다.출처 https://findmypiece.tistory.com/360" }, { "title": "[디자인패턴] 상태 패턴(State Pattern)", "url": "/posts/%EC%83%81%ED%83%9C%ED%8C%A8%ED%84%B4/", "categories": "CS, 디자인패턴, 구조패턴", "tags": "designpattern, statepattern", "date": "2024-02-29 16:45:00 +0900", "snippet": "아래 출처 포스팅이 정리가 잘 되어 있습니다.기록용으로 남깁니다😊출처 https://johngrib.github.io/wiki/pattern/state/" }, { "title": "AWS ECS 기반 MSA 환경에서 서버리스 스케줄링 아키텍처 구축기", "url": "/posts/AWS-ECS-%EA%B8%B0%EB%B0%98-MSA-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4-%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B5%AC%EC%B6%95%EA%B8%B0/", "categories": "Backend", "tags": "aws, ecs, msa, eventbridge, lambda, kafka", "date": "2023-10-01 00:00:00 +0900", "snippet": "배경제품 비즈니스 요구사항중 휴직이 시작/종료된 구성원들에 대해 재직상태를 즉시 갱신시켜줘야 하는 요구사항이 도출되었다.(이전까지는 관리자가 수동으로 재직상태를 업데이트 해주는 방식이었음)AWS ECS 기반 MSA 환경에서 첫 스케줄링이 필요한 요구사항이었고 이를 해결하고자 시작하게 되었다.클라우드 아키텍처 설계이전까지 사내 프로젝트들은 모놀리틱 아키텍처로 스케줄링 요구사항은 단일 EC2 인스턴스에 스프링 애플리케이션을 배포하여 @Scheduled 어노테이션 기반으로 구현되어 있었다.하지만 단일 EC2 인스턴스에 대한 인프라프..." }, { "title": "AWS 서버리스 아키텍처 기반 2,000여명 고객사 인사데이터 동기화 시스템 구축기", "url": "/posts/AWS-%EC%84%9C%EB%B2%84%EB%A6%AC%EC%8A%A4-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EA%B8%B0%EB%B0%98-2,000%EC%97%AC%EB%AA%85-%EA%B3%A0%EA%B0%9D%EC%82%AC-%EC%9D%B8%EC%82%AC%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%8F%99%EA%B8%B0%ED%99%94-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EA%B5%AC%EC%B6%95%EA%B8%B0/", "categories": "Backend", "tags": "aws, lambda, eventbridge, s3", "date": "2023-09-01 00:00:00 +0900", "snippet": "배경임직원 규모가 1,000명 이상인 기업에선 자사 인사 관리 시스템(HCM)과 외부 서드 파티 솔루션의 임직원 데이터를 이중화 관리해야 하는 번거로움이 존재한다.Open API가 구축되지 않은 상황에서 위 문제를 해결하기 위해 고객사에서 동기화 시스템 구축을 제품 도입 조건으로 제안하게되어 시작하게 되었다.클라우드 아키텍처 설계이전까지 사내에서 스케줄링 요구사항은 단일 EC2 인스턴스에 스프링 애플리케이션을 배포하여 @Scheduled 어노테이션 기반으로 구현되어 있었다.하지만 기존 방식의 EC2 인스턴스 프로비저닝 작업,..." }, { "title": "[클린아키텍처] 12 ~ 14장", "url": "/posts/%ED%81%B4%EB%A6%B0%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-12~14%EC%9E%A5/", "categories": "책, 클린아키텍처", "tags": "cleanarchitecture", "date": "2023-07-25 00:00:00 +0900", "snippet": " ‘클린 아키텍처’ 기술 서적에 대해 학습했던 내용을 정리하기 위한 목적의 TIL 포스팅입니다.🙆‍♂️4부 - 컴포넌트 원칙 SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해준다. 큰 빌딩과 마찬가지로 대규모 소프트웨어 시스템은 작은 컴포넌트들로 만들어진다.12장 - 컴포넌트 컴포넌트가 무엇인지 컴포넌트의 역사에 대해 설명하는 내용이다. 크게 중요한 내용은 많지 않아서 컴포넌트가 무엇인지 그리고 어떻게 소프트웨어가 발전하게 되었는지를 가볍게 보면 좋다. ..." }, { "title": "클린아키텍처 내용 정리", "url": "/posts/0%ED%81%B4%EB%A6%B0%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC/", "categories": "책, 클린아키텍처", "tags": "cleanarchitecture", "date": "2023-07-05 00:00:00 +0900", "snippet": " ‘클린 아키텍처’ 기술 서적에 대해 학습했던 내용을 정리하기 위한 목적의 TIL 포스팅입니다.🙆‍♂️1부 - 소개1장 - 설계와 아키텍처란?목표는? 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는데 투입되는 인력을 최소화하는데 있다. 새로운 기능을 출시할 때 마다 비용이 증가한다면 나쁜 설계라 볼수 있다.사례 연구 ~ 무엇이 잘못되었나? 한 소프트웨어 개발 회사 몇년 동안 계속 개발 인력을 기하급수적으로 늘려가는데, 그에 비해 생산성 및 비용 그리고 매출이 현저하게 떨어진 사례가 있다. 위 사례의 근..." }, { "title": "[Java] HashSet은 어떠한 이유로 순서를 보장하지 않을까", "url": "/posts/HashSet%EC%9D%80-%EC%96%B4%EB%96%A0%ED%95%9C-%EC%9D%B4%EC%9C%A0%EB%A1%9C-%EC%88%9C%EC%84%9C%EB%A5%BC-%EB%B3%B4%EC%9E%A5%ED%95%98%EC%A7%80-%EC%95%8A%EC%9D%84%EA%B9%8C/", "categories": "Backend, Java", "tags": "java", "date": "2023-07-04 00:00:00 +0900", "snippet": "HashSet 은 중복을 허용하지 않고 순서를 보장하지 않는다는 것은 많은 이들이 알고 있을 것이다.그러면 어떠한 이유로 인해 순서를 보장하지 않을까? 라고 접근해봤을때 아주 잘 정리된 포스팅이 있어 여기를 참고하면 좋다.(✨정독 강추✨)짧게 요약하면 다음과 같다.HashSet 은 내부적으로 HashMap 으로 구현되어 있다.Key Object에 저장하고 싶은 객체를 저장하고, Value Object에는 dummy data를 넣어 둔다.Map의 Key 는 고유해야하기 때문에 중복을 허용하지 않는 것이다.그러면 어떻게 객체를 고..." }, { "title": "객체지향의 사실과 오해 내용 정리", "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B4-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC/", "categories": "책, 객체지향의사실과오해", "tags": "oop", "date": "2023-06-23 00:00:00 +0900", "snippet": " ‘객체지향의 사실과 오해’ 학습 내용을 정리하기 위한 목적의 TIL 포스팅입니다🙆‍♂️Chapter1-협력하는 객체들의 공동체 객체지향의 목표는 실세계를 모방하는 것이 아니라 새로운 세계를 창조하는 것이다.협력하는 사람들커피 공화국의 아침 손님, 캐시어, 바리스타는 주문한 커피를 손님에게 제공학 위해 협력하는 과정에서 자신이 맡은 바 책임을 다한다. 손님은 카페인을 채우기 위해 커피를 주문할 책임을, 캐시어는 손님의 주문을 받는 책임을, 바리스타는 주문된 커피를 제조하는 책임을 객체지향에서 ..." }, { "title": "AWS Lambda 개요", "url": "/posts/Lambda-%EA%B0%9C%EC%9A%94/", "categories": "AWS, Lambda", "tags": "aws, lambda", "date": "2023-05-26 00:00:00 +0900", "snippet": "아래 출처 포스팅이 정리가 잘 되어 있습니다.기록용으로 남깁니다😊출처 https://inpa.tistory.com/entry/AWS-%F0%9F%93%9A-%EB%9E%8C%EB%8B%A4Lambda-%EA%B0%9C%EB%85%90-%EC%9B%90%EB%A6%AC" }, { "title": "JWT 저장 위치", "url": "/posts/JWT-%EC%A0%80%EC%9E%A5-%EC%9C%84%EC%B9%98/", "categories": "Backend, Security", "tags": "jwt, localstorage, cookie", "date": "2023-05-23 00:00:00 +0900", "snippet": " 액세스 토큰은 프로그램상 자바스크립트 로컬 변수에 저장하고, http 헤더에 bearer 토큰으로 담아서 매 요청마다 보내도록 하자. 액세스 토큰을 쿠키에 담으면 CSRF 공격에 취약해진다. 즉, 해커가 내 인증정보를 활용해서 서버에 나인것처럼 속여서 요청을 보낼 수 있게 된다. 로컬스토리지는 사용하지 말자. (보안에 매우 취약) 브라우저의 로컬스토리지는 정말 편리하지만 XSS를 방어할 수 있는 방법이 없다. 단, 이 쿠키가 Http Only이며 Secure(h..." }, { "title": "읽으면 유용한 Architecture 칼럼 모음", "url": "/posts/%EC%9D%BD%EC%9C%BC%EB%A9%B4-%EC%9C%A0%EC%9A%A9%ED%95%9C-Architecture-%EC%B9%BC%EB%9F%BC-%EB%AA%A8%EC%9D%8C/", "categories": "Architecture", "tags": "architecture", "date": "2023-04-28 00:00:00 +0900", "snippet": "Reference https://medium.com/coupang-engineering/%EB%8C%80%EC%9A%A9%EB%9F%89-%ED%8A%B8%EB%9E%98%ED%94%BD-%EC%B2%98%EB%A6%AC%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%BF%A0%ED%8C%A1%EC%9D%98-%EB%B0%B1%EC%97%94%EB%93%9C-%EC%A0%84%EB%9E%B5-184f7fdb1367#6884 https://interviewnoodle.com/hotel-booking-system-d..." }, { "title": "도메인 주도 개발 시작하기 내용 정리", "url": "/posts/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC/", "categories": "책, 도메인주도개발시작하기", "tags": "ddd, dddstart", "date": "2023-04-23 16:10:00 +0900", "snippet": "Chapter1-도메인 모델 시작도메인 온라인 서점(쇼핑몰) 소프트웨어는 온라인으로 책을 판매하는데 필요한 상품조회, 구매, 결제, 배송 추적 등의 기능을 제공해야 한다. 이때 ‘온라인 서점’은 소프트웨어로 해결하고자 하는 문제 영역, 즉 도메인에 해당한다. 한 도메인은 다시 하위 도메인으로 나눌 수 있다.[그림1.1] 도메인은 여러 하위 도메인으로 구성된다. 카탈로그 하위 도메인은 고객에게 구매할 수 있는 상품 목록을 제공하고, 주문 하위 도메인은 고객의 주문을 처리한다. 한 하위 도메인은 다른 하위 ..." }, { "title": "클린코드 내용 정리", "url": "/posts/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC/", "categories": "책, 클린코드", "tags": "cleancode", "date": "2023-04-17 00:00:00 +0900", "snippet": "Chapter5-형식 맞추기프로그래머라면 형식을 깔끔하게 맞춰 코드를 짜야 한다. 코드 형식을 맞추기 위한 간단한 규칙을 정하고 그 규칙을 착실히 따라야 한다. 팀으로 일한다면 팀이 합의해 규칙을 정하고 모두가 그 규칙을 따라야 한다. 필요하다면 규칙을 자동으로 적용하는 도구를 활용한다. (ex. intellij의 codestyle이 이러한 도구 중 하나가 될 것 같다)형식을 맞추는 목적 코드 형식은 중요하다! 오늘 구현한 기능이 다음 버전에서 ㅂ바뀔 확률은 아주 높다. 그런데 오늘 구현한 코드의 가독성은 ..." }, { "title": "DB 마이그레이션을 위한 flyway", "url": "/posts/DB-%EB%A7%88%EC%9D%B4%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%85%98%EC%9D%84-%EC%9C%84%ED%95%9C-flyway/", "categories": "Backend", "tags": "dbmigration, flyway", "date": "2023-04-12 00:00:00 +0900", "snippet": "DB 스키마 형상을 소스 코드가 아닌 DB 테이블로 관리하기 위한 툴로 flyway를 많이 사용한다.flyway의 동작 방식과 관련해선 여기를 참고하면 이해하기 수월하다.그리고 여기를 참고했을 때 DB 스키마에 변경사항이 생겼지만 스크립트 파일을 누락한 경우 애플리케이션이 실행되지 않는 불상사가 발생하여 주의해야 한다고 한다.출처 https://velog.io/@hyun-jii/Flyway-%EC%A0%95%EC%9D%98-DB-%EB%A7%88%EC%9D%B4%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%85%98..." }, { "title": "[MSA] Kafka 도메인 이벤트 순서 보장하기", "url": "/posts/Kafka-%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%88%9C%EC%84%9C-%EB%B3%B4%EC%9E%A5%ED%95%98%EA%B8%B0/", "categories": "Backend, MSA", "tags": "msa, kafka", "date": "2023-04-08 15:00:00 +0900", "snippet": "MSA환경에서 Kafka를 활용한 데이터 동기화 포스팅에서 MSA환경에서 카프카를 활용하여 두 마이크로서비스간의 데이터를 동기화하기 위한 방법들에 대해 알아보았고 아래 이미지처럼 4가지 경우의 수에 대해서 알아보았다.도메인 이벤트별 토픽 나누는 방식에서 도출될 수 있는 문제(3, 4)도메인 이벤트별 토픽을 나누는 방식(ex. order-create-topic, order-cancel-topic, order-change-topic)에서 도출될 수 있는 문제로는 컨슈머의 처리 순서에 대해 보장할 수 없다는 점이다.예를 들어, 주문..." }, { "title": "[MSA] Kafka 도메인 이벤트 순서 보장 문제 해결기", "url": "/posts/Kafka-%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%88%9C%EC%84%9C-%EB%B3%B4%EC%9E%A5-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%EA%B8%B0/", "categories": "Backend, MSA", "tags": "msa, kafka", "date": "2023-04-08 15:00:00 +0900", "snippet": "https://jeonyoungho.github.io/posts/Kafka-도메인-이벤트-순서-보장하기위 포스팅과 연관된 실제 도메인 이벤트 순서 보장 문제 해결 기록을 남기고자 합니다😀배경현재 MSA 환경에서 제품내 인사 데이터(코드, 조직, 구성원)는 Kafka 도메인 이벤트 기반으로 동기화 되고 있다.cms 서비스로부터 인사 데이터 변경이 발생되면 Kafka 도메인 이벤트를 발행하고 각 마이크로서비스에서 Zero-Payload 방식으로 동기화를 시켜주고 있다. 이때 도메인 이벤트별 토픽(code-create-topic, ..." }, { "title": "[MSA] MSA환경에서 Kafka를 활용한 데이터 동기화", "url": "/posts/MSA%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C-Kafka%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%8F%99%EA%B8%B0%ED%99%94/", "categories": "Backend, MSA", "tags": "msa, kafka", "date": "2023-04-08 14:00:00 +0900", "snippet": "MSA 로 구성된 환경에서 카프카를 활용하여 도메인 이벤트를 기반으로 처리를 할 땐 아래 요소들을 고민해야 한다. 어떤 방식으로 데이터를 주고 받을 것인지? (Full-Payload 방식 or Zero-Payload 방식) 토픽을 어떻게 나눌 것인지?(도메인 이벤트를 기준으로 나눌 것인지 or 도메인 기준으로 나눌 것인지)위 두 가지 사항에 대해 먼저 고민해보자.아래 설명에서 사용되는 예제로는 두 마이크로서비스(주문서비스, 배송서비스)를 기준으로 설명할 것이다.1) 어떤 방식으로 데이터를 주고 받을 것인지?아래에서 설명하겠..." }, { "title": "함께자라기 내용 정리", "url": "/posts/0%ED%95%A8%EA%BB%98%EC%9E%90%EB%9D%BC%EA%B8%B0-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC/", "categories": "책, 함께자라기", "tags": "", "date": "2023-03-27 00:00:00 +0900", "snippet": "[함께] 빠르고 빈번한 바통 터치가 가능한 전문가 조직제시 제임스 개럿(Jesse James Garrett)의 저서 «사용자 경험의 요소»에선 웹개발에서 추상화의 단계를 다섯 면으로 나눈다. 전략(strategy) 범위(scope) 구조(structure) 뼈대(skeleton) 표면/비쥬얼(surface/visual)우리가 전문가의 이미지를 잘못 가지고 있다면 전문가가 다음과 같이 일을 처리하리라 생각하기 쉽다. ‘전략이 깔끔히 완료되고 나서야 범위(무슨 기능이 들어갈지 결정)를 정하고, 다음에 구조(기능들을 어떻..." }, { "title": "Kafka Connect란", "url": "/posts/Kafka-Connect-%EB%9E%80/", "categories": "Backend, MSA", "tags": "msa, kafka, kafkaconnect", "date": "2023-03-10 00:00:00 +0900", "snippet": "출처 https://cjw-awdsd.tistory.com/53 https://sihyung92.oopy.io/architecture/cdc https://hoing.io/archives/5285" }, { "title": "CircuitBreaker 개요 및 Resilence4J 를 활용한 실습", "url": "/posts/CircuitBreaker-%EA%B0%9C%EC%9A%94-%EB%B0%8F-Resilence4J-%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%9C-%EC%8B%A4%EC%8A%B5/", "categories": "Backend, MSA", "tags": "msa, microservicearchitecture, circuitbreaker, hystrix, resilience4j", "date": "2023-01-20 00:00:00 +0900", "snippet": "써킷 브레이커 패턴써킷 브레이커는 누전 차단기라는 뜻을 가진다. 누전차단기는 전기 회로에서 과부하가 걸리거나 단락으로 인한 피해를 막기 위해 자동으로 회로를 정지시키는 장치이다.MSA 로 구성된 환경에서 여러 마이크로서비스들이 존재하고 내부 internal-api 로 통신을 하게 되어 서비스가 운영된다.예를 들어, 아래 그림과 같이 Display 마이크로서비스가 Product, Delivery, Order 마이크로서비스와 내부적인 통신을 가진다고 들어보자.만약, Product 서비스에 장애가 났다고 가정해보자.그럴 경우 이를 ..." }, { "title": "[이펙티브자바] 아이템89-인스턴스 수를 통제해야 한다면 readResolve 보다는 열거 타입을 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C89-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4-%EC%88%98%EB%A5%BC-%ED%86%B5%EC%A0%9C%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4%EB%A9%B4-readResolve-%EB%B3%B4%EB%8B%A4%EB%8A%94-%EC%97%B4%EA%B1%B0-%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2023-01-17 00:00:00 +0900", "snippet": " 핵심 정리: 불변식을 지키기 위해 인스턴스를 통제해야 한다면 가능한 한 열거 타입을 사용하자. 여의치 않은 상황에서 직렬화와 인스턴스 통제가 모두 필요하다면 readResolve 메서드를 작성해 넣어야 하고, 그 클래스에서 모든 참조 타입 인스턴스 필드를 transient 로 선언해야 한다.싱글턴 인스턴스의 직렬화 앞선 아이템 3에서는 아래와 같은 싱글턴 패턴 예제를 보았다. public static final 필드를 사용하는 방식이다. 생성자는 private 접근 지정자로 선언하여 외부로부터 감추고 INSTANCE를 ..." }, { "title": "[이펙티브자바] 아이템88-readObject 메서드는 방어적으로 작성하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C88-readObject-%EB%A9%94%EC%84%9C%EB%93%9C%EB%8A%94-%EB%B0%A9%EC%96%B4%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%9E%91%EC%84%B1%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2023-01-17 00:00:00 +0900", "snippet": " 핵심 정리: readObject 메서드를 작성할 때는 언제나 public 생성자를 작성하는 자세로 임해야 한다. readObject는 어떤 바이트 스트림이 넘어오더라도 유효한 인스턴스를 만들어내야 한다. 바이트 스트림이 진짜 직렬화된 인스턴스라고 가정해선 안된다. 이번 아이템에서 기본 직렬화 형태를 사용한 클래스를 예로 들었지만, 커스텀 직렬화를 사용하더라도 모든 문제가 그대로 발생할 수 있다. 이어서 안전한 readObject 메서드를 작성하는 지침을 요약해보았다. private 이어야 하는 객체 참조 필드는 각..." }, { "title": "[Architecture] 헥사고날아키텍처", "url": "/posts/%ED%97%A5%EC%82%AC%EA%B3%A0%EB%82%A0%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98/", "categories": "Architecture", "tags": "architecture, hexagonalarchitecture", "date": "2023-01-05 00:00:00 +0900", "snippet": "Reference https://mesh.dev/20210910-dev-notes-007-hexagonal-architecture/ https://happy-coding-day.tistory.com/entry/%ED%97%A5%EC%82%AC%EA%B3%A0%EB%82%A0-%EC%95%84%ED%82%A4%ED%85%8D%EC%B2%98Hexagonal-Architecture-%EC%BD%94%EB%93%9C%EB%A1%9C-%EC%9D%B4%ED%95%B4%ED%95%B4%EB%B3%B4%EA%B8%B0-%EB%AF%B..." }, { "title": "[이펙티브자바] 아이템83-지연 초기화는 신중히 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C83-%EC%A7%80%EC%97%B0-%EC%B4%88%EA%B8%B0%ED%99%94%EB%8A%94-%EC%8B%A0%EC%A4%91%ED%9E%88-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2023-01-02 00:00:00 +0900", "snippet": " 핵심 정리: 대부분의 필드는 지연시키지 말고 곧바로 초기화해야 한다. 성능 때문에 혹은 위험한 초기화 순환을 막기 위해 꼭 지연 초기화를 써야 한다면 올바른 지연 초기화 기법을 사용하자. 인스턴스 필드에는 이중검사 관용구를, 정적 필드에는 지연 초기화 홀더 클래스 관용구를 사용하자. 반복해 초기화해도 괜찮은 인스턴스 필드에는 단일검사 관용구도 고려 대상이다.지연 초기화 필드의 초기화 시점을 그 값이 처음 필요할 때까지 늦추는 기법이다. 값이 전혀 쓰이지 않으면 초기화도 결코 일어나지 않게 된다. 주로 최적화 용도에 사..." }, { "title": "[이펙티브자바] 아이템80-스레드보다는 실행자, 태스크, 스트림을 애용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C80-%EC%8A%A4%EB%A0%88%EB%93%9C%EB%B3%B4%EB%8B%A4%EB%8A%94-%EC%8B%A4%ED%96%89%EC%9E%90-%ED%83%9C%EC%8A%A4%ED%81%AC-%EC%8A%A4%ED%8A%B8%EB%A6%BC%EC%9D%84-%EC%95%A0%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2023-01-02 00:00:00 +0900", "snippet": "실행자 프레임워크(Executor Framework) 인터페이스 기반의 유연한 태스크 실행 기능을 담고 있음 아래 한 줄로 생성 가능하다.ExecutorService exec = Executors.newSinleThreadExecutor(); 실행할 테스크(task; 작업)을 넘기고자 한다면 아래와 같이 Runnable 을 구현한 구현체를 넘기면 된다.exec.execute(runnable); 만약 실행자를 우아하게 종료하고자 한다면 아래와 같은 코드를 한 줄 실행시키면 된다.(이 작업이 실패하면 VM 자체가 종료 되지..." }, { "title": "[Database] charset과 collation", "url": "/posts/charset%EA%B3%BC-collation/", "categories": "Backend, Database", "tags": "database, mysql, mariadb", "date": "2022-12-16 00:00:00 +0900", "snippet": "MySQL 또는 MariaDB 를 사용하여 컬럼에 unqiue 제약 조건을 걸었더니 대소문자를 구별하지 않는 것을 새로 알게 되었고 그 이유에 대해서 알아보았다.즉, AAA 와 aaa 와 동일하게 취급하여 유니크 제약 조건으로 인해 둘 중 하나의 insert가 안되는 것이다.unquie 제약 조건을 추가하는 DDL 명령어는 아래와 같다.ALTER TABLE `테이블명` ADD UNIQUE KEY 제약조건명 (`컬럼명`);그리고 해당 테이블 DDL 컬럼에는 아래와 같이 명시가 되어 있었다.create table (`column_..." }, { "title": "[이펙티브자바] 아이템75-예외의 상세 메시지에 실패 관련 정보를 담으라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C75-%EC%98%88%EC%99%B8%EC%9D%98-%EC%83%81%EC%84%B8-%EB%A9%94%EC%8B%9C%EC%A7%80%EC%97%90-%EC%8B%A4%ED%8C%A8-%EA%B4%80%EB%A0%A8-%EC%A0%95%EB%B3%B4%EB%A5%BC-%EB%8B%B4%EC%9C%BC%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-12-13 00:00:00 +0900", "snippet": "사후 분석을 위해 실패 순간의 상황을 정확히 포착해 예외의 상세 메시지에 담아야 한다. 예외를 잡지 못해 프로그램이 실패하면 자바 시스템은 그 예외의 stack trace 를 자동으로 출력한다. stack tract 는 예외 객체의 toString 메서드를 호출해 얻는 문자열로 보통은 예외 클래스 이름 뒤에 상세 메시지가 붙는 형태다. 이 정보가 실패 원인을 분석해야 하는 개발자들에겐 유일한 정보일 경우가 많기 때문에 예외의 메시지를 상세하게 담는게 중요하다.실패 순간을 포착하려면 발생한 예외의 관여된 모든 매개변수와 필..." }, { "title": "[이펙티브자바] 아이템73-추상화 수준에 맞는 예외를 던지라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C73-%EC%B6%94%EC%83%81%ED%99%94-%EC%88%98%EC%A4%80%EC%97%90-%EB%A7%9E%EB%8A%94-%EC%98%88%EC%99%B8%EB%A5%BC-%EB%8D%98%EC%A7%80%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-12-13 00:00:00 +0900", "snippet": " 핵심 정리: 아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라. 이때 예외 연쇄를 이용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에 좋다.메서드가 저수준 예외를 처리하지 않고 바깥으로 전파하면 윗 레벨 API를 오염시킨다.위 문제를 피하려면 상위 계층에서는 저수준 예외를 잡아 자신의 추상화 수준에 맞는 예외로 바꿔던져야 한다. 이를 예외 번역(exception translation)이라 한다..." }, { "title": "[디자인패턴] Delegate 패턴", "url": "/posts/Delegate%ED%8C%A8%ED%84%B4/", "categories": "CS, 디자인패턴, 행위패턴", "tags": "designpattern, delegate", "date": "2022-12-06 00:00:00 +0900", "snippet": "제품 개발을 하면서 ~Delegate 라는 클래스들을 자주 접하게 되었다.관련해서 찾아보니 Delegate Pattern 이라는 디자인 패턴을 적용한 것이었다.위 이미지에서 알 수 있다시피 모바일 앱 개발에서 자주 사용되는 패턴인 듯하다.Delegate 패턴이란?Delegate 패턴이란 위임자 패턴이라 불려진다. 쉽게 설명하면 OOP에서 한 객체가 모든 일을 수행하는 것이 아닌 어떤 일 중 일부를 다른 객체(Helper Object) 에게 위임하는 패턴이다.아래 첫 번째 출처에 기재된 블로그에서 Delegate 패턴에 대해 쉽..." }, { "title": "[이펙티브자바] 아이템70-복구할 수 있는 상황에는 검사 예외를 프로그래밍 오류에는 런타임 예외를 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C70-%EB%B3%B5%EA%B5%AC%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%83%81%ED%99%A9%EC%97%90%EB%8A%94-%EA%B2%80%EC%82%AC-%EC%98%88%EC%99%B8%EB%A5%BC-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%98%A4%EB%A5%98%EC%97%90%EB%8A%94-%EB%9F%B0%ED%83%80%EC%9E%84-%EC%98%88%EC%99%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-11-29 00:00:00 +0900", "snippet": " 핵심 정리: 복구할 수 있는 상황이면 검사 예외를, 프로그래밍 오류라면 비검사 예외를 던지자. 확실하지 않다면 비검사 예외를 던지자. 검사 예외도 아니고 런타임 예외도 아닌 Throwable은 정의하지도 말자. 검사 예외라면 복구에 필요한 정보를 알려주는 메서드도 제공하자.자바는 문제 상황을 알리는 타입(throwable)으로 검사 예외, 런타임 예외, 에러 이렇게 세 가지를 제공한다. 이 세 가지를 언제 사용하는지 명확히 알고 사용하자.검사 예외(Checked Exception) 호출하는 쪽에서 복구하리라 여겨지는 상황..." }, { "title": "[이펙티브자바] 아이템69-예외는 진짜 예외 상황에만 사용하라 신중히 하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C69-%EC%98%88%EC%99%B8%EB%8A%94-%EC%A7%84%EC%A7%9C-%EC%98%88%EC%99%B8-%EC%83%81%ED%99%A9%EC%97%90%EB%A7%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-11-29 00:00:00 +0900", "snippet": " 핵심 정리: 예외는 예외 상황에서 쓸 의도로 설계되었다. 정상적인 제어 흐름에서 사용해서는 안되며, 이를 프로그래머에게 강요하는 API를 만들어서도 안 된다.예외는 예외 진짜 예외 상황에서만 사용하라try { int i = 0; while(true) range[i++].climb();} catch (ArrayIndexOutOfBoundsException e) { } 위 코드는 직관적인 않을 뿐만 아니라, 배열의 원소를 아주 끔찍하게 순회하고 있다. 무한 루프를 돌다가 배열의 끝에 도달해 예외(..." }, { "title": "[이펙티브자바] 아이템67-최적화는 신중히 하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C67-%EC%B5%9C%EC%A0%81%ED%99%94%EB%8A%94-%EC%8B%A0%EC%A4%91%ED%9E%88-%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-11-29 00:00:00 +0900", "snippet": " 핵심 정리: 빠른 프로그램을 작성하려 안달하지 말자. 좋은 프로그램을 작성하다 보면 성능은 따라오게 마련이다. 하지만 시스템을 설계할 때, 특히 API, 네트워크 프로토콜, 영구 저장용 데이터 포맷을 설계할 때는 성능을 염두에 두어야 한다. 시스템 구현을 완료했다면 이제 성능을 측정해보자. 충분히 빠르면 그것으로 끝이다. 그렇지 않다면 프로파일러를 사용해 문제의 원인이 되는 지점을 찾아 최적화를 수행하라. 가장 먼저 어떤 알고리즘을 사용했는지를 살펴보자. 알고리즘을 잘 못 골랐다면 다른 저수준 최적화는 아무리 해봐야 소용이..." }, { "title": "[이펙티브자바] 아이템59-라이브러리를 익히고 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C59-%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC%EB%A5%BC-%EC%9D%B5%ED%9E%88%EA%B3%A0-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-11-22 00:00:00 +0900", "snippet": " 핵심 정리: 바퀴를 다시 발명하지 말자. 아주 특별한 나만의 기능이 아니라면 누군가 이미 라이브러리 형태로 구현해놓았을 가능성이 크다. 그런 라이브러리가 있다면, 쓰면 된다. 있는지 모르겠다면 찾아봐라. 일반적으로 라이브러리의 코드는 여러분이 직접 작성한 것보다 품질이 좋고, 점차 개선될 가능성이 크다. 코드 품질에도 규모의 경제가 적용된다. 라이브러리 코드는 개발자 각자가 작성하는 것보다 주목을 훨씬 많이 받으므로 코드 품질도 그만큼 높아진다.무작정 정수 하나를 생성하고 싶다고 해보자. 값의 범위는 0부터 명시한 수 사이..." }, { "title": "[이펙티브자바] 아이템58-전통적인 for문보다는 foreach문을 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C58-%EC%A0%84%ED%86%B5%EC%A0%81%EC%9D%B8-for%EB%AC%B8%EB%B3%B4%EB%8B%A4%EB%8A%94-foreach%EB%AC%B8%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-11-22 00:00:00 +0900", "snippet": " 핵심 정리: 전통적인 for문과 비교했을때 foreach문은 명료학, 유연하고, 버그를 예방해준다. 성능 저하도 없다. 가능한 모든 곳에서 for문이 아닌 for-each문을 사용하자.전통적인 for문의 단점// 컬렉션 순회하기 - 더 나은 방법이 있다.for (Iterator&amp;lt;Element&amp;gt; i = c.iterator(); i.hasNext(); ) { Element e = i.next(); ... // 으로 무언가를 한다.}// 배열 순회하기 - 더 나은 방법이 있다.for (int ..." }, { "title": "[이펙티브자바] 아이템52-다중정의는 신중히 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C52-%EB%8B%A4%EC%A4%91%EC%A0%95%EC%9D%98%EB%8A%94-%EC%8B%A0%EC%A4%91%ED%9E%88-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-11-03 00:00:00 +0900", "snippet": "다중정의된 메서드는 컴파일 타임에 실행이 결정된다.다음은 컬렉션을 집합, 리스트, 그 외로 구분하고자 만든 프로그램이다.“집합”, “리스트”, “그 외”를 차례로 출력할 것 같지만, 실제로 수행해보면 “그 외”만 세 번 연달아 출력한다. 이유가 뭘까? 다중정의(overloading. 오버로딩)된 세 classify 중 어느 메서드를 호출할지가 컴파일타임에 정해지기 때문이다.컴파일 타임의 for 문 안의 c는 항상 Collection&amp;lt;?&amp;gt; 타입이다. 런타임에는 타입이 매번 달라지지만, 호출할 메서드를 선..." }, { "title": "[이펙티브자바] 아이템53-가변인수는 신중히 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C53-%EA%B0%80%EB%B3%80%EC%9D%B8%EC%88%98%EB%8A%94-%EC%8B%A0%EC%A4%91%ED%9E%88-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-11-02 00:00:00 +0900", "snippet": "가변인수가변인수는 명시한 타입의 인수를 0개 이상 받을 수 있다.가변인수 메서드를 호출하면, 가장 먼저 인수의 개수와 길이가 같은 배열을 만들고 인수들을 이 배열에 저장하여 가변인수 메서드에 건네준다.// 코드 53-1 간단한 가변인수 활용 예 (320쪽)static int sum(int... args) { int sum = 0; for (int arg : args) sum += arg; return sum;}가변인수를 잘 못 구현한 예다음은 최솟값을 찾는 메서드인데 인수를 0개만 받을 수 있도록 ..." }, { "title": "[이펙티브자바] 아이템45-스트림은 주의해서 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C45-%EC%8A%A4%ED%8A%B8%EB%A6%BC%EC%9D%80-%EC%A3%BC%EC%9D%98%ED%95%B4%EC%84%9C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-10-25 00:00:00 +0900", "snippet": "스트림스트림 API는 다량의 데이터 처리 작업(순차적이든 병렬적이든)을 돕고자 자바8에 추가되었다.이 API가 제공하는 추상 개념 중 핵심은 두 가지다.1) 스트림(Stream)은 데이터 원소의 유한 혹은 무한 시퀀스(sequence)를 뜻한다.2) 스트림 파이프라인(stream pipeline)은 이 원소들로 수행하는 연산 단계를 표현하는 개념이다.스트림의 원소들은 어디로부터 올 수 있다.대표적으로 컬렉션, 배열, 파일, 정규표현식 패턴 매처(matcher), 난수 생성기, 혹은 다른 스트림이 있다.스트림 안의 데이터 원소들..." }, { "title": "[이펙티브자바] 아이템43-람다보다는 메서드 참조를 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C43-%EB%9E%8C%EB%8B%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EB%A9%94%EC%84%9C%EB%93%9C-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-10-25 00:00:00 +0900", "snippet": "람다보다 메서드 참조를 사용해야 하는 이유 - 간결함map.merge(key, 1, (count, incr) -&amp;gt; count + incr);위 코드는 자바 8때 Map에 추가된 merge 메서드를 사용했다.merge 메서드는 키, 값, 함수를 인수로 받으며, 주어진 키가 맵 안에 아직 없다면 주어진 {키, 값} 쌍을 그대로 저장한다.반대로 키가 이미 있다면 (세 번재 인수로 받은) 함수를 현재 값과 주어진 값에 적용한 다음, 그 결과로 현재 값을 덮어쓴다.즉, 맵에 {키, 함수의 결과} 쌍을 저장한다. 관련해서는 ..." }, { "title": "[Spring] Spring EventListener", "url": "/posts/Spring-EventListener/", "categories": "Spring", "tags": "spring, event, eventlistener", "date": "2022-09-27 00:00:00 +0900", "snippet": "출처 https://sunghs.tistory.com/139" }, { "title": "[Java] 객체지향 생활체조 원칙", "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%83%9D%ED%99%9C%EC%B2%B4%EC%A1%B0-%EC%9B%90%EC%B9%99/", "categories": "Backend, Java", "tags": "java, oop", "date": "2022-09-14 00:00:00 +0900", "snippet": "https://hudi.blog/thoughtworks-anthology-object-calisthenics/포스팅 본문에서도 설명하고 있지만 왜(Why?) 이러한 원칙이 나왔는지, 어떠한 문제점들을 해결하고자 하는지에 대해 초점을 맞춰서 읽으면 좋을 것 같다.Why? 에 대해 아주 적절하게 잘 설명되어 있어서 읽으면서 공감이 많이 갔는데, 이를 의식적으로 실천할 수 있도록 노력해보면 좋을 것 같다 :)" }, { "title": "[이펙티브자바] 아이템41-정의하려는 것이 타입이라면 마커 인터페이스를 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C41-%EC%A0%95%EC%9D%98%ED%95%98%EB%A0%A4%EB%8A%94-%EA%B2%83%EC%9D%B4-%ED%83%80%EC%9E%85%EC%9D%B4%EB%9D%BC%EB%A9%B4-%EB%A7%88%EC%BB%A4-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-09-13 00:00:00 +0900", "snippet": "마커 인터페이스와 관련하여 여기를 먼저 참고하면 좋다.마커 인터페이스 아무 메서드도 담고 있지 않고, 단지 자신을 구현하는 클래스가 특정 속성을 가짐을 표시해주는 인터페이스를 마커 인터페이스(marker interface)라 한다. Serializable 인터페이스는 자신을 구현한 클래스의 인스턴스는 ObjectOutputStream을 통해 쓸(write) 수 있다고, 즉 직렬화(serialization)할 수 있다고 알려준다.마커 인터페이스과 마커 애너테이션마커 인터페이스는 두 가지 면에서 마커 애너테이션보다 낫다.1) ..." }, { "title": "[이펙티브자바] 아이템39-명명 패턴보단 애너테이션을 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C39-%EB%AA%85%EB%AA%85-%ED%8C%A8%ED%84%B4%EB%B3%B4%EB%8B%A8-%EC%95%A0%EB%84%88%ED%85%8C%EC%9D%B4%EC%85%98%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-09-12 00:00:00 +0900", "snippet": "전통적으로 도구나 프레임워크나 특별히 다뤄야 할 프로그램 요소에는 딱 구분되는 명명 패턴을 적용해왔다.예를 들어, 테스트 프레임워크인 JUnit은 버전3까진 테스트 메서드 이름을 test로 시작하게끔했다. 효과적이라고 보일 수 있겠지만 이는 많은 단점을 가지고 있다.명명패턴의 단점 1)오타가 나면 안된다. tsetSafetyOverride처럼 오타를 내면 테스트를 수행하지 않아 개발자는 이 메서드가 통과했다고 오해할 수도 있다. 2)올바른 프로그램 요소에서만 사용되리라 보증할 방법이 없다. ..." }, { "title": "[이펙티브자바] 아이템38-확장할 수 있는 열거 타입이 필요하면 인터페이스를 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C38-%ED%99%95%EC%9E%A5%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EC%97%B4%EA%B1%B0-%ED%83%80%EC%9E%85%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%98%EB%A9%B4-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-09-12 00:00:00 +0900", "snippet": "타입 안전 열거 패턴과 열거 타입타입 안전 열거 패턴은 확장할 수 있으나 열거 타입은 확장할 수 없다. 즉, extends 하여 새로운 타입을 정의할 수 없다. 사실 대부분 상황에서 열거 타입을 확장하는건 좋지 않은 생각이다. 이와 관련해서는 여기에 자세히 설명되어 있다.하지만 확장할 수 있는 열거 타입이 어울리는 경우가 있긴 하다. 앞전 아이템에서 작성한 연산 코드(operation code)인데, 연산 코드의 각 원소는 특정 기계가 수행하는 연산을 뜻한다. 또한 API가 제공하는 기본 연산 외에 사용자 확장 연산을 추가할..." }, { "title": "[이펙티브자바] 아이템36-비트 필드 대신 EnumSet을 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C36-%EB%B9%84%ED%8A%B8-%ED%95%84%EB%93%9C-%EB%8C%80%EC%8B%A0-EnumSet%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-09-12 00:00:00 +0900", "snippet": "열거한 값들이 주로 집합으로 사용될 경우, 예전에는 아래와 같이 각 상수에서 서로 다른 2의 거듭제곱 값을 할당한 정수 열거 패턴(아이템36)을 사용했다.public class Text { public static final int STYLE_BOLD = 1 &amp;lt;&amp;lt; 0; // 1 public static final int STYLE_ITALIC = 1 &amp;lt;&amp;lt; 1; // 2 public static final int STYLE_UNDERLINE = 1 &amp;lt;..." }, { "title": "[이펙티브자바] 아이템34-int 상수 대신 열거 타입을 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C34-int-%EC%83%81%EC%88%98-%EB%8C%80%EC%8B%A0-%EC%97%B4%EA%B1%B0-%ED%83%80%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-08-30 00:00:00 +0900", "snippet": "자바에서의 열거 타입이 없었다면?아래처럼 정수 상수를 한 묶음으로 선언해서 사용하곤 했다.// 코드 34-1 정수 열거 패턴 - 상당히 취약하다!public static final int APPLE_FUJI = 0;public static final int APPLE_PIPPIN = 1;public static final int APPLE_GRANNY_SMITH = 2; public static final int ORANGE_NAVEL = 0;public static final int ORANGE_T..." }, { "title": "[이펙티브자바] 아이템33-타입 안전 이종 컨테이너를 고려하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C33-%ED%83%80%EC%9E%85-%EC%95%88%EC%A0%84-%EC%9D%B4%EC%A2%85-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-08-29 00:00:00 +0900", "snippet": "타입 안전 이종 컨테이너 패턴컨테이너 대신 키를 매개변수화한 다음, 컨테이너에 값을 넣거나 뺄 때 매개변수화한 키를 함께 제공하여 제네릭 타입 시스템이 값의 타입이 키와 같음을 보장해주는 설계 패턴 방식이다.책에는 위와 같은 설명을 하고 있지만 쉽게 이해되지 않는다.아래 예제 코드를 통해 살펴보자.public class Favorites { // 코드 33-3 타입 안전 이종 컨테이너 패턴 - 구현 (200쪽) private Map&amp;lt;Class&amp;lt;?&amp;gt;, Object&amp;gt; f..." }, { "title": "[이펙티브자바] 아이템32-제네릭과 가변인수를 함께 쓸 때는 신중하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C32-%EC%A0%9C%EB%84%A4%EB%A6%AD%EA%B3%BC-%EA%B0%80%EB%B3%80%EC%9D%B8%EC%88%98%EB%A5%BC-%ED%95%A8%EA%BB%98-%EC%93%B8-%EB%95%8C%EB%8A%94-%EC%8B%A0%EC%A4%91%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-08-29 00:00:00 +0900", "snippet": "먼저 가변 인자에 대한 개념이 부족하다면 잘 정리된 여기를 참고하면 좋다.가변 인수의 허점 가변 인수는 메드 넘기는 인수의 개수를 클라이언트가 조절할 수 있게 해는데, 구현 방식에 허점이 있다. 가변 인수를 호출하면 가변인수를 담기 위한 배열이 자동으로 하나 만들어진다. 그런데 내부로 감춰야 했을 이 배열을 그만 클라이언트에 노출하는 문제가 생겼다. 자바 제네릭은 5부터 도입되었는데 이전 버전과의 호환성을 위해 컴파일 타임에서 제네릭 타입이 제거된다. 즉, 제네릭과 매개변수화 타입은 실체화 되지 않는 실체..." }, { "title": "[JPA] HikariCP 설정", "url": "/posts/HikariCP-%EC%84%A4%EC%A0%95/", "categories": "Backend, JPA", "tags": "hikaricp, connection, leak", "date": "2022-08-26 00:00:00 +0900", "snippet": "HikariCP는 고성능의 JDBC 커넥션 풀 라이브러리이다. SpringBoot는 커넥션 풀 관리를 위해 HikariCP를 사용한다.이와 관련된 설정 옵션으로 아래 출처 링크를 참고하면 좋다.참고 및 출처 https://effectivesquid.tistory.com/entry/HikariCP-%EC%84%B8%ED%8C%85%EC%8B%9C-%EC%98%B5%EC%85%98-%EC%84%A4%EB%AA%85 https://jsonobject.tistory.com/430 https://code-lab1.tistory.c..." }, { "title": "[JPA] Connection 누수", "url": "/posts/Connection-%EB%88%84%EC%88%98/", "categories": "Backend, JPA", "tags": "hikaricp, connection, leak", "date": "2022-08-26 00:00:00 +0900", "snippet": "사용한 커넥션을 커넥션풀로 다시 반환하지 못하게 되는 현상을 커넥션 누수라 한다.아래 출처를 통해 다양한 포스팅들을 참고하면 이를 이해하기 쉬울 것이다.특히! Hibernate 멀티테넌시를 사용한다면 더욱 주의가 필요할 것이다 :)참고 및 출처 https://velog.io/@rnjsrntkd95/Hikari-CP-%EC%BB%A4%EB%84%A5%EC%85%98-%EB%88%84%EC%88%98-with.%EB%A9%80%ED%8B%B0%ED%85%8C%EB%84%8C%EC%8B%9C https://imksh.com/73..." }, { "title": "[이펙티브자바] 아이템31-한정적 와일드카드를 사용해 API 유연성을 높이라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C31-%ED%95%9C%EC%A0%95%EC%A0%81-%EC%99%80%EC%9D%BC%EB%93%9C%EC%B9%B4%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4-API-%EC%9C%A0%EC%97%B0%EC%84%B1%EC%9D%84-%EB%86%92%EC%9D%B4%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-08-22 00:00:00 +0900", "snippet": " 이전 아이템28에서 이야기했듯 매개변수화 타입은 불공변(invariant)이다. 이를 꼭 기억하자. 즉 서로 다른 타입 Type1과 Type2가 있을 때 List&amp;lt;Type1&amp;gt;은 List&amp;lt;Type2&amp;gt;의 하위 타입도 상위 타입도 아니다. 예를 들어 List&amp;lt;Object&amp;gt;에는 어떤 객체든 넣을 수 있지만 List&amp;lt;String&amp;gt;에는 문자열만 넣을 수 있다. 즉, List&amp;lt;String&amp;gt..." }, { "title": "[이펙티브자바] 아이템30-이왕이면 제네릭 메서드로 만들자", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C30-%EC%9D%B4%EC%99%95%EC%9D%B4%EB%A9%B4-%EC%A0%9C%EB%84%A4%EB%A6%AD-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%9E%90/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-08-20 00:00:00 +0900", "snippet": "로 타입으로 이루어진 메서드를 제네릭을 사용하여 변환아래 예제 코드를 보자.// 코드 30-2 제네릭 메서드 (177쪽)public static Set union(Set s1, Set s2) { Set result = new HashSet&amp;lt;&amp;gt;(s1); result.addAll(s2); return result;}컴파일은 되지만 경고가 두 개 발생한다.Warning:(20, 22) java: unchecked call to HashSet(java.util.Collection&amp;lt;..." }, { "title": "[이펙티브자바] 아이템29-이왕이면 제네릭 타입으로 만들라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C29-%EC%9D%B4%EC%99%95%EC%9D%B4%EB%A9%B4-%EC%A0%9C%EB%84%A4%EB%A6%AD-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-08-20 00:00:00 +0900", "snippet": "클라이언트에서 직접 형변환해야 하는 타입보단 제네릭 타입이 더 안전하고 쓰기 편하다. 클라이언트에서 불필요한 형변환 없음 훨씬 더 안정적으로 타입을 관리할 수 있다. (런타임 에러가 발생할 확률을 줄일 수 있다.)사실 제네릭 타입 안에서 리스트를 사욯아는게 항상 가능하지도, 꼭 더 좋은 거도 아니다. 자바가 리스트를 기본 타입으로 제공하지 않으므로 ArrayList 같은 제네릭 타입도 결국은 기본 타입인 배열을 사용해 구현해야 한다. 또한 HashMap 같은 제네릭 타입은 성능을 높일 목적으로 배열을 사용하기도 한다.대..." }, { "title": "[이펙티브자바] 아이템28-배열보다는 리스트를 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C28-%EB%B0%B0%EC%97%B4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EB%A6%AC%EC%8A%A4%ED%8A%B8%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-08-16 00:00:00 +0900", "snippet": "배열과 제네릭 타입의 중요한 두 가지 차이1) 배열은 공변(covariant)이다. 어려워보이지만 뜻은 간단하다. Sub가 Super의 하위 타입이라면 배열 Sub[]는 배열 Super[]의 하위 타입이 된다.(공변, 즉 함께 변한다는 뜻이다) 반면 제네릭은 불공변(invariant)이다. 즉, 서로 다른 타입 Type1과 Type2가 있을때, List&amp;lt;Type1&amp;gt;은 List&amp;lt;Type2&amp;gt;의 하위 타입도 아니고 상위 타입도 아니다. 사실 문제가 있는건 배열쪽이다. 아래 코..." }, { "title": "[이펙티브자바] 아이템27-비검사 경고를 제거하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C27-%EB%B9%84%EA%B2%80%EC%82%AC-%EA%B2%BD%EA%B3%A0%EB%A5%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-08-16 00:00:00 +0900", "snippet": "할 수 있는 한 모든 비검사 경고를 제거하라. 모두 제거한다면 그 코드는 타입 안정성이 보장된다. 즉, 런타임에 ClassCastException이 발생할 일이 없고, 개발자가 의도한 대로 잘 동작하리라 확신할 수 있다.경고를 제거할 순 없지만 타입 안전하다고 확신할 수 있다면 @SupressWarnins(“unchecked”) 애너테이션을 달아 경고를 숨기자. 안전하다고 검증된 비검사 경고를 (숨기지 않고) 그대로 두면, 진짜 문제를 알리는 새로운 경고가 나와도 눈치채지 못할 수 있다. 제거하지 않은 수..." }, { "title": "[이펙티브자바] 아이템26-로 타입은 사용하지 말라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C26-%EB%A1%9C-%ED%83%80%EC%9E%85%EC%9D%80-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EB%A7%90%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-08-16 00:00:00 +0900", "snippet": "로 타입 로 타입이란 제네릭 타입 매개변수를 전혀 사용하지 않을 때를 말한다. 예컨대 List&amp;lt;E&amp;gt; 의 로 타입은 List다. 로 타입(타입 매개변수가 없는 제네릭 타입)을 쓰는 걸 언어 차원에서 막아 놓진 않았지만 절대로 써선 안된다. 로 타입을 쓰면 제네릭을 안겨주는 안정성과 표현력을 모두 잃게 된다. 그럼에도 불구하고 로 타입이 생긴 이유는 제네릭 타입이 없을때 작성된 코드들과의 하위 호완성을 유지하기 위해서이다. 로 타입인 List..." }, { "title": "[이펙티브자바] 아이템25-톱레벨 클래스는 한 파일에 하나만 담으라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C25-%ED%86%B1%EB%A0%88%EB%B2%A8-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%ED%95%9C-%ED%8C%8C%EC%9D%BC%EC%97%90-%ED%95%98%EB%82%98%EB%A7%8C-%EB%8B%B4%EC%9C%BC%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-08-07 00:00:00 +0900", "snippet": " 소스 파일 하나에 톱레벨 클래스를 여러 개 선언하더라도 자바 컴파일러는 문제 없이 컴파일 한다. 하지만 심각한 위험을 감수해야 하는 행위다. 이렇게 하면 한 클래스를 여러 가지로 정의할 수 잇으며, 그중 어느 것을 사용할지는 어느 소스 파일을 먼저 컴파일하느냐에 따라 달라지기 때문이다. public class Main { public static void main(String[] args) { System.out.println(Utensil.NAME + Dessert.NAME);..." }, { "title": "[이펙티브자바] 아이템24-멤버 클래스는 되도록 static으로 만들어라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C24-%EB%A9%A4%EB%B2%84-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%8A%94-%EB%90%98%EB%8F%84%EB%A1%9D-static%EC%9C%BC%EB%A1%9C-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-08-07 00:00:00 +0900", "snippet": "중첩 클래스 중첩 클래스에는 정적 멤버 클래스, (비정적) 멤버 클래스, 익명 클래스, 지역 클래스 이렇게 네 가지 종류가 있다.정적(static) 멤버 클래스 다른 클래스 안에 선언되고, 바깥 클래스의 private 멤버에도 접근할 수 있다는 점만 제외하곤 일반 클래스와 똑같다. 정적 멤버 클래스는 다른 정적 멤버와 똑같은 접근 규칙을 적용받는다. 예컨대 private으로 선언하면 바깥 클래스에서만 접근할 수 있는 식이다.비정적(non-static) 멤버 클래스 중첩 클래스에 static 키워드가 없는 형태이다. 비..." }, { "title": "[이펙티브자바] 아이템23-태그 달린 클래스보다는 클래스 계층구조를 활용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C23-%ED%83%9C%EA%B7%B8-%EB%8B%AC%EB%A6%B0-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%ED%81%B4%EB%9E%98%EC%8A%A4-%EA%B3%84%EC%B8%B5%EA%B5%AC%EC%A1%B0%EB%A5%BC-%ED%99%9C%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-08-03 00:00:00 +0900", "snippet": "// 코드 23-1 태그 달린 클래스 - 클래스 계층구조보다 훨씬 나쁘다! (142-143쪽)class Figure { enum Shape { RECTANGLE, CIRCLE }; // 태그 필드 - 현재 모양을 나타낸다. final Shape shape; // 다음 필드들은 모양이 사각형(RECTANGLE)일 때만 쓰인다. double length; double width; // 다음 필드는 모양이 원(CIRCLE)일 때만 쓰인다. double radius; // 원용 생성자 ..." }, { "title": "[이펙티브자바] 아이템22-인터페이스는 타입을 정의하는 용도로만 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C22-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8A%94-%ED%83%80%EC%9E%85%EC%9D%84-%EC%A0%95%EC%9D%98%ED%95%98%EB%8A%94-%EC%9A%A9%EB%8F%84%EB%A1%9C%EB%A7%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-07-27 00:00:00 +0900", "snippet": "인터페이스는 자신을 구현한 클래스의 인스턴스를 참조할 수 있는 타입 역할을 한다. 클래스가 어떤 인터페이스를 구현한다는 것은 자신의 인스턴스로 무엇을 할 수 있는지를 클라이언트에 얘기해주는 거이다. 인터페이스는 오직 이 용도로만 사용해야 한다.상수 인터페이스 안티패턴은 인터페이스를 잘못 사용한 예다.// 코드 22-1 상수 인터페이스 안티패턴 - 사용금지! (139쪽)public interface PhysicalConstants { // 아보가드로 수 (1/몰) static final double AVOGADRO..." }, { "title": "[이펙티브자바] 아이템21-인터페이스는 구현하는 쪽을 생각해 설계하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C21-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8A%94-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-%EC%AA%BD%EC%9D%84-%EC%83%9D%EA%B0%81%ED%95%B4-%EC%84%A4%EA%B3%84%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-07-26 00:00:00 +0900", "snippet": " 자바 8전에는 기존 구현체를 깨드리지 않고는 인터페이스에 메서들르 추가할 방법이 없었다. 자바 8에 와서 기존 인터페이스에 메서드를 추가할 수 있도록 디폴트 메서드를 소개했지만 위험이 완전히 사라진 것은 아니다. 모든 기존 구현체들과 매끄럽게 연동되리라는 보장이 없다. 디폴트 메서드는 구현 클래스에 대해 아무것도 모른 채 합의 없이 무작정 삽입될 뿐이다. 자바 8의 Collection 인터페이스에 추가된 removeIf 메서드를 예로 생각해보자. 이 메서드는 주어진 P..." }, { "title": "[이펙티브자바] 아이템20-추상 클래스보다는 인터페이스를 우선하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C20-%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%B3%B4%EB%8B%A4%EB%8A%94-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EC%9A%B0%EC%84%A0%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-07-25 00:00:00 +0900", "snippet": "자바가 제공하는 다중 구현 메커니즘은 인터페이스와 추상 클래스, 이렇게 두 가지다. 자바8부터 인터페이스도 디폴트 메서드(default method)를 제공할 수 있다.(참고) 둘의 가장 큰 차이는 추상 클래스가 정의한 타입을 구현하는 클래스는 반드시 추상 클래스의 하위 클래스가 되어야 한다는 점이다. 자바는 단일 상속만 지원하기에, 추상 클래스 방식은 새로운 타입을 정의하는데 커다란 제약을 안게 되는 셈이다.인터페이스는 기존 클래스에도 손쉽게 새로운 인터페이스를 구현해넣을 수 있다. 기존 클래스 위에 새로운 추상 클래..." }, { "title": "[이펙티브자바] 아이템19-상속을 고려해 설계하고 문서화하라. 그러지 않았다면 상속을 금지하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C19-%EC%83%81%EC%86%8D%EC%9D%84-%EA%B3%A0%EB%A0%A4%ED%95%B4-%EC%84%A4%EA%B3%84%ED%95%98%EA%B3%A0-%EB%AC%B8%EC%84%9C%ED%99%94%ED%95%98%EB%9D%BC-%EA%B7%B8%EB%9F%AC%EC%A7%80-%EC%95%8A%EC%95%98%EB%8B%A4%EB%A9%B4-%EC%83%81%EC%86%8D%EC%9D%84-%EA%B8%88%EC%A7%80%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-07-19 00:00:00 +0900", "snippet": "상속용 클래스는 재정의할 수 있는 메서드들을 내부적으로 어떻게 이용하는지(자기사용) 문서로 남겨야 한다. &#39;재정의 가능&#39; 이란 public과 protected 중 final이 아닌 모든 메서드를 뜻한다. 재정의 가능 메서드를 호출할 수 있는 모든 상황을 문서로 남겨야 한다.Implementation Requirements API 문서의 메서드 설명 끝에서 종종 Implementation Requirements로 시작하는 절을 볼 수 있는데, 그 메서드의 내부 동작 방식을 설명하는 곳이다. 이 절은 메서드 ..." }, { "title": "[이펙티브자바] 아이템18-상속보다는 컴포지션을 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C18-%EC%83%81%EC%86%8D%EB%B3%B4%EB%8B%A4%EB%8A%94-%EC%BB%B4%ED%8F%AC%EC%A7%80%EC%85%98%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-07-19 00:00:00 +0900", "snippet": "위 포스팅에서 언급하는 상속은 클래스가 인터페이스를 구현하거나 인터페이스가 다른 인터페이스를 확장하는 인터페이스 상속과는 무관하다.상속은 코드를 재사용하는 강력한 수단이지만, 잘 못 사용하면 오류를 내기 쉽다. 같은 프로그래머가 통제하는 패키지 안에서라면 상속도 안전한 방법이다. 확장할 목적으로 설계되었고 문서화도 잘 된 클래스(아이템19)도 마찬가지로 안전하다. 하지만 일반적인 구체 클래스를 패키지 경계를 넘어, 즉 다른 패키지의 구체 클래스를 상속하는 일은 위험하다.메서드 호출과 달리 상속은 캡슐화를 깨뜨린다. 상위..." }, { "title": "[이펙티브자바] 아이템17-변경 가능성을 최소화하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C17-%EB%B3%80%EA%B2%BD-%EA%B0%80%EB%8A%A5%EC%84%B1%EC%9D%84-%EC%B5%9C%EC%86%8C%ED%99%94%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-07-18 00:00:00 +0900", "snippet": "불변 클래스란? 인스턴스의 내부 값을 수정할 수 없는 클래스 String, 기본 타입의 박싱된 클래스들, BigInteger, BigDecimal이 여기 속한다.클래스를 불변으로 만드는 다섯 가지 규칙1) 객체의 상태를 변경하는 메서드(변경자, Setter)를 제공하지 않는다.2) 클래스를 확장할 수 없도혹 해야 한다. 클래스를 final로 선언 private 생성자를 두고 public 정적 팩터리를 제공3) 모든 필드를 final로 선언 설꼐자의 의도를 명확히 드러내는 방법이다.4) 모든 필드를 private 으로 ..." }, { "title": "[이펙티브자바] 아이템16-public 클래스에서는 public 필드가 아닌 접근자 메서드를 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C16-public-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%97%90%EC%84%9C%EB%8A%94-public-%ED%95%84%EB%93%9C%EA%B0%80-%EC%95%84%EB%8B%8C-%EC%A0%91%EA%B7%BC%EC%9E%90-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-07-12 00:00:00 +0900", "snippet": "객체 지향 프로그래머는 필드를을 모두 private으로 바꾸고, public 접근 제어자(getter)를 추가한다.// 이처럼 툅환 클래스는 public이어선 안된다.class Point { public double x; public double y;}위와 같은 클래스는 데이터 필드에 직접 접근할 수 있으니 캡슐화의 이점을 제공하지 못한다.(아이템15)// 코드 16-2 접근자와 변경자(mutator) 메서드를 활용해 데이터를 캡슐화한다. (102쪽)class Point { private double x; pri..." }, { "title": "[이펙티브자바] 아이템15-클래스와 멤버의 접근 권한을 최소화하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C15-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EB%A9%A4%EB%B2%84%EC%9D%98-%EC%A0%91%EA%B7%BC-%EA%B6%8C%ED%95%9C%EC%9D%84-%EC%B5%9C%EC%86%8C%ED%99%94%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-07-11 00:00:00 +0900", "snippet": "컴포넌트 설계 어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 바로 클래스의 내부 데이터와 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐이다. 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리한다. 오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는다. 정보 은닉 혹은 캡슐화라고 하는 이 개념은 SW 설계의 근간이 되는 원리이다.정보 은닉의 장점1) 개발 속도를 높여준다. 여러 컴포넌트를 병렬로 개발할 수 있기 때문이다.2) 시..." }, { "title": "[Spring] Spring Data JPA 멀티 테넌시", "url": "/posts/Spring-Data-JPA-%EB%A9%80%ED%8B%B0-%ED%85%8C%EB%84%8C%EC%8B%9C/", "categories": "Spring", "tags": "spring, multitenancy, springdatajpa", "date": "2022-07-01 00:00:00 +0900", "snippet": "출처 https://velog.io/@gaegulgaegul/Spring-Data-JPA-%EB%A9%80%ED%8B%B0-%ED%85%8C%EB%84%8C%EC%8B%9C" }, { "title": "[이펙티브자바] 아이템14-Comparable을 구현할지 고려하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C14-Comparable%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%A0%EC%A7%80-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-06-17 00:00:00 +0900", "snippet": "Comparable 인터페이스란? Comparable 인터페이스는 객체를 정렬하는데 사용되는 메서드인 compareTo를 정의하고 있다. Comparable 인터페이스를 구현한 클래스는 반드시 compareTo를 정의해야 한다.Comparable 인터페이스 특징 자바에서 같은 타입의 인스턴스를 비교해야만 하는 클래스들은 모두 Comparable 인터페이스를 구현하고 있다. Boolean 타입을 제외한 래퍼 클래스와 알파벳, 연대같이 순서가 명확한 클래스들은 모두 정렬이 가능하다. 기본 정렬 순서는 작은 값에서 큰 값으..." }, { "title": "[이펙티브자바] 아이템13-clone 재정의는 주의해서 진행하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C13-clone-%EC%9E%AC%EC%A0%95%EC%9D%98%EB%8A%94-%EC%A3%BC%EC%9D%98%ED%95%B4%EC%84%9C-%EC%A7%84%ED%96%89%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-06-14 00:00:00 +0900", "snippet": "Cloneable 인터페이스를 구현하는 모든 클래스는 clone을 재정의해야 한다 이때 접근 제한자는 public으로, 반환 타입은 클래스 자신으로 변경한다. 이 메서드는 가장 먼저 super.clone을 호출한 후 필요한 필드를 전부 적절히 수정한다. 일반적으로 이 말은 그 객체의 내부 깊은 구조에 숨어 있는 모든 가변 객체를 복사하고, 복제본이 가진 객체 참조 모두가 복사된 객체들을 가리키게 함을 뜻한다. 이러한 내부 복사는 주로 clone을 재귀적으로 호출해 구현하지만, 이 방식이 항상 최선인 것은 아니다. 기본..." }, { "title": "[이펙티브자바] 아이템12-toString을 항상 재정의하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C12-toString%EC%9D%84-%ED%95%AD%EC%83%81-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-06-06 00:00:00 +0900", "snippet": "toString의 일반 규약에 따르면서 ‘간결하면서 사람이 읽기 쉬운 형태의 유익한 정보’를 반환해야 한다. Object의 toString을 재정의하지 않고 사용할 경우 아래와 같이 클래스명@16진수로 표시한 해시코드로 나타나게 된다. 이는 해당 객체가 어떤 상태인지 어떤 정보를 담고 있는지를 전혀 알 수 없다. 또한 toString의 규약은 “모든 하위 클래스에서 이 메서드를 재정의하라”고 한다. toString을 잘 구현한 클래스는 사용하기에 훨씬 즐겁고, 그 클래스를 사용한 시스템은 디버깅하기 쉽다. ..." }, { "title": "[이펙티브자바] 아이템11-equals를 재정의하려거든 hashcode도 재정의하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C11-equals%EB%A5%BC-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%A0%A4%EA%B1%B0%EB%93%A0-hashcode%EB%8F%84-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-06-05 00:00:00 +0900", "snippet": "equals를 재정의한 클래스 모두에서 hashCode도 재정의해야 한다. 그렇지 않으면 hashCode 일반 규약을 어기게 되어 해당 클래스의 인스턴스를 HashMap이나 HashSet과 같은 컬렉션의 원소로 사용할 때 문제를 일으킬 것이다.Object 명세에서 언급하는 hashcode 규약 equals 비교에 사용되는 정보가 변경되지 않았다면, hashCode 도 변하면 안 된다. 애플리케이션을 다시 실행한다면 이 값이 달라져도 상관 없다. equals가 두 객체가 같다고 판단했다면, 두 객..." }, { "title": "[이펙티브자바] 아이템10-equals는 일반 규약을 지켜 재정의하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C10-equals%EB%8A%94-%EC%9D%BC%EB%B0%98-%EA%B7%9C%EC%95%BD%EC%9D%84-%EC%A7%80%EC%BC%9C-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-06-05 00:00:00 +0900", "snippet": "equals 메서드를 재정의 하지 않을 때는 언제인가? equals 메서드는 재정의하기 쉬워보이지만 곳곳에 함정이 도사리고 있음, 그러기에 자칫 하면 끔찍한 결과를 초래 문제를 회피하는 방법은 아예 재정의하지 않는 것, 그 클래스의 인스턴스는 오직 자기 자신과만 같게됨 그게 언제일까?1) 각 인스턴스가 본질적으로 고유 할 때 값을 표현하는게 아니라 동작하는 객체를 표현하는 클래스 Thread가 좋은 예시 Sprint 에서 Service 객체 또한 이에 해당할 것 같다.2) 인스턴스의 논리적 동치성(logical eq..." }, { "title": "[학습할래][JPA-Episode2] 영속성 컨텍스트", "url": "/posts/JPA-Episode2-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/", "categories": "학습할래", "tags": "jpa", "date": "2022-06-03 00:00:00 +0900", "snippet": "이전 JPA 에피소드 1탄에서 SQL 중심적인 개발의 문제점과 JPA를 왜 써야하는지?에 대해서 알아보았는데요, 또한 JPA에서 가장 중요한 2가지를 언급드렸었습니다. 1) 객체와 관게형 데이터베이스 매핑하기(Object Relational mapping) DB를 어떻게 설계하고 객체를 어떻게 설계해서 중간에 어떻게 JPA로 매핑해서 쓸건지 2) 영속성 컨텍스트 실제 내부에서 JPA가 어떻게 동작하는지 오늘은 두 가지 중 영속성 컨텍스트 에 대해 알아보도록 하겠습니다!!!..." }, { "title": "[이펙티브자바] 아이템9-try-finally보다는 try-with-resources를 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C9-try-finally%EB%B3%B4%EB%8B%A4%EB%8A%94-try-with-resources%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-05-27 00:00:00 +0900", "snippet": " 자바에선 InputStream, OutputStream, java.sql.Connection 등과 같은 close 메서드를 호출해 직접 닫아줘야 하는 자원이 많다. 이는 예측할 수 없는 성능 문제로 이어지기도 한다. 전통적으로 자원이 제대로 닫힘을 보장하는 수단으로 try-finally가 있다. 예외가 발생하거나 메서드에서 반환되는 경우를 포함해서 말이다.// 코드 9-1 try-finally - 더 이상 자원을 회수하는 최선의 방책이 아니다! (47쪽)static String firstLineOfFile(String ..." }, { "title": "[이펙티브자바] 아이템8-finalizer와 cleaner 사용을 피하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C8-finalizer%EC%99%80-cleaner-%EC%82%AC%EC%9A%A9%EC%9D%84-%ED%94%BC%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-05-25 00:00:00 +0900", "snippet": "이펙티브 자바 아이템8 finalizer에 관련되어 이해하기 쉽게 잘 정리된 포스팅이 있어 참고하여 정리해보려 한다.java에서의 모든 객체는 Object 객체를 상속받는다. 그리고 Object에는 finalize() 라는 메서드가 존재한다.finalize() 메서드는 클래스의 객체가 더 이상 참조되고 있지 않을 경우 GC가 메모리에 정리하기 전에 자동으로 호출시킨다.그리고 현재 자바9부터 deprecated로 지정된 것을 확인하실 수 있다.자바9에서 depreacted 로 지정된 이유는 몇 가지 문제점들이 있기 떄문이다.fi..." }, { "title": "[Java] unmodifiableList", "url": "/posts/unmodifiableList/", "categories": "Backend, Java", "tags": "java, unmodifiablelist", "date": "2022-05-25 00:00:00 +0900", "snippet": "UnmodifiableCollection.unmodifiableList() 같은 메소드에서 리턴되는 레퍼런스는 수정 메소드를 호출 할 수 없다.여기서 수정 메서드 라 함은 add(), set(), addAll() 등을 의미한다. 만약 호출하게 된다면 UnsupportedOperationException이 발생한다.하지만 원본 리스트 자체가 수정되지 않도록 보장해주진 않는다. 또한 여기서 원본 리스트를 수정하면 unmodifiableList 자체도 동일하게 수정된다.예제를 살펴보자.import java.util.ArrayList..." }, { "title": "[이펙티브자바] 아이템7-다 쓴 객체 참조를 해제하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C7-%EB%8B%A4-%EC%93%B4-%EA%B0%9D%EC%B2%B4-%EC%B0%B8%EC%A1%B0%EB%A5%BC-%ED%95%B4%EC%A0%9C%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-05-23 00:00:00 +0900", "snippet": " c, c++ 처럼 메모리를 직접 관리해야 하는 언어를 쓰다 자바처럼 가비지 컬렉터를 갖춘 언어로 넘어오면 일일이 메모리 관리를 해줘야하는 번거로움이 사라지기에 매우 편해질 것이다. 하지만, 여기서 반드시 주의할 점은 있다.package effectivejava.chapter2.item7;import java.util.*;// 코드 7-1 메모리 누수가 일어나는 위치는 어디인가? (36쪽)public class Stack { private Object[] elements; private int size = 0; ..." }, { "title": "[Java] WeakHashMap", "url": "/posts/WeakHashMap/", "categories": "Backend, Java", "tags": "java, weakhashmap", "date": "2022-05-23 00:00:00 +0900", "snippet": "Java에서는 세 가지 주요 유형의 참조(Reference) 방식강한 참조 (Strong Reference) Integer prime = 1; 와 같은 가장 일반적인 참조 유형이다. prime 변수 는 값이 1 인 Integer 객체에 대한 강한 참조를 가진다. 이 객체를 가리키는 강한 참조가 있는 객체는 GC대상이 되지않는다.부드러운 참조 (Soft Reference) SoftReference&amp;lt;Integer&amp;gt; soft = new SoftReference&amp;lt;Integer&amp;gt;..." }, { "title": "[학습할래][JPA-Episode1] JPA의 세계로", "url": "/posts/JPA-Episode1-JPA%EC%9D%98-%EC%84%B8%EA%B3%84%EB%A1%9C/", "categories": "학습할래", "tags": "jpa", "date": "2022-05-20 00:00:00 +0900", "snippet": "JPA 왜 써야하는가?애플리케이션은 객체 지향 개발을 하면서 코드를 까보면 SQL만 가득차 있는 모습을 볼 수 가 있는데요. 이러한 SQL 중심적인 개발은 많은 문제점들을 야기합니다.1. 무한 반복, 지루한 코드CRUD 쿼리 무한 반복해야됩니다. 테이블이 10개면 10개를 다해줘야해서 생산성이 저하되고 힘들게 됩니다.(객체에 필드가 추가되면 쿼리들에 하나씩 일일이 다 추가해줘야함… 하나라도 놓치게 되면..)2. 패러다임의 불일치(객체 지향 vs 관계형 DB) 관계형 DB는 데이터를 정교화해서 저장하는게 목표이고, 객체는 필드..." }, { "title": "[이펙티브자바] 아이템6-불필요한 객체 생성을 피하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C6-%EB%B6%88%ED%95%84%EC%9A%94%ED%95%9C-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1%EC%9D%84-%ED%94%BC%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-05-19 00:00:00 +0900", "snippet": "똑같은 기능의 객체를 매번 생성하기보다는 객체 하나를 재사용하는 편이 나을때가 많다.(String 객체 생성 방식과 리터럴 방식의 차이점) 재사용은 빠르고 세련되며 특히 불변 객체는 언제든 재사용할 수 있다. 다음 코드는 하지 말아야할 극단적 예이니 유심히 살펴보자.String s = new String(&quot;bikini&quot;); 위 코드는 실행될 때마다 String 인스턴스를 새로 만든다. 완전히 쓸데 없는 행위다. 10000번이 호출된다면 10000개가 생성될 것이다. 개선된 버전은 아래와 같다.Strin..." }, { "title": "[이펙티브자바] 아이템5-자원을 직접 명시하지 말고 의존 객체 주입을 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C5-%EC%9E%90%EC%9B%90%EC%9D%84-%EC%A7%81%EC%A0%91-%EB%AA%85%EC%8B%9C%ED%95%98%EC%A7%80-%EB%A7%90%EA%B3%A0-%EC%9D%98%EC%A1%B4-%EA%B0%9D%EC%B2%B4-%EC%A3%BC%EC%9E%85%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-05-16 00:00:00 +0900", "snippet": " 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스가 싱글턴 방식이 적합하지 않다. 클래스가 여러 자원 인스턴스를 지원해야 하며 자원에 따라 동작이 달라지는 경우엔 의존 객체 주입을 사용할 수 있다. 이는 인스턴스를 생성할 때 생성자에 필요한 자원을 넘겨주는 방식이다.의존 객체 주입의 장점 불변(아이템17)을 보장하여 여러 클라이언트가 의존 객체들을 안심하고 공유할 수 있기도 하다. 생성자, 정적 팩터리(아이템1), 빌더(아이템2) 모두에 똑같이 응용할 수 있다. 유연성과 테스트 용이성..." }, { "title": "[이펙티브자바] 아이템4-인스턴스화를 막으려거든 private 생성자를 사용하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C4-%EC%9D%B8%EC%8A%A4%ED%84%B4%EC%8A%A4%ED%99%94%EB%A5%BC-%EB%A7%89%EC%9C%BC%EB%A0%A4%EA%B1%B0%EB%93%A0-private-%EC%83%9D%EC%84%B1%EC%9E%90%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-05-16 00:00:00 +0900", "snippet": " 단순히 정적 메서드와 정적 필드만을 담은 클래스를 만들고 싶을 때가 있을 것이다. 예를 들면, java.lang.Math, java.util.Arrays 처럼 기본 타입 값이나 배열 관련 메서드들을 모아놓을 수 있다. 또한 java.util.Collections 처럼 특정 인터페이스를 구현하는 객체를 생성해주는 정적 메서드를 모아 놓을 수 있다. 인스턴스화를 막으려면 어떻게 해야할까?대안1) 추상 클래스로 만든다? =&amp;gt; 하위 클래스를 만들어 인스턴스화하면 그만이기에 막을 수 없다. 이러한 추상 클래스를 ..." }, { "title": "[이펙티브자바] 아이템3-private 생성자나 열거 타입으로 싱글턴임을 보증하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C3-private-%EC%83%9D%EC%84%B1%EC%9E%90%EB%82%98-%EC%97%B4%EA%B1%B0-%ED%83%80%EC%9E%85%EC%9C%BC%EB%A1%9C-%EC%8B%B1%EA%B8%80%ED%84%B4%EC%9E%84%EC%9D%84-%EB%B3%B4%EC%A6%9D%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-05-16 00:00:00 +0900", "snippet": "싱글턴 객체를 만드는 방법1) 생성자를 private으로 만들고 유일한 인스턴스에 접근할 수 있는 수단으로 public static 멤버 하나를 마련해둔다.// 코드 3-1 public static final 필드 방식의 싱글턴 (23쪽)public class Elvis { public static final Elvis INSTANCE = new Elvis(); private Elvis() { } public void leaveTheBuilding() { System.out.println(&quot..." }, { "title": "[이펙티브자바] 아이템2-생성자에 매개변수가 많다면 빌더를 고려하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C2-%EC%83%9D%EC%84%B1%EC%9E%90%EC%97%90-%EB%A7%A4%EA%B0%9C%EB%B3%80%EC%88%98%EA%B0%80-%EB%A7%8E%EB%8B%A4%EB%A9%B4-%EB%B9%8C%EB%8D%94%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-05-13 00:00:00 +0900", "snippet": "정적 팩터리와 생성자에는 똑같은 제약이 하나있다.선택적 매개변수가 많을 때 적절히 대응하기 어렵다는 점이다.첫번째 대안) 점층적 생성자 패턴 필수 매개변수와 선택 매개변수의 적절한 조합으로 생성자를 늘려가는 방식 ex) 필수 매개변수만 받는 생성자, 필수 매개변수와 선택 매개변수 1개를 받는 생성자, 선택 매개변수를 2개까지 받는 생성자, … 선택 매개변수를 전부 다 받는 생성자 public class NutritionFacts { private final int servingSize; // ..." }, { "title": "[이펙티브자바] 아이템1-생성자 대신 정적 팩터리 메서드를 고려하라", "url": "/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C1-%EC%83%9D%EC%84%B1%EC%9E%90-%EB%8C%80%EC%8B%A0-%EC%A0%95%EC%A0%81-%ED%8C%A9%ED%84%B0%EB%A6%AC-%EB%A9%94%EC%84%9C%EB%93%9C%EB%A5%BC-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/", "categories": "책, EffectiveJava", "tags": "java, effectivejava", "date": "2022-05-13 00:00:00 +0900", "snippet": "정적 팩터리 메서드란? 단순하게 클래스의 인스턴스를 반환하는 단순한 정적 메서드를 뜻한다. 예를 들면, 다음과 같은 코드와 같이 단순하게 인자를 받아 해당 클래스의 인스턴스를 반환하는 메서드를 뜻한다.public static Product from(String name) { return new Product(name);} 정적 팩터리 메서드의 장점장점-1) 이름을 가질 수 있다. 일반적인 클래스에서 생성자에 넘기는 매개변수와 생성자 자체만으론 반환될 객체의 특성을 제대로 설명하지 못한다. 반면 정적 팩터리는 이름만..." }, { "title": "[학습할래] Dynamic Import", "url": "/posts/dynamic-import/", "categories": "학습할래", "tags": "mobx", "date": "2022-05-02 00:00:00 +0900", "snippet": "일반적으로 브라우저에 접속하면 해당 브라우저에서 필요한 html 파일을 네트워크를 통해 가져오고, 해당 html 파일에 명시된 자바스크립트 파일, 스타일 시트 파일들을 함께 가져오게 됩니다.여기서!!!하나의 애플리케이션의 번들(javascript 파일) 사이즈가 엄청 커지게 되면 초기에 웹 페이지 로딩 속도가 엄청 느려지게 될 것입니다.당연히 실무에서는 애플리케이션의 사이즈가 점점 커져갈 수 밖에 없고 당연히 부딪히게 될 수 밖에 없는 문제가 될 것입니다.운 좋게도 저는 코드 분할(code spliting)에 대해 먼저 접하게..." }, { "title": "[React] dynamic import", "url": "/posts/React-dynamic-import/", "categories": "Frontend, React", "tags": "react", "date": "2022-04-27 00:00:00 +0900", "snippet": "하나의 애플리케이션의 번들 사이즈가 엄청 커지게 되면 초기에 웹 페이지 로딩 속도가 엄청 느려질 것이다.당연히 실무에서는 애플리케이션의 사이즈가 점점 커져갈 수 밖에 없고 당연히 부딪히게 될 수 밖에 없는 문제가 될 것이다.운 좋게도 팀원을 통해 코드 분할(code spliting)에 대해 먼저 접하게 되었는데, 맨 처음 들었을땐 이해가 부족하여 좀 더 학습하게 되었다.벨로그에 잘 정리된 포스팅이 있어 이 내용을 바탕으로 정리해보려 한다.그리고 추후 프로젝트에 적용해보려고 한다.Code SplitingCode Spliting은..." }, { "title": "[학습할래] Webpack", "url": "/posts/Webpack/", "categories": "학습할래", "tags": "mobx", "date": "2022-04-22 00:00:00 +0900", "snippet": "webpack을 주제로 선정하게 된 이유는 프론트 개발 환경에서 가장 중추적인 역할을 하고 있기 때문입니다.그러다보니 프론트엔드 개발자라면 한 번쯤은 깊게 학습해볼 필요가 있는 부분이라 생각하고 스스로 학습 내용을 정리할겸 주제로 선정하게 되었습니다.1. 웹팩이란 무엇이고 왜 사용하는가?웹팩에 대해 학습해본 사람이라면 한 번쯤 위와 같은 이미지를 본 적이 있을 것입니다.웹팩에 대해 한 문장으로 표현을 한다면 자바스크립트 모듈 번들러 라고 표현할 수 있습니다. 즉, 여러 개의 모듈을 하나로 번들링(묶어주는) 역할을 합니다. 이때..." }, { "title": "모노레포", "url": "/posts/%EB%AA%A8%EB%85%B8%EB%A0%88%ED%8F%AC/", "categories": "Frontend, Environment", "tags": "yarn, monorepo", "date": "2022-04-16 00:00:00 +0900", "snippet": "모노레포란?모노레포(MonoRepo) 는 Monolithic Repositories 의 약자로, 하나의 레포지토리에서 여러 개의 프로젝트가 구성된 것을 의미한다.보통 하나의 레포지토리 안에 하나의 프로젝트가 들어가있는 것이 일반적인데, 이러한 일반적인 형태의 프로젝트 구성을 Multi-repo, PolyRepo 라고 한다.모노레포를 사용하는 이유모노레포를 사용하는 이유는 무엇보다 컴포넌트의 공통화를 위해 많이 사용할 것이다.일반적으로 디자인시스템을 기반으로 공통 컴포넌트들이 도출될텐데 이는 보통 여러 프로젝트(코어 프로젝트, ..." }, { "title": "패키지 매니저 잠금 파일(lock)", "url": "/posts/%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%A7%A4%EB%8B%88%EC%A0%80-%EC%9E%A0%EA%B8%88-%ED%8C%8C%EC%9D%BC(package-lock-%EB%B0%8F-yarn-lock)/", "categories": "Frontend, Environment", "tags": "webpack", "date": "2022-04-13 00:00:00 +0900", "snippet": "npm이나 yarn을 사용하면 package-lock.json, yarn.lock 파일이 생성되는 것을 확인할 수 있다.왜 그럴까?자세한 내용은 여기에서 확인할 수 있는데 간략하게 정리해보자면 다음과 같다. 잠금 파일(lock)이 생긴 이유는 설치할때마다 동일한 패키지 버전을 보장하기 위해서이다. 왜냐하면, 시맨틱 버저닝 규칙에 따른 ~, ^ 때문이다. 예를 들어, &quot;react&quot;: &quot;^16.8.2&quot; 이렇게 리액트 버전을 지정할 경우 16.8.2 이상 17.0.0 미만의 범위로 버전이 지..." }, { "title": "[Webpack] resolve alias 설정", "url": "/posts/webpack-resolve-alias-%EC%84%A4%EC%A0%95/", "categories": "Frontend, Environment", "tags": "webpack", "date": "2022-04-12 00:00:00 +0900", "snippet": "javascript import 키워드로 모듈을 가져올때 일반적으로는 아래와 같이 상대 경로를 통해 해당 모듈을 가져오게 된다.import child from &#39;./store/child&#39;;하지만 만약 이를 절대 경로를 하고자 한다면 어떻게 해야할까? 바로 웹팩에 resolve object에 alias 설정을 해주면 된다. 실습을 위해 util 디렉토리 생성 후 util 클래스를 하나 만들어준다.그리고 webpack.config.js 파일에 아래와 같은 설정을 추가해준다. webpack.config.jsmodul..." }, { "title": "yarn workspace", "url": "/posts/yarn-workspace/", "categories": "Frontend, Environment", "tags": "yarn, workspace", "date": "2022-04-10 00:00:00 +0900", "snippet": "모노레포에 대해선 여기에서 알아보았고 모노레포를 구성하는 방법 중에 yarn workspace 로 구성하는 방법을 알아보자.yarn workspace 사용법들어가기에 앞서 yarn 의 workspace 기능을 통해서 MonoRepo 를 구성하는 방식은 아주 간단하다.먼저 아래 커맨들를 실행하여 npm프로젝트를 초기화해주자.yarn init그리고 package.json 에 아래와 같이 private 과 workspaces Property를 설정하면 된다.{ ... &quot;private&quot;: true, &quot;..." }, { "title": "[React] Storybook이란", "url": "/posts/Storybook%EC%9D%B4%EB%9E%80/", "categories": "Frontend, React, Storybook", "tags": "storybook", "date": "2022-04-09 00:00:00 +0900", "snippet": "실습 내용은 깃허브 레포지토리를 통해 확인하실 수 있습니다.Storybook이란?스토리북은 UI 컴포넌트 개발 도구이다. 스토리북은 실제 애플리케이션 외에 별도의 서버로 구동되어 화면 상에서 UI 컴포넌트들을 직접 눈으로 확인하며 조작(Controls)할 수 있다.그리하여 Storybook을 활용하면 UI 컴포넌트를 내부 개발자들을 위해 쉽게 문서화할 수 있고 디자인 시스템을 개발하는데 훨씬 더 편리하게 도와준다.스토리북(storybook)을 구성하는 기본 단위는 스토리(story)이며, 하나의 UI 컴포넌트는 보통 하나 이상..." }, { "title": "[학습할래] Mobx", "url": "/posts/Mobx/", "categories": "학습할래", "tags": "mobx", "date": "2022-04-08 00:00:00 +0900", "snippet": "1) Mobx 란?mobx는 프론트엔드에서 사용하는 애플리케이션 상태 관리 프레임워크입니다. 애플리케이션 전반에서 사용하는 상태(state, 자주 변경되어 관리되는 데이터)를 손쉽게 관리하여 변경에 대한 반응을 처리해줄 수 있는 라이브러리입니다. 보통 리액트에선 Redux와 Mobx를 많이 사용하며 INHR+는 Mobx를 사용하고 있습니다.2) 상태란 무엇일까?예를 들어, 현재 개발하고 있는 CMS 구성원 상세 팝업에서 대표 조직 토글 버튼을 클릭시 화면에서 자동으로 on/off 처리가 됩니다. 이처럼 사용자의 인터렉션을 통해..." }, { "title": "[Architecture] MVVM 구조", "url": "/posts/MVVM/", "categories": "Architecture", "tags": "architecture, mvvm", "date": "2022-04-07 00:00:00 +0900", "snippet": "Reference https://velog.io/@k7120792/Model-View-ViewModel-Pattern" }, { "title": "[Mobx] observable vs makeAutoObersable vs makeObservable", "url": "/posts/observable-vs-makeAutoObersable-vs-makeObservable/", "categories": "Frontend, Mobx", "tags": "mobx", "date": "2022-04-06 00:00:00 +0900", "snippet": "Observable Statemobx에서 observable 을 만드는 방법은 세 가지가 있다. makeObservable makeAutoObservable observablemakeObservablemakeObservable을 사용하여 하나씩 notation하는 방법import { makeObservable, observable, computed, action } from &quot;mobx&quot;class Doubler { value // observable constructor(value) { ..." }, { "title": "[Mobx] Action", "url": "/posts/action/", "categories": "Frontend, Mobx", "tags": "mobx", "date": "2022-04-06 00:00:00 +0900", "snippet": "Actionsaction은 state를 변경하는 코드이다. 원칙적으로 action은 항상 어떠한 이벤트에 의해 일어나게 된다. 예를 들면, 버튼 클릭, 인풋 변경, 웹소켓 메시지 도착 등등의 이벤트에 대한 응답으로 action이 일어나게 된다.makeAutoObservable을 사용하는 경우는 예외지만, 그 외에는 action임을 MobX에게 알려주어야 한다. 그렇게 했을 때의 성능상 이점은 다음과 같다. action을 사용하는 것이 코드를 더 잘 구조화하게 해주고, 성능상 이점을 가져다준다. 1)action은 transac..." }, { "title": "[Webpack] Source Map", "url": "/posts/sourceMap/", "categories": "Frontend, Environment", "tags": "npm, yarn", "date": "2022-04-05 00:00:00 +0900", "snippet": "소스맵(Source Map) 이란?웹팩은 흔히 여러 자바스크립트 파일을 하나로 합쳐주는 번들의 역할을 한다. 그리고 보통 서버에 배포할때 성능 최적화를 위해 HTML, CSS, JS와 같은 웹 자원들을 합축하게 된다. 그런데 만약 압축하여 배포한 파일에서 에러가 난다면 어떻게 디버깅할 수 있을까?바로 소스 맵을 이용해 배포용 파일의 특정 부분이 원본 소스의 어떤 부분인지 확인하는 것이다. 이러한 편의성을 제공하는 것이 소스 맵입니다.소스 맵 설정하기웹팩에서 소스 맵을 설정하는 방법은 아래와 같습니다.// webpack.conf..." }, { "title": "[Mobx] mobx란?", "url": "/posts/mobx%EB%9E%80/", "categories": "Frontend, Mobx", "tags": "mobx", "date": "2022-04-02 00:00:00 +0900", "snippet": "Mobx란?Mobx는 프론트엔드를 위한 애플리케이션 상태 관리 라이브러리이다. 애플리케이션 전반에서 사용하는 상태(state, 자주 변경되어 관리되는 데이터)를 손쉽게 관리하여 변경에 대한 반응을 처리해줄 수 있는 라이브러리이다. 그래서 전역 상태 라이브러리 라고 표현하기도 한다.상태 관리는 왜 필요할까? mobx를 왜 사용해야 할까?간단하게 두 가지를 볼 수 있다. 1)유지보수가 쉬워지도록 상태 로직을 분리하여 모듈화 할 수 있다. 2)상태관리의 단계를 간결하게 해준다. Note: Mobx는 간단하고(Simple) 확장..." }, { "title": "[React] React Typescript 프로젝트에 eslint prettier 설정", "url": "/posts/react-typescript-eslint-prettier-%EC%84%A4%EC%A0%95/", "categories": "Frontend, React", "tags": "react, typescript, eslint, prettier", "date": "2022-03-31 00:00:00 +0900", "snippet": "React(with Typescript) 프로젝트를 빌딩하면서 직접 eslintrc 파일을 설정해보며 학습했던 내용들을 한 번 정리해보려고 한다.ESLint와 Prettier프로젝트가 커지고 개발자가 많아지면 javascript 코드 구조가 일관성을 유지할 수 없을 가능성이 커진다.이러한 문제를 해결해주기 위한 도구들이 Eslint 와 Prettier 이다. 이 둘의 역할을 정리해보자면 다음과 같다. Eslint: 코드의 문법을 검사하는 린팅과 코드의 스타일을 잡아주는 포맷팅 기능을 한다. Prettier: 코드의 스타일을..." }, { "title": "[Typescript] tsconfig 설정 파일", "url": "/posts/tsconfig-%EC%84%A4%EC%A0%95-%ED%8C%8C%EC%9D%BC/", "categories": "Frontend, Typescript", "tags": "frontend, typescript, type, interface", "date": "2022-03-30 00:00:00 +0900", "snippet": "프로젝트 초기 개발 환경을 구축하면서 less파일을 module로 ts가 인식하지 못하는 문제를 겪었다.이와 관련해서 아래와 같이 타입 정의를 해줌으로써 해결할 수 있었다. style.d.tsdeclare module &#39;*.module.less&#39; { const classes: { [className: string]: string }; export default classes;}이를 해결하는 와중에 tscofig 파일을 많이 수정하게 되면서 타입스크립트의 다양한 옵션들에 대해 알아보는 시간을 가졌다.한 블로그..." }, { "title": "npm과 yarn의 차이", "url": "/posts/npm%EA%B3%BC-yarn%EC%9D%98-%EC%B0%A8%EC%9D%B4/", "categories": "Frontend, Environment", "tags": "npm, yarn", "date": "2022-03-29 00:00:00 +0900", "snippet": "npm과 yarn은 둘 다 자바스크립트 패키지매니저다.즉, 둘 다 여러 자바스크립트 의존성들을 손쉽게 관리해줄 수 있는 도구라고 할 수 있다.(마치 맥 유저들이 homebrew를 통해 손 쉽게 패키지를 관리할 수 있는 것처럼..)npm은 노드 패키지 매니저의 약자로 런ㄴ타임 동안 노드 환경에서 쓰이는 다양한 패키지들을 관리한다. npm은 npm registry라고 불리는 공개적인 패키지들로 구성된 db를 가지고 있다.(마치 자바의 메이븐 저장소처럼)yarn 은 npm의 부족한 점을 개선하기 위해 페이스북에서 개발되었다. 그럼 ..." }, { "title": "[프론트엔드 개발환경의 이해와 실습] 웹팩 핫로딩", "url": "/posts/%EC%9B%B9%ED%8C%A9-%ED%95%AB%EB%A1%9C%EB%94%A9/", "categories": "Frontend, Environment", "tags": "webpack, hotloading", "date": "2022-03-27 00:00:00 +0900", "snippet": "핫 모듈 리플레이스먼트배경웹팩 개발서버는 코드의 변화를 감지해서 전체 화면을 갱신하기 때문에 개발 속도를 높일 수 있다.하지만 어떤 상황에서는 전체 화면을 갱신하는 것이 좀 불편한 경우도 있다. 싱글페이지어플리케이션(SPA)은 브라우져에서 데이터를 들고 있기 때문에 리프레시 후에 모든 데이터가 초기화 되어 버리기 때문이다. 다른 부분을 수정했는데 입력한 폼 데이터가 날아가 버리는 경우도 있고 말이다.예를 들면, app.jsimport form from &quot;./form&quot;;import result from &qu..." }, { "title": "[프론트엔드 개발환경의 이해와 실습] 웹팩 최적화", "url": "/posts/%EC%9B%B9%ED%8C%A9-%EC%B5%9C%EC%A0%81%ED%99%94/", "categories": "Frontend, Environment", "tags": "webpack", "date": "2022-03-27 00:00:00 +0900", "snippet": "웹팩 최적화코드가 많아지면 번들링된 결과물도 커지기 마련이다. 거의 메가바이트 단위로 커질수도 있는데 브라우져 성능에 영향을 줄 수 있다. 파일을 다운로드하는데 시간이 많이 걸리기 때문이다. 이번 포스팅에서는 번들링한 결과물을 어떻게 최적화 할수 있는지 몇가지 방법에 대해 알아볼 것이다.1) production 모드웹팩에 내장되어 있는 최적화 방법중 mode 값을 설정하는 방식이 가장 기본이다. 세 가지 값이 올 수 있는데 지금까지 설정한 &quot;development&quot;는 디버깅 편의를 위해 아래 두 개 플러그인을 ..." }, { "title": "[프론트엔드 개발환경의 이해와 실습] 웹팩 개발 서버", "url": "/posts/%EC%9B%B9%ED%8C%A9-%EA%B0%9C%EB%B0%9C-%EC%84%9C%EB%B2%84/", "categories": "Frontend, Environment", "tags": "webpack, webpack-dev-server", "date": "2022-03-26 00:00:00 +0900", "snippet": "웹팩 개발 서버배경지금까지는 브라우져에 파일을 직접 로딩해서 결과물을 확인했다. 인터넷에 웹사이트를 게시하려면 실제 서버를 기동하여 이 파일을 읽고 요청한 클라이언트에게 제공해야 한다.개발환경에서도 이와 유사한 환경을 갖추는 것이 좋다. 운영환경과 맞춤으로써 배포시 잠재적 문제를 미리 확인할 수 있다. 게다가 ajax 방식의 api 연동은 cors 정책 때문에 반드시 서버가 필요하다.프론트엔드 개발환경에서 이러한 개발용 서버를 제공해 주는 것이 webpack-dev-server다.설치 및 사용먼저 webpack-dev-serv..." }, { "title": "[프론트엔드 개발환경의 이해와 실습] 웹팩 API 서버 연동", "url": "/posts/%EC%9B%B9%ED%8C%A9-API-%EC%84%9C%EB%B2%84-%EC%97%B0%EB%8F%99/", "categories": "Frontend, Environment", "tags": "webpack, webpack-dev-server", "date": "2022-03-26 00:00:00 +0900", "snippet": "API 연동프론트엔드에서는 서버와 데이터 주고 받기 위해 ajax를 사용한다. 보통은 api 서버를 어딘가에 띄우고(혹은 로컬 호스트에 띄우고) 프론트 서버와 함께 개발한다. 개발 환경에서 이러한 api 서버 구성을 어떻게 하는지 알아 보자.목업 API 1: devServer.before웹팩 개발 서버 설정 중 before 속성은 웹팩 서버에 기능을 추가할 수 있는 여지를 제공한다. 이것을 이해하려면 노드 Express.js에 사전지식이 있으면 유리한데, 간단히 말하면 익스프레스는 미들웨어 형태로 서버 기능을 확장할 수 있는 ..." }, { "title": "[프론트엔드 개발환경의 이해와 실습] eslint 자동화하는 방법", "url": "/posts/eslint-%EC%9E%90%EB%8F%99%ED%99%94%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95/", "categories": "Frontend, Environment", "tags": "eslint, prettier", "date": "2022-03-26 00:00:00 +0900", "snippet": "eslint 자동화린트는 코딩할 때마다 수시로 실행해야하는데 이러한 일은 자동화 하는 것이 좋다. &quot;깃 훅을 사용하는 방법&quot;과 &quot;에디터 확장 도구&quot;를 사용하는 방법이 있다.깃 훅을 사용하는 방법소스 트래킹 도구로 깃을 사용한다면 깃 훅을 이용하는 것이 좋다. 커밋 전, 푸시 전 등 깃 커맨드 실행 시점에 끼여들수 있는 훅을 제공한다. husky는 깃 훅을 쉽게 사용할 수 있는 도구다. (Git 2.13.0 이상 버전을 지원) 커밋 메세지 작성전에 끼어들어 린트로 코드 검사 작업을 추가하면 좋..." }, { "title": "[프론트엔드 개발환경의 이해와 실습] 프리티어(Prettier)", "url": "/posts/Prettier/", "categories": "Frontend, Environment", "tags": "prettier", "date": "2022-03-25 00:00:00 +0900", "snippet": "Prettier프리티어는 코드를 &quot;더&quot; 예쁘게 만든다. ESLint의 역할 중 포매팅과 겹치는 부분이 있지만 프리티터는 좀 더 일관적인 스타일로 코드를 다듬는다.반면 코드 품질과 관련된 기능은 하지 않는 것이 ESLint와 다른 점이다.설치 및 사용법프리티어 패키지를 다운로드 하고npm i -D prettier코드를 아래 처럼 작성한다. app.jsconsole.log(&#39;hello world&#39;)Prettier로 검사해 보자.npx prettier app.js --write--write 옵션을 ..." }, { "title": "[프론트엔드 개발환경의 이해와 실습] 웹팩과 sass", "url": "/posts/%EC%9B%B9%ED%8C%A9%EA%B3%BC-sass/", "categories": "Frontend, Environment", "tags": "webpack, sass", "date": "2022-03-24 00:00:00 +0900", "snippet": "babel이 es6이상의 자바스크립트 코드를 es5로 변경해주는 것과 같이 sass 또한 sass 문법으로된 코드를 css로 바꿔준다.sass에는 두 가지 sass, scss 가 있다. 만약 sass(문법) + css 코드까지 사용할거면 scss 를 사용한다.sass-loader 관련해서는 여기 를 참고하자.아래 명령어로 설치를 하면 된다.npm install sass-loader sass webpack --save-dev sass-loader: 웹팩에서 sass파일을 만나면 node-sass를 돌려주는 역할 no..." }, { "title": "[프론트엔드 개발환경의 이해와 실습] ESLint", "url": "/posts/ESLint/", "categories": "Frontend, Environment", "tags": "eslint", "date": "2022-03-24 00:00:00 +0900", "snippet": "1) 린트1) 배경오래된 스웨터의 보푸라기 같은 것을 린트(Lint)라고 부른다. 보푸라기가 많으면 옷이 보기 좋지 않은데 코드에서도 이런 보프라기가 있다. 들여쓰기를 맞추지 않은 경우, 선언한 변수를 사용하지 않은 경우……보프라기 있는 옷을 입을 수는 있듯이 이러한 코드로 만든 어플리케이션도 동작은 한다. 그러나 코드의 가독성이 떨어지고 점점 유지보수하기 어려운 애물단지가 되어버리기 일쑤다.보푸라기를 제거하는 린트 롤러(Lint roller)처럼 코드의 오류나 버그, 스타일 따위를 점검하는 것을 린트(Lint) 혹은 린터(L..." }, { "title": "[프론트엔드 개발환경의 이해와 실습] 바벨의 기본 개념", "url": "/posts/%EB%B0%94%EB%B2%A8%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B0%9C%EB%85%90/", "categories": "Frontend, Environment", "tags": "babel", "date": "2022-03-22 00:00:00 +0900", "snippet": "1) 배경크로스 브라우징브라우져마다 사용하는 언어가 달라서 프론트엔트 코드는 일관적이지 못할 때가 많다. 스팩과 브라우져가 개선되고 있지만, 여전히 인터넷 익스플로러는 프라미스를 이해하지 못한다. 작년까지만 해도 사파리 최신 브라우져는 Promise.prototype.finally 메소드를 사용할 수 없었다. 프론트엔드 개발에서 크로스브라우징 이슈는 코드의 일관성을 해치고 초심자를 불안하게 만든다. 히브리어로 바벨이 혼돈이란 뜻인 것처럼 말이다.크로스브라우징의 혼란을 해결해 줄 수 있는 것이 바벨이다. ECMAScript201..." }, { "title": "[프론트엔드 개발환경의 이해와 실습] 바벨 사용법과 웹팩 통합", "url": "/posts/%EB%B0%94%EB%B2%A8-%EC%82%AC%EC%9A%A9%EB%B2%95%EA%B3%BC-%EC%9B%B9%ED%8C%A9-%ED%86%B5%ED%95%A9/", "categories": "Frontend, Environment", "tags": "babel", "date": "2022-03-22 00:00:00 +0900", "snippet": "바벨 사용법과 웹팩 통합프리셋 사용하기바벨은 목적에 따라 몇 가지 프리셋을 제공한다. preset-env preset-flow preset-react preset-typescriptpreset-env는 ECMAScript2015+를 변환할 때 사용한다. 바벨 7 이전 버전에는 연도별로 각 프리셋을 제공했지만(babel-reset-es2015, babel-reset-es2016, babel-reset-es2017, babel-reset-latest) 지금은 env 하나로 합쳐졌다.(굉장히 깔끔해졌다)preset-flow,..." }, { "title": "[프론트엔드 개발환경의 이해와 실습] 자주 사용하는 웹팩 플러그인", "url": "/posts/%EC%9E%90%EC%A3%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9B%B9%ED%8C%A9-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8/", "categories": "Frontend, Environment", "tags": "webpack, plugins", "date": "2022-03-21 00:00:00 +0900", "snippet": "자주 사용하는 웹팩 플러그인개발하면서 플러그인을 직접 작성할 일은 거의 없었다. 웹팩에서 직접 제공하는 플러그인을 사용하거나 써드파티 라이브러리를 찾아 사용하는데 자주 사용하는 플러그인에 대해 알아보자.BannerPlugin번들 결과물에 빌드 정보나 커밋 버전같은 걸 추가할 수 있다. webpack.config.jsconst webpack = require(&#39;webpack&#39;);module.exports = { plugins: [ new webpack.BannerPlugin({ banner: &#..." }, { "title": "[프론트엔드 개발환경의 이해와 실습] 웹팩 플러그인", "url": "/posts/%EC%9B%B9%ED%8C%A9-%ED%94%8C%EB%9F%AC%EA%B7%B8%EC%9D%B8/", "categories": "Frontend, Environment", "tags": "webpack, plugins", "date": "2022-03-20 00:00:00 +0900", "snippet": "플러그인웹팩에서 알아야 할 마지막 기본 개념이 플러그인이다.1) 플러그인의 역할로더가 파일 단위로 처리하는 반면, 플러그인은 번들된 결과물을 처리한다. 번들된 자바스크립트를 난독화한다거나 특정 텍스트를 추출하는 용도로 사용한다.2) 커스텀 플러그인 만들기웹팩 문서의 Writing a plugin을 보면 클래스로 플러그인을 정의 하도록 한다. 헬로월드 코드를 가져다 그대로 실행 붙여보자. my-webpack-plugin.jsclass MyWebpackPlugin { apply(compiler) { compiler.hoo..." }, { "title": "[프론트엔드 개발환경의 이해와 실습] 자주 사용하는 로더", "url": "/posts/%EC%9E%90%EC%A3%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EB%A1%9C%EB%8D%94/", "categories": "Frontend, Environment", "tags": "webpack, loader", "date": "2022-03-18 00:00:00 +0900", "snippet": "자주 사용하는 로더css-loader웹팩은 모든것을 모듈로 바라보기 때문에 자바스크립트 뿐만 아니라 스타일시트로 import 구문으로 불러 올수 있다. app.jsimport &quot;./app.css&quot; app.cssbody { background-color: green;}CSS 파일을 자바스크립트에서 불러와 사용하려면 CSS를 모듈로 변환하는 작업이 필요하다. css-loader 가 그러한 역할을 하는데 코드에서 CSS 파일을 모듈처럼 불러와 사용할 수 있게끔 해준다.먼저 로더를 설치 하자.$ npm inst..." }, { "title": "[프론트엔드 개발환경의 이해와 실습] 모듈", "url": "/posts/%EB%A1%9C%EB%8D%94/", "categories": "Frontend, Environment", "tags": "webpack, loader", "date": "2022-03-18 00:00:00 +0900", "snippet": "로더로더의 역할웹팩은 모든 파일을 모듈로 바라본다. 자바스크립트로 만든 모듈 뿐만아니라 스타일시트, 이미지, 폰트 까지도 전부 모듈로 보기 때문에 import 구문을 사용하면 자바스크립트 코드 안으로 가져올수 있다.이것이 가능한 이유는 웹팩의 로더 덕분이다. 로더는 타입스크립트 같은 다른 언어를 자바스크립트 문법으로 변환해 주거나 이미지를 data URL 형식의 문자열로 변환한다. 뿐만아니라 CSS 파일을 자바스크립트에서 직접 로딩할수 있도록 해준다.커스텀 로더 만들기로더를 사용하기 전에 동작 원리를 이해하기 위해 로더를 직접..." }, { "title": "[프론트엔드 개발환경의 이해와 실습] 엔트리/아웃풋 실습", "url": "/posts/%EC%97%94%ED%8A%B8%EB%A6%AC-%EC%95%84%EC%9B%83%ED%92%8B-%EC%8B%A4%EC%8A%B5/", "categories": "Frontend, Environment", "tags": "webpack, entry, output", "date": "2022-03-17 00:00:00 +0900", "snippet": "웹팩의 엔트리와 아웃풋이전 포스팅에서 웹팩이 필요한 이유에 대해 알아보았다. 짧게 요약하면 모든 브라우저 환경에서 모듈 시스템을 적용하기 위해서이다.출처: webpack.js.org왼쪽 이미지처럼 웹팩은 js를 비롯한 여러 모듈들을 하나로 묶어주는 번들러 역할을 한다. 이전 예시에서 app.js는 math.js 파일을 import 키워드로 가지고 있다. 이는 app.js는 math.js 에 대한 의존성을 가지고 있다고 표현할 수 있는데 웹팩은 이러한 의존성을 가진 모든 모듈들을 하나의 번들(오른쪽 이미지에서 js, css, i..." }, { "title": "[프론트엔드 개발환경의 이해와 실습] 프론트엔드 개발환경의 이해: NPM", "url": "/posts/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%ED%99%98%EA%B2%BD%EC%9D%98-%EC%9D%B4%ED%95%B4/", "categories": "Frontend, Environment", "tags": "npm", "date": "2022-03-16 00:00:00 +0900", "snippet": "몇 년 전부터 프론트엔드 개발자 채용 공고에 Node.js 기술이 우대 사항 항목으로로 추가 되었다. Node.js는 백엔드를 구현하는 기술이라고 생각했다면 이 채용 항목이 의문이었을지 모르겠다. 웹 어플리케이션 개발에 직접적으로 사용하는 것은 아니지만 개발 환경을 이해하고 구성하는데 Node.js를 모르면 언젠가는 한계에 부딪히게 될 것이다.프론트엔드 개발에 Node.js가 필요한 이유1) 최신 스펙으로 개발할 수 있다.자바스크립트 스펙은 빠르게 발전하고 있는데 이에 비해 브라우저의 지원 속도는 항상 뒤쳐진다. 아무리 편리한..." }, { "title": "[프론트엔드 개발환경의 이해와 실습] 웹팩이 필요한 이유와 기본 동작", "url": "/posts/%EC%9B%B9%ED%8C%A9%EC%9D%B4-%ED%95%84%EC%9A%94%ED%95%9C-%EC%9D%B4%EC%9C%A0%EC%99%80-%EA%B8%B0%EB%B3%B8-%EB%8F%99%EC%9E%91/", "categories": "Frontend, Environment", "tags": "webpack", "date": "2022-03-16 00:00:00 +0900", "snippet": "웹팩이 필요한 이유웹팩이 필요한 이유, 즉 해당 기술이 해결하고자 하는 본질에 대해 알아보자.배경먼저 모듈에 대해 이야기 해보자. 문법 수준에서 모듈을 지원하기 시작한 것은 ES2015부터다. import/export 구문이 없었던 모듈 이전 상황을 살펴보는 것이 웹팩 등장 배경을 설명하는데 수월할 것 같다.아래 덧셈 함수를 보자. math.jsfunction sum(a, b) { return a + b} // 전역 공간에 sum이 노출 app.jssum(1, 2) // 3위 코드는 모두 하나의 HTML 파일 안에서 로딩..." }, { "title": "[프론트엔드 개발환경의 이해와 실습] 외부 패키지 관리 방법", "url": "/posts/%EC%99%B8%EB%B6%80-%ED%8C%A8%ED%82%A4%EC%A7%80-%EA%B4%80%EB%A6%AC-%EB%B0%A9%EB%B2%95/", "categories": "Frontend, Environment", "tags": "npm, cdn, versioning", "date": "2022-03-16 00:00:00 +0900", "snippet": "패키지 설치1) CDN을 이용한 방법외부 패키지를 가져오는 가장 간단한 방법은 CDN(컨텐츠 전송 네트워크)으로 제공하는 라이브러리를 직접 가져오는 방식이다. 리액트의 주소를 html에서 로딩하면 된다.&amp;lt;script src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&amp;gt;&amp;lt;/script&amp;gt;하지만 네트워크를 통해 받아오는거기에 CDN 서버 장애가 발생하면 이를 사용하는 웹 애플리케이션에 장애가 발생하게 될 것이다.2..." }, { "title": "[React] useState 사용시 제네릭을 사용하면 좋을 때", "url": "/posts/useState-%EC%82%AC%EC%9A%A9%EC%8B%9C-%EC%A0%9C%EB%84%A4%EB%A6%AD%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%EC%A2%8B%EC%9D%84-%EB%95%8C/", "categories": "Frontend, React", "tags": "frontend, react", "date": "2022-03-13 00:00:00 +0900", "snippet": "Typescript를 적용한 React 프로젝트에서 useState 훅을 사용시 일반적으로 아래와 같이 제네릭을 사용하지 않아도 무방하다.import React, { useState } from &#39;react&#39;;function Counter() { const [count, setCount] = useState(0); const onIncrease = () =&amp;gt; setCount(count + 1); const onDecrease = () =&amp;gt; setCount(count - 1); re..." }, { "title": "[React] React.FC의 사용 여부에 따른 차이점", "url": "/posts/React.FC%EC%9D%98-%EC%82%AC%EC%9A%A9-%EC%97%AC%EB%B6%80%EC%97%90-%EB%94%B0%EB%A5%B8-%EC%B0%A8%EC%9D%B4%EC%A0%90/", "categories": "Frontend, React", "tags": "react", "date": "2022-03-12 00:00:00 +0900", "snippet": "리액트 타입스크립트 프로젝트에서 컴포넌트를 선언할때 React.FC 키워드를 선언할 수 도 있고 선언하지 않을 수도 있다.React.FC 를 사용했을 때의 장점1) props 에 기본적으로 children 이 들어가있다.2) 컴포넌트의 defaultProps, propTypes, contextTypes 를 설정 할 때 자동완성이 될 수 있다React.FC 를 사용했을 때의 단점1) children 이 옵셔널 형태로 들어가있다보니까 어찌 보면 컴포넌트의 props 의 타입이 명백하지 않다. 예를 들어 어떤 컴포넌트는 child..." }, { "title": "[Typescript] Type Aliases(type)과 Interfaces(interface)의 차이", "url": "/posts/type%EA%B3%BC-interface%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90/", "categories": "Frontend, Typescript", "tags": "frontend, typescript, type, interface", "date": "2022-03-10 00:00:00 +0900", "snippet": "typescript 를 사용하면서 type aliases 와 interface의 차이점에 대한 궁금증이 생겼다.둘 다 type 을 선언할 때 사용한다는 점만 알고 있었을 뿐 둘의 차이는 정확하게 무엇일까라는 의구심이 들었다.Type Aliases와 Interfaces의 차이Type aliases(type)와 Interfaces(interface)는 굉장히 비슷하고, 많은 경우에 자유롭게 선택해서 사용할 수 있다. interface의 거의 모든 기능을 type에서도 사용할 수 있지만, 가장 구별되는 점은 type은 새 프로퍼티를..." }, { "title": "[2장. 리액트 컴포넌트 스타일링하기] 04. 리액트 컴포넌트 스타일링하기 정리", "url": "/posts/04-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%8A%A4%ED%83%80%EC%9D%BC%EB%A7%81%ED%95%98%EA%B8%B0-%EC%A0%95%EB%A6%AC/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-02-07 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.04. 리액트 컴포넌트 스타일링하기 정리리액트 컴포넌트를 스타일링 할 때 사용 할 수 있는 도구는 다양하고, 그 중에서 정해진 답은 없다. 다양한 도구들을 조금씩 사용해보고, 취향에 맞는 도구를 위주로 사용하면 된다." }, { "title": "[2장. 리액트 컴포넌트 스타일링하기] 03. styled-components", "url": "/posts/03-styled-components/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-02-05 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.03. styled-components이번에 배워볼 기술은 CSS in JS 라는 기술이다. 이 문구가 뜻하는 그대로, 이 기술은 JS 안에 CSS 를 작성하는 것을 의미하는데, 이번 튜토리얼에서 해당 기술을 사용하는 라이브러리인 styled-components 를 다뤄볼 것이다.styled-components 는 현존하는 CSS in JS 관련 리액트 라이브러리 중에서 가장 인기 있는 라이브러리이다. 이에 대한 대안으로는 emoti..." }, { "title": "[2장. 리액트 컴포넌트 스타일링하기] 02. CSS Module", "url": "/posts/02-CSS-Module-copy/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-02-04 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.02. CSS Module이번에는 CSS Module 이라는 기술에 대해서 알아보자. 리액트 프로젝트에서 컴포넌트를 스타일링 할 때 CSS Module 이라는 기술을 사용하면, CSS 클래스가 중첩되는 것을 완벽히 방지할 수 있다.CRA 로 만든 프로젝트에서 CSS Module 를 사용 할 때에는, CSS 파일의 확장자를 .module.css 로 하면 되는데, 예를 들어서 다음과 같이 Box.module.css 라는 파일을 만들게 된..." }, { "title": "[2장. 리액트 컴포넌트 스타일링하기] 01. Sass", "url": "/posts/01-Sass/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-02-03 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.01. SassSass (Syntactically Awesome Style Sheets: 문법적으로 짱 멋진 스타일시트) 는 CSS pre-processor 로서, 복잡한 작업을 쉽게 할 수 있게 해주고, 코드의 재활용성을 높여줄 뿐 만 아니라, 코드의 가독성을 높여주어 유지보수를 쉽게해준다.이 튜토리얼에서는 Sass 의 기초적인 내용만 다루게 된다. 만약에 Sass 에 대해서 더 제대로 알아보시고 싶다면, 포스팅 원작자분이 쓴 포스..." }, { "title": "[2장. 리액트 컴포넌트 스타일링하기] 00. 리액트 컴포넌트 스타일링하기 개요", "url": "/posts/00-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%8A%A4%ED%83%80%EC%9D%BC%EB%A7%81%ED%95%98%EA%B8%B0-%EA%B0%9C%EC%9A%94/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-02-03 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.00. 개요이번에는 리액트 컴포넌트를 스타일링하는 방법에 대해서 알아보자. 리액트에서 컴포넌트를 스타일링 할 때에는 다양한 기술이 사용될 수 있다.리액트에서 컴포넌트를 스타일링 하는 가장 기본적인 방법은 css 파일을 만들어서 컴포넌트에서 import 해서 사용하는 것이다. 이 방법은 어떤 사람들에게는 충분히 편리할 수도 있겠지만, 컴포넌트를 스타일링 할 때 다른 도구들을 사용하면 훨씬 더 편하게 작업을 할 수 있다.이 튜토리얼에서는..." }, { "title": "[1장. 리액트 입문] 27. 리액트 개발 할 때 사용하면 편리한 도구들 - Prettier, ESLint, Snippet", "url": "/posts/27-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EA%B0%9C%EB%B0%9C-%ED%95%A0-%EB%95%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EB%A9%B4-%ED%8E%B8%EB%A6%AC%ED%95%9C-%EB%8F%84%EA%B5%AC%EB%93%A4-Prettier-ESLint-Snippet/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-02-03 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.27. 리액트 개발 할 때 사용하면 편리한 도구들 - Prettier, ESLint, Snippet이번에는 리액트 개발을 할 때 사용하면 편리한 도구들에 대하여 알아보도록 하겠다. 이번에 다루게 되는 도구들은 모두 VS Code 와 연동해서 사용하는 도구들인데, 이 도구들은 VS Code 만 지원 하는 것이 아니라 WebStorm, Atom 등의 에디터에서도 사용이 가능하니, 만약 VS Code 가 아닌 에디터를 사용하고 계신 경우 ..." }, { "title": "[1장. 리액트 입문] 26. componentDidCatch 로 에러 잡아내기 / Sentry 연동", "url": "/posts/26-componentDidCatch-%EB%A1%9C-%EC%97%90%EB%9F%AC-%EC%9E%A1%EC%95%84%EB%82%B4%EA%B8%B0-%EB%B0%8F-Sentry-%EC%97%B0%EB%8F%99/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-02-03 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.26. componentDidCatch 로 에러 잡아내기 / Sentry 연동이번에는, componentDidCatch 라는 생명주기 메서드를 사용하여 리액트 애플리케이션에서 발생하는 에러를 처리하는 방법을 알아보자.먼저, 이번 튜토리얼을 진행 하기 위하여 새로운 프로젝트를 만들어주자.$ npx create-react-app error-catch그 다음에, 해당 디렉터리를 에디터로 열고, 개발 서버를 시작해주세요.$ cd error-..." }, { "title": "[1장. 리액트 입문] 25. LifeCycle Method", "url": "/posts/25-LifeCycle-Method/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-02-02 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.25. LifeCycle MethodLifeCycle Method 는 한국어로 &quot;생명주기 메서드&quot; 라고 부른다. 생명주기 메서드는 컴포넌트가 브라우저상에 나타나고, 업데이트되고, 사라지게 될 때 호출되는 메서드들 이다. 추가적으로 컴포넌트에서 에러가 났을 때 호출되는 메서드도 있다.생명주기 메서드는 클래스형 컴포넌트에서만 사용 할 수 있는데, 우리가 기존에 배웠었던 useEffect 랑 은근히 비슷하다고 생각하면 된..." }, { "title": "[1장. 리액트 입문] 24. 클래스형 컴포넌트", "url": "/posts/24-%ED%81%B4%EB%9E%98%EC%8A%A4%ED%98%95-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-02-02 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.24. 클래스형 컴포넌트이제는 잘 사용하지 않지만, 그래도 클래스형 컴포넌트에 대해서 알아보자. 앞으로 클래스형 컴포넌트를 사용하는 일은 거의 없겠지만 그래도 알아둘 필요는 있다. 나중에 클래스형 컴포넌트를 사용하는 프로젝트를 유지보수하게 되는 일이 있을 수도 있고, 함수형 컴포넌트 + Hooks 로 못하는 작업이 2개정도 있긴 하다.추가적으로, 옛날에 만들어진 리액트 관련 라이브러리의 경우에는 Hooks 지원이 아직 안되는 경우도 ..." }, { "title": "[1장. 리액트 입문] 23. Immer 를 사용한 더 쉬운 불변성 관리", "url": "/posts/23-Immer-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EB%8D%94-%EC%89%AC%EC%9A%B4-%EB%B6%88%EB%B3%80%EC%84%B1-%EA%B4%80%EB%A6%AC/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-02-02 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.23. Immer 를 사용한 더 쉬운 불변성 관리리액트에서 배열이나 객체를 업데이트 해야 할 때에는 직접 수정하면 안되고 불변성을 지켜주면서 업데이트를 해주어야 한다.예를 들면 다음과 같이 하면 안되고const object = { a: 1, b: 2};object.b = 3;다음과 같이 ...(스프레드) 연산자 를 사용해서 새로운 객체를 만들어주어야 한다.const object = { a: 1, b: 2};const nextO..." }, { "title": "[1장. 리액트 입문] 22. Context API 를 사용한 전역 값 관리", "url": "/posts/22-Context-API-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%A0%84%EC%97%AD-%EA%B0%92-%EA%B4%80%EB%A6%AC/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-02-02 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.22. Context API 를 사용한 전역 값 관리우리가 현재 만들고 있는 프로젝트를 보면, App 컴포넌트에서 onToggle, onRemove 가 구현이 되어있고, 이 함수들은 UserList 컴포넌트를 거쳐서 각 User 컴포넌트들에게 전달이 되고 있다.여기서 UserList 컴포넌트의 경우에는 onToggle 과 onRemove 를 전달하기 위하여 중간 다리역할만 하고 있다.function UserList({ users, o..." }, { "title": "[1장. 리액트 입문] 21. 커스텀 Hooks 만들기", "url": "/posts/21-%EC%BB%A4%EC%8A%A4%ED%85%80-Hooks-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-02-02 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.21. 커스텀 Hooks 만들기컴포넌트를 만들다보면, 반복되는 로직이 자주 발생하게 된다. 예를 들면 input 을 관리하는 코드는 관리 할 때마다 꽤나 비슷한 코드가 반복된다.이번에는 그러한 상황에 커스텀 Hooks 를 만들어서 반복되는 로직을 쉽게 재사용하는 방법을 알아볼 것이다.src 디렉터리에 hooks 라는 디렉터리를 만들고, 그 안에 useInputs.js 라는 파일을 만들자.커스텀 Hooks 를 만들 때에는 보통 이렇게 ..." }, { "title": "[1장. 리액트 입문] 20. useReducer 를 사용하여 상태 업데이트 로직 분리하기", "url": "/posts/20-useReducer-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%83%81%ED%83%9C-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%EB%A1%9C%EC%A7%81-%EB%B6%84%EB%A6%AC%ED%95%98%EA%B8%B0/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-02-02 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.20. useReducer 를 사용하여 상태 업데이트 로직 분리하기useReducer 이해하기이전에 만든 사용자 리스트 기능에서의 주요 상태 업데이트 로직은 App 컴포넌트 내부에서 이루어졌다. 상태를 업데이트 할 때에는 useState 를 사용해서 새로운 상태를 설정해주었는데, 상태를 관리하게 될 때 useState 를 사용하는것 말고도 다른 방법이 있다. 바로, useReducer 를 사용하는건데, 이 Hook 함수를 사용하면 컴..." }, { "title": "[1장. 리액트 입문] 19. React.memo 를 사용한 컴포넌트 리렌더링 방지", "url": "/posts/19-React-memo-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EB%A6%AC%EB%A0%8C%EB%8D%94%EB%A7%81-%EB%B0%A9%EC%A7%80/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-02-02 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.19. React.memo 를 사용한 컴포넌트 리렌더링 방지이번에는, 컴포넌트의 props 가 바뀌지 않았다면, 리렌더링을 방지하여 컴포넌트의 리렌더링 성능 최적화를 해줄 수 있는 React.memo 라는 함수에 대해 알아보자.이 함수를 사용한다면, 컴포넌트에서 리렌더링이 필요한 상황에서만 리렌더링을 하도록 설정해줄 수 있다.사용법은 굉장히 쉽다. 그냥, 감싸주시면 된다. 우선 CreateUser 부터 적용을 해주겠다. Create..." }, { "title": "[1장. 리액트 입문] 18. useCallback 을 사용하여 함수 재사용하기", "url": "/posts/18-useCallback-%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%ED%95%A8%EC%88%98-%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-02-02 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.18. useCallback 을 사용하여 함수 재사용하기useCallback 은 useMemo 와 비슷한 Hook 이다.useMemo 는 특정 결과값을 재사용 할 때 사용하는 반면, useCallback 은 특정 함수를 새로 만들지 않고 재사용하고 싶을때 사용한다.이전에 App.js 에서 구현했던 onCreate, onRemove, onToggle 함수를 확인해보자.const onCreate = () =&amp;gt; { const..." }, { "title": "[1장. 리액트 입문] 17. useMemo 를 사용하여 연산한 값 재사용하기", "url": "/posts/17-useMemo-%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EC%97%B0%EC%82%B0%ED%95%9C-%EA%B0%92-%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-02-01 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.17. useMemo 를 사용하여 연산한 값 재사용하기이번에는 성능 최적화를 위하여 연산된 값을 useMemo 라는 Hook 을 사용하여 재사용하는 방법을 알아보자.App 컴포넌트에서 다음과 같이 countActiveUsers 라는 함수를 만들어서, active 값이 true 인 사용자의 수를 세어서 화면에 렌더링을 해보자.App.jsimport React, { useRef, useState } from &#39;react&#39;;..." }, { "title": "[1장. 리액트 입문] 16. useEffect를 사용하여 마운트/언마운트/업데이트시 할 작업 설정하기", "url": "/posts/16-useEffect%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%97%AC-%EB%A7%88%EC%9A%B4%ED%8A%B8-%EC%96%B8%EB%A7%88%EC%9A%B4%ED%8A%B8-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EC%8B%9C-%ED%95%A0-%EC%9E%91%EC%97%85-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-01-30 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.16. useEffect를 사용하여 마운트/언마운트/업데이트시 할 작업 설정하기이번에는 useEffect 라는 Hook 을 사용하여 컴포넌트가 마운트 됐을 때 (처음 나타났을 때), 언마운트 됐을 때 (사라질 때), 그리고 업데이트 될 때 (특정 props가 바뀔 때) 특정 작업을 처리하는 방법에 대해서 알아보자.마운트/언마운트우선, 마운트/언마운트를 관리해보자. UserList.jsimport React, { useEffect }..." }, { "title": "[1장. 리액트 입문] 15. 배열에 항목 수정하기", "url": "/posts/15-%EB%B0%B0%EC%97%B4%EC%97%90-%ED%95%AD%EB%AA%A9-%EC%88%98%EC%A0%95%ED%95%98%EA%B8%B0/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-01-30 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.15. 배열에 항목 수정하기이번에는, 배열 항목을 수정하는 방법을 알아보자.User 컴포넌트에 계정명을 클릭했을때 색상이 초록색으로 바뀌고, 다시 누르면 검정색으로 바뀌도록 구현을 해보자.우선, App 컴포넌트의 users 배열 안의 객체 안에 active 라는 속성을 추가해주자. App.jsApp.jsimport React, { useRef, useState } from &#39;react&#39;;import UserList f..." }, { "title": "[1장. 리액트 입문] 14. 배열에 항목 제거하기", "url": "/posts/14-%EB%B0%B0%EC%97%B4%EC%97%90-%ED%95%AD%EB%AA%A9-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B8%B0/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-01-30 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.14. 배열에 항목 제거하기이번에는 배열에 항목을 제거 할 때 어떻게 해야 하는지 알아보자.우선, UserList 에서 각 User 컴포넌트를 보여줄 때, 삭제 버튼을 렌더링해주겠다. UserList.jsimport React from &#39;react&#39;;function User({ user, onRemove }) { return ( &amp;lt;div&amp;gt; &amp;lt;b&amp;gt;{use..." }, { "title": "[1장. 리액트 입문] 13. 배열에 항목 추가하기", "url": "/posts/13-%EB%B0%B0%EC%97%B4%EC%97%90-%ED%95%AD%EB%AA%A9-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-01-30 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.13. 배열에 항목 추가하기이번에는 배열에 새로운 항목을 추가하는 방법을 알아보자.우선, input 두개와 button 하나로 이루어진 CreateUser.js 라는 컴포넌트를 src 디렉터리에 만들어보자. CreateUser.jsimport React from &#39;react&#39;;function CreateUser({ username, email, onChange, onCreate }) { return ( &amp..." }, { "title": "[1장. 리액트 입문] 12. useRef 로 컴포넌트 안의 변수 만들기", "url": "/posts/12-useRef-%EB%A1%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%95%88%EC%9D%98-%EB%B3%80%EC%88%98-%EB%A7%8C%EB%93%A4%EA%B8%B0/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-01-30 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.12. useRef 로 컴포넌트 안의 변수 만들기컴포넌트에서 특정 DOM 을 선택해야 할 때, ref 를 사용해야 한다고 배웠었다. 그리고, 함수형 컴포넌트에서 이를 설정 할 때 useRef() 훅을 사용하여 설정한다고 배웠었다.useRef() Hook 은 DOM 을 선택하는 용도 외에도, 다른 용도가 한가지 더 있는데, 바로 컴포넌트 안에서 조회 및 수정 할 수 있는 변수를 관리하는 것 이다.useRef 로 관리하는 변수는 값이 바..." }, { "title": "[1장. 리액트 입문] 11. 배열 렌더링하기", "url": "/posts/11-%EB%B0%B0%EC%97%B4-%EB%A0%8C%EB%8D%94%EB%A7%81%ED%95%98%EA%B8%B0/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-01-30 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.11. 배열 렌더링하기이번에는 리액트에서 배열을 렌더링하는 방법을 알아보자.아래와 같은 배열이 있다고 가정해보자.const users = [ { id: 1, username: &#39;velopert&#39;, email: &#39;public.velopert@gmail.com&#39; }, { id: 2, username: &#39;tester&#39;, email: &#39;tester@exa..." }, { "title": "[1장. 리액트 입문] 10. useRef 로 특정 DOM 선택하기", "url": "/posts/10-useRef-%EB%A1%9C-%ED%8A%B9%EC%A0%95-DOM-%EC%84%A0%ED%83%9D%ED%95%98%EA%B8%B0/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-01-30 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.10. useRef 로 특정 DOM 선택하기JavaScript 를 사용 할 때 우리가 특정 DOM 을 선택해야 하는 상황에 getElementById, querySelector 같은 DOM Selector 함수를 사용해서 DOM 을 선택한다.리액트를 사용하는 프로젝트에서도 가끔씩 DOM 을 직접 선택해야 하는 상황이 발생 할 때도 있다.예를 들어서 특정 엘리먼트의 크기를 가져와야 한다던지, 스크롤바 위치를 가져오거나 설정해야된다던지,..." }, { "title": "[1장. 리액트 입문] 9. 여러개의 input 상태 관리하기", "url": "/posts/09-%EC%97%AC%EB%9F%AC%EA%B0%9C%EC%9D%98-input-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-01-30 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.9. 여러개의 input 상태 관리하기input 이 여러개일때는 어떻게 관리해야 하는지 알아보자.우선 지난번에 만든 InputSample 에서 새로운 input 을 추가해보자.이번에는 input 이 비어져있을때 인풋에 대한 설명을 보여주는 placeholder 값도 설정해보자.기존에 만들었던 상태는 지워주고, onChange 와 onReset 함수는 비워주자. InputSample.jsimport React, { useState }..." }, { "title": "[1장. 리액트 입문] 8. input 상태 관리하기", "url": "/posts/08-input-%EC%83%81%ED%83%9C-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-01-30 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.8. input 상태 관리하기이번에는 리액트에서 사용자가 입력 할 수 있는 input 태그의 상태를 관리하는 방법을 알아보자.우선, src 디렉터리에 InputSample 컴포넌트를 생성 후 App 컴포넌트에서 렌더링해보자. InputSample.jsimport React from &#39;react&#39;;function InputSample() { return ( &amp;lt;div&amp;gt; &amp;l..." }, { "title": "[1장. 리액트 입문] 7. useState 를 통해 컴포넌트에서 바뀌는 값 관리하기", "url": "/posts/07-useState-%EB%A5%BC-%ED%86%B5%ED%95%B4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EC%84%9C-%EB%B0%94%EB%80%8C%EB%8A%94-%EA%B0%92-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-01-30 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.7. useState 를 통해 컴포넌트에서 바뀌는 값 관리하기지금까지는 리액트 컴포넌트를 만들 때 동적인 부분이 하나도 없었다. 즉 값이 바뀌는 일이 없었다. 이번에는 컴포넌트에서 보여줘야 하는 내용이 사용자 인터랙션에 따라 바뀌어야 할 때 어떻게 구현할 수 있는지에 대하여 알아볼 것이다.리액트 16.8 이전 버전에서는 함수형 컴포넌트에서는 상태를 관리할 수 없었는데요, 리액트 16.8 에서 Hooks 라는 기능이 도입되면서 함수형 ..." }, { "title": "[1장. 리액트 입문] 6. 조건부 렌더링", "url": "/posts/06-%EC%A1%B0%EA%B1%B4%EB%B6%80-%EB%A0%8C%EB%8D%94%EB%A7%81/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-01-30 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.6. 조건부 렌더링조건부 렌더링이란, 특정 조건에 따라 다른 결괌루을 렌더링하는 것을 의미한다.예를 들어서, App 컴포넌트에서 Hello 컴포넌트를 사용 할 때, isSpecial 이라는 props 를 설정해보자.import React from &#39;react&#39;;import Hello from &#39;./Hello&#39;;import Wrapper from &#39;./Wrapper&#39;;function App()..." }, { "title": "[1장. 리액트 입문] 5. props를 통해 컴포넌트에게 값 전달하기", "url": "/posts/05-props%EB%A5%BC-%ED%86%B5%ED%95%B4-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90%EA%B2%8C-%EA%B0%92-%EC%A0%84%EB%8B%AC%ED%95%98%EA%B8%B0/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-01-30 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.5. props를 통해 컴포넌트에게 값 전달하기이번에는 컴포넌트의 props 라는 개념에 대해서 알아보자. props 는 properties 의 줄임말이다. 우리가 어떠한 값을 컴포넌트에게 전달해줘야 할 때, props 를 사용한다.props 의 기본 사용법예를 들어서, App 컴포넌트에서 Hello 컴포넌트를 사용 할 때 name 이라는 값을 전달해주고 싶다고 가정해보자. 그러면, 이렇게 코드를 작성하면 된다.import React..." }, { "title": "[1장. 리액트 입문] 4. JSX의 기본 규칙 알아보기", "url": "/posts/04-JSX%EC%9D%98-%EA%B8%B0%EB%B3%B8-%EA%B7%9C%EC%B9%99-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-01-30 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.4. JSX의 기본 규칙 알아보기JSX 는 리액트에서 생김새를 정의할 때, 사용하는 문법이다. 얼핏보면 HTML 같이 생겼지만 실제로는 JavaScript 이다.return &amp;lt;div&amp;gt;안녕하세요&amp;lt;/div&amp;gt;;리액트 컴포넌트 파일에서 XML 형태로 코드를 작성하면 babel 이 JSX 를 JavaScript 로 변환해준다.어떻게 변환되는지 한번 예시를 살펴보자.https://bit.ly/2..." }, { "title": "[1장. 리액트 입문] 3. 나의 첫번째 리액트 컴포넌트", "url": "/posts/03-%EB%82%98%EC%9D%98-%EC%B2%AB%EB%B2%88%EC%A7%B8-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-01-30 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.3. 나의 첫번째 리액트 컴포넌트첫번째 리액트 컴포넌트를 만들어보자.src 디렉터리에 Hello.js 라는 파일을 다음과 같이 작성해보세요. Hello.jsimport React from &#39;react&#39;;function Hello() { return &amp;lt;div&amp;gt;안녕하세요&amp;lt;/div&amp;gt;}export default Hello;리액트 컴포넌트를 만들 땐import React fr..." }, { "title": "[1장. 리액트 입문] 02. 작업환경 준비", "url": "/posts/02-%EC%9E%91%EC%97%85%ED%99%98%EA%B2%BD-%EC%A4%80%EB%B9%84/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-01-30 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.2. 작업환경 준비앞으로의 튜토리얼을 진행하기 위해 다음 항목들을 설치해주어야 한다. Node.js: Webpack 과 Babel 같은 도구들이 자바스크립트 런타임인 Node.js 를 기반으로 만들어져있다. 그렇기에 해당 도구들을 사용하기 위해서 Node.js 를 설치해야 한다. Yarn: 조금 개선된 버전의 npm 이라고 생각하면 된다. npm 은 Node.js 를 설치하게 될 때 같이 딸려오는 패키지 매니저 도구이다. 프로젝트..." }, { "title": "[1장. 리액트 입문] 01. 리액트는 어쩌다 만들어졌을까?", "url": "/posts/01-%EB%A6%AC%EC%95%A1%ED%8A%B8%EB%8A%94-%EC%96%B4%EC%A9%8C%EB%8B%A4-%EB%A7%8C%EB%93%A4%EC%96%B4%EC%A1%8C%EC%9D%84%EA%B9%8C/", "categories": "Frontend, ReactWithVelopert", "tags": "frontend, react, velopert", "date": "2022-01-30 00:00:00 +0900", "snippet": "본 포스팅은 벨로퍼트와 함께하는 모던 리액트를 학습 후 정리하는 목적으로 작성하는 포스팅입니다.01. 리액트는 어쩌다 만들어졌을까?어떤 기술을 새로 익힐때 해당 기술의 본질(해당 기술이 생겨난 배경, 풀어내고자 하는 문제)를 이해하는 것이 가장 중요하다고 생각한다. 리액트는 왜 만들어졌을까?Javascript를 사용하여 HTML 로 구성한 UI를 제어하고자한다면 다음과 같은 javascript 코드를 사용하여 DOM을 직접 제어하는 과정이 필요하다.const number = document.getElementById(&#39;..." }, { "title": "[Javascript] 호이스팅", "url": "/posts/%ED%98%B8%EC%9D%B4%EC%8A%A4%ED%8C%85/", "categories": "Frontend, Javascript", "tags": "javscript, es6, hoisting", "date": "2021-12-21 00:00:00 +0900", "snippet": "호이스팅이란?모든 변수 선언은 호이스트된다. 호이스트 란 변수의 정의가 그 범위에 따라 선언(declaration)/초기화(initialization)/할당 분리되는 것을 의미한다.쉽게 말하면 변수가 함수내에서 정의되었을 경우 선언이 함수의 최상위로, 함수 바깥에서 정의되었을 경우는 전역 컨텍스트의 최상위로 변경됩니다.const hoisting = () =&amp;gt; { console.log(&quot;First-Name:&quot;, name); var name = &quot;Marcus&quot;; console...." }, { "title": "[Spring] P6Spy", "url": "/posts/P6Spy/", "categories": "Spring", "tags": "spring, p6spy, datajpatest", "date": "2021-12-02 00:00:00 +0900", "snippet": "출처 https://zgundam.tistory.com/199 https://github.com/TerryChang/p6spytest https://backtony.github.io/spring/2021-08-13-spring-log-1/" }, { "title": "[Spring] Filter와 Interceptor 차이", "url": "/posts/Filter%EC%99%80-Interceptor-%EC%B0%A8%EC%9D%B4/", "categories": "Spring", "tags": "spring, filter, interceptor", "date": "2021-12-02 00:00:00 +0900", "snippet": "필터 정확한 명칭은 서블릿 필터(스프링에서 제공하는 기능이 아님) 필터를 적용할 경우 필터가 호출된 다음에 서블릿이 호출 따라서 모든 고객의 요청 로그를 남기는 요구사항이 있을 경우 필터를 사용필터 체인 필터는 체인으로 구성되며, 중간에 필터를 자유롭게 추가 및 제거할 수 있음 예를 들어 로그를 남기는 필터를 먼저 적용한 후 로그인 여부를 체크하는 필터를 이후에 추가할 수 있음 ex) HTTP 요청 -&amp;gt; WAS -&amp;gt; 필터 1 -&amp;gt; 필터 2 -&amp;gt;… -&amp;gt; 필..." }, { "title": "[JPA] JPA 정리", "url": "/posts/JPA-%EC%A0%95%EB%A6%AC/", "categories": "Backend, JPA", "tags": "spring, jpa, fetchjoin, querydsl, jpql, dynamicupdate, flush", "date": "2021-12-01 00:00:00 +0900", "snippet": "페치 조인의 한계1) 페치 조인 대상에는 별칭(alias)을 줄 수 없다.String query = &quot;select t from Team t join fetch t.members as m&quot;//as m 이라는 별칭(alias)는 fetch join에서 사용할 수 없다. 하이버네이트는 가능하지만, 가급적 사용을 하지 않는게 좋다 ex: 팀을 조회하는 상황에서 멤버가 5명인데 3명만 조회한 경우 3명만 따로 조작하는 것은 몹시 위험.하다.String query = &quot;select t from Team t ..." }, { "title": "[Swagger] springdoc vs springfox", "url": "/posts/springdoc-vs-springfox/", "categories": "Spring", "tags": "spring, springboot, oas3, swagger, springdoc, springfox", "date": "2021-11-21 00:00:00 +0900", "snippet": "출처 https://junho85.pe.kr/1583?category=177748" }, { "title": "[JPA] default_batch_fetch_size", "url": "/posts/default_batch_fetch_size/", "categories": "Backend, JPA", "tags": "spring, jpa", "date": "2021-11-21 00:00:00 +0900", "snippet": "JPA를 사용할 때 N+1 문제를 해결하기 위해 default_batch_fetch_size를 설정하여 in절로 여러 개를 한 번에 가져올 수 있도록 한다.하지만 실제 default_batch_fetch_size를 100으로 설정하고 30개의 데이터를 가져오려 하니 25개를 담은 in절 쿼리 1번 + 5개를 담은 in절 쿼리 한 번이 호출되었다.Statement와 PreparedStatementRDB의 경우 쿼리가 호출 될 때 아래의 3가지의 과정을 거친다.1) 쿼리 문장 분석2) 컴파일3) 실행Statement를 사용할 경우..." }, { "title": "[Java] 일급 컬렉션", "url": "/posts/%EC%9D%BC%EA%B8%89-%EC%BB%AC%EB%A0%89%EC%85%98/", "categories": "Backend, Java", "tags": "java, collection", "date": "2021-11-17 00:00:00 +0900", "snippet": "일급 컬렉셕이란?단순하게 컬렉션을 Wrapping 하여 클래스로 묶어내는 것을 말한다.예를 들어, 다음과 같은 코드를Map&amp;lt;String, String&amp;gt; map = new HashMap&amp;lt;&amp;gt;();map.put(&quot;1&quot;, &quot;A&quot;);map.put(&quot;2&quot;, &quot;B&quot;);map.put(&quot;3&quot;, &quot;C&quot;);아래와 같이 Wrapping 하는 것을 얘기한다.public class GameRank..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 벌크 연산", "url": "/posts/44%EB%B2%8C%ED%81%AC-%EC%97%B0%EC%82%B0/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-28 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.JPQL - 벌크 연산일반적인 여러 객체에 대한 업데이트나 delete문이라 생각하면 된다. 재고가 10개 미만인 모든 상품의 가격을 10% 상승하려면? JPA 변경 감지 기능으로 실행하려면 너무 많은 SQL 실행 1)재고가 10개 미만인 상품을 리스트로 조회한다. 2)상품 엔티티의 가격을 10% 증가한다. 3)트랜잭션 커밋 시점에 변경감지가 동작한다. 변경된 데이터가 100건이라면 100번의 UPDATE SQL..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] Named 쿼리", "url": "/posts/43Named-%EC%BF%BC%EB%A6%AC/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-28 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.JPQL - Named 쿼리 (정적 쿼리) 미리 정의해서 이름을 부여해두고 사용하는 JPQL 정적 쿼리 어노테이션, XML에 정의 애플리케이션 로딩 시점에 초기화 후 재사용 진짜 네임드 쿼리의 장점 애플리케이션 로딩 시점에 JPA가 SQL로 파싱해서 캐슁한다. 애플리케이션 로딩 시점에 쿼리를 검증 실행하는 시점에 SQL로 파싱하는데 문제가 있으면 오류냄 Named 쿼리 - 어노테이션..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 엔티티 직접 사용", "url": "/posts/42%EC%97%94%ED%8B%B0%ED%8B%B0-%EC%A7%81%EC%A0%91-%EC%82%AC%EC%9A%A9/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-28 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.엔티티 직접 사용 - 기본 키 값 JPQL에서 엔티티를 직접 사용하면 SQL에서 해당 엔티티의 기본 키 값을 사용 [JPQL]select count(m.id) from Member m //엔티티의 아이디를 사용select count(m) from Member m //엔티티를 직접 사용 [SQL](JPQL 둘다 같은 다음 SQL 실행)select count(m.id) as cnt from Member m 엔티티를 파라미터로 전달String jpql = “s..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 다형성 쿼리", "url": "/posts/41%EB%8B%A4%ED%98%95%EC%84%B1-%EC%BF%BC%EB%A6%AC/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-28 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.JPQL - 다형성 쿼리크게 중요하진 않은 내용이지만 보고 넘어가자.TYPE 조회 대상을 특정 자식으로 한정 예) Item 중에 Book, Movie를 조회해라 [JPQL]select i from Item iwhere type(i) IN (Book, Movie) [SQL]select i from iwhere i.DTYPE in (‘B’, ‘M’)TREAT(JPA 2.1) 자바의 타입 캐스팅과 유사 상속 구조에서 부모 타입을 특정 자식 타입으로 다룰 때..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 페치조인2 - 한계", "url": "/posts/40%ED%8E%98%EC%B9%98%EC%A1%B0%EC%9D%B82-%ED%95%9C%EA%B3%84/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-28 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.페치 조인의 특징과 한계1) 페치 조인 대상에는 별칭(alias)을 줄 수 없다. 하이버네이트는 가능, 가급적 사용X 예시String query = &quot;select distinct t from Team t join fetch t.members as m where m.age &amp;gt; 10&quot;;List&amp;lt;Team&amp;gt; result = em.createQuery(query, Team.class) .getResu..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 페치조인1 - 기본", "url": "/posts/39%ED%8E%98%EC%B9%98%EC%A1%B0%EC%9D%B81-%EA%B8%B0%EB%B3%B8/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-28 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.JPQL - 페치 조인(fetch join)실무에서 정말정말 중요함 SQL 조인 종류X JPQL에서 성능 최적화를 위해 제공하는 기능 연관된 엔티티나 컬렉션을 SQL 한 번에 함께 조회하는 기능 join fetch 명령어 사용 페치 조인 ::= [ LEFT [OUTER] | INNER ] JOIN FETCH 조인경로엔티티 페치 조인 회원을 조회하면서 연관된 팀도 함께 조회(SQL 한 번에) SQL을 보면 회원 뿐만 아니라 팀(T.*)도 함께 SELE..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 경로표현식", "url": "/posts/38%EA%B2%BD%EB%A1%9C%ED%91%9C%ED%98%84%EC%8B%9D/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-28 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.경로 표현식 .(점)을 찍어 객체 그래프를 탐색하는 것경로 표현식 용어 정리 상태 필드(state field): 단순히 값을 저장하기 위한 필드(ex: m.username) 연관 필드(association field): 연관관계를 위한 필드 단일 값 연관 필드: @ManyToOne, @OneToOne, 대상이 엔티티(ex: m.team) 컬렉션 값 연관 필드: @OneToMany, @ManyToMany, 대상이 컬렉션(ex: m.o..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] JPQL 함수", "url": "/posts/37JPQL-%ED%95%A8%EC%88%98/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-28 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.JPQL 기본 함수JPQL에서 제공하는 표준 함수이기에 데이터베이스에 관계없이 사용하면 된다. CONCATString query = &quot;select concat(&#39;a&#39;, &#39;b&#39;) from Member m&quot;;List&amp;lt;String&amp;gt; resultList = em.createQuery(query, String.class) .getResultList(); SUBSTRING TRIM ..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 조건식 (CASE 등등)", "url": "/posts/36%EC%A1%B0%EA%B1%B4%EC%8B%9D-CASE-%EB%93%B1%EB%93%B1/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-28 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.조건식 - CASE 식String query = &quot;select &quot; + &quot;case when m.age &amp;lt;= 10 then &#39;학생요금&#39; &quot; + &quot; when m.age &amp;gt;= 60 then &#39;경로요금&#39; &quot; + &quot; else &#39;일반요금&..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] JPQL 타입 표현과 기타식", "url": "/posts/35JPQL-%ED%83%80%EC%9E%85-%ED%91%9C%ED%98%84%EA%B3%BC-%EA%B8%B0%ED%83%80%EC%8B%9D/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-28 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.JPQL 타입 표현 문자: ‘HELLO’, ‘She’’s’ 숫자: 10L(Long), 10D(Double), 10F(Float) Boolean: TRUE, FALSE ENUM: jpabook.MemberType.Admin (패키지명 포함)Team team = new Team();team.setName(&quot;teamA&quot;);em.persist(team);Member member = new Member();member.setUsername(&qu..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 서브 쿼리", "url": "/posts/34%EC%84%9C%EB%B8%8C-%EC%BF%BC%EB%A6%AC/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-28 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.서브 쿼리 나이가 평균보다 많은 회원select m from Member mwhere m.age &amp;gt; (select avg(m2.age) from Member m2)위에 있는 m 대신 서브 쿼리에서 새로운 m2를 사용하면 성능이 더 잘 나온다. 한 건이라도 주문한 고객select m from Member mwhere (select count(o) from Order o where m = o.member) &amp;gt; 0위에 있는 m 을 서브 쿼..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 조인", "url": "/posts/33%EC%A1%B0%EC%9D%B8/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-28 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.조인엔티티를 중심으로 동작한다. 객체 스타일의 문법이다. 내부 조인: SELECT m FROM Member m [INNER] JOIN m.team t member있고 team이 없으면 데이터가 아예 안나옴(교집합) String query = &quot;select m from Member m inner join Team t where m.username = t.name&quot;;List&amp;lt;Member&amp;g..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 페이징", "url": "/posts/32%ED%8E%98%EC%9D%B4%EC%A7%95/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-28 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.페이징 APIOracle DB나 MSSQL같은 경우엔 페이징이 거지 같다. 쿼리를 막 rownum쓰고 그거를 order by까지 적용하려면 3depth로 거지같아진다.. 이러한 문제들을 깔끔하게 해결해준다. JPA는 페이징을 다음 두 API로 추상화 setFirstResult(int startPosition) : 조회 시작 위치(0부터 시작) setMaxResults(int maxResult) : 조회할 데이터 수 //페이징 ..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] JPQL 기본 문법과 쿼리 API", "url": "/posts/31JPQL-%EA%B8%B0%EB%B3%B8-%EB%AC%B8%EB%B2%95%EA%B3%BC-%EC%BF%BC%EB%A6%AC-API/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-28 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.JPQL(Java Persistence Query Language) - 기본 문법과 기능JQPL 소개 JPQL은 객체지향 쿼리 언어다.따라서 테이블을 대상으로 쿼리하는 것이 아니라 엔티티 객체를 대상으로 쿼리한다. JPQL은 SQL을 추상화해서 특정데이터베이스 SQL에 의존하지 않는다. JPQL은 결국 SQL로 변환된다.JPQL 문법 select m from Member as m where m.age &amp;gt; 18 엔티티와 속성은 대소문자 구분O..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 객체지향 쿼리(JPQL) 언어 소개", "url": "/posts/30%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5-%EC%BF%BC%EB%A6%AC-%EC%96%B8%EC%96%B4-%EC%86%8C%EA%B0%9C/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-28 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.목차 객체지향 쿼리 언어 소개 JPQL 기본 문법과 기능 페치 조인 경로 표현식 다형성 쿼리 엔티티 직접 사용 Named 쿼리 벌크 연산JPA는 다양한 쿼리 방법을 지원 JPQL JPA Criteria QueryDSL 네이티브 SQL (특정 DB에 맞는 쿼리를 호출할 때) JDBC API 직접 사용, MyBatis, SpringJdbcTemplate 함께 사용 Criteria랑 QueryDSL JPQL이란 표준 문법을 기반으로 한다.J..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 실전 예제6 - 값 타입 매핑", "url": "/posts/29%EC%8B%A4%EC%A0%84-%EC%98%88%EC%A0%9C6-%EA%B0%92-%ED%83%80%EC%9E%85-%EB%A7%A4%ED%95%91/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-28 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.실전 예제 - 6. 값 타입 매핑 equals() 와 hashCode() 메소드를 구현할 때 getter로 멤버변수에 접근하는게 좋다. 프록시도 안정적으로 접근할 수 있도록 @Embeddablepublic class Address { @Column(length = 10) private String city; @Column(length = 20) private String street; @Column(lengt..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 값 타입 컬렉션", "url": "/posts/28%EA%B0%92-%ED%83%80%EC%9E%85-%EC%BB%AC%EB%A0%89%EC%85%98/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-27 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.값 타입 컬렉션은 값 타입을 컬렉션에 담아서 쓰는 것을 말한다. 문제는 DB에 넣을때가 문제가 된다. 기본적으로 값 타입 컬렉션을 DB에 넣는 구조를 지원하지 않는다. 결론적으로 이러한 컬렉션들을 별도의 테이블로 뽑아야한다. (FAVORITE_FOOD 테이블, ADDRESS 테이블) 값 타입을 하나 이상 저장할 때 사용 @ElementCollection, @CollectionTable 사용 데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다. ..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 값 타입의 비교", "url": "/posts/27%EA%B0%92-%ED%83%80%EC%9E%85%EC%9D%98-%EB%B9%84%EA%B5%90/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-27 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다. 값 타입: 인스턴스가 달라도 그 안에 값이 같으면 같은 것으로 봐야 함int a = 10;int b = 10;a == b ? =&amp;gt; true!Address a = new Address(“서울시”)Address b = new Address(“서울시”)a == b ? =&amp;gt; false! (당연히 참조값이 다르므로) 동일성(identity) 비교: 인스턴스의 참조 값을 비교, == 사용 동등성(equivalence) 비교: 인스턴스의 값을..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 값 타입과 불변 객체", "url": "/posts/26%EA%B0%92-%ED%83%80%EC%9E%85%EA%B3%BC-%EB%B6%88%EB%B3%80-%EA%B0%9D%EC%B2%B4/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-27 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.값 타입은 복잡한 객체 세상을 조금이라도 단순화하려고 만든 개념이다. 따라서 값 타입은 단순하고 안전하게 다룰 수 있어야 한다.값 타입 공유 참조 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험함 공유하려면 값 타입이 아닌 엔티티로 만들어야함 부작용(side effect) 발생Address address = new Address(&quot;city&quot;, &quot;street&quot;, &quot;10&quot..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 임베디드 타입", "url": "/posts/25%EC%9E%84%EB%B2%A0%EB%94%94%EB%93%9C-%ED%83%80%EC%9E%85/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-27 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.임베디드 타입(복합 값 타입) 새로운 값 타입을 직접 정의할 수 있음 JPA는 임베디드 타입(embedded type)이라 함 주로 기본 값 타입을 모아서 만들어서 복합 값 타입이라고도 함 int, String과 같은 값 타입 추적도 안되고 변경하면 끝난다. 임베디드 타입 회원 엔티티는 이름, 근무 시작일, 근무 종료일, 주소 도시, 주소 번지, 주소 우편번호를 가진다. 근무 시작일, 종료일 묶을 수 있지 않을까..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 기본값 타입", "url": "/posts/24%EA%B8%B0%EB%B3%B8%EA%B0%92-%ED%83%80%EC%9E%85/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-27 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.목차 기본값 타입 임베디드 타입(복합 값 타입)(중요!) 값 타입과 불변 객체 값 타입의 비교 값 타입 컬렉션(중요!) 실전 예제 - 6. 값 타입 매핑JPA의 데이터 타입 분류 엔티티 타입 @Entity로 정의하는 객체 데이터가 변해도 식별자로 지속해서 추적 가능 예) 회원 엔티티의 키나 나이 값을 변경해도 식별자로 인식 가능 값 타입 int, Integer, String처럼 단순히 값..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 실전 예제5 - 연관관계 관리", "url": "/posts/23%EC%8B%A4%EC%A0%84-%EC%98%88%EC%A0%9C5-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EA%B4%80%EB%A6%AC/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-27 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.글로벌 페치 전략 설정 모든 연관관계를 지연 로딩으로 @ManyToOne, @OneToOne은 기본이 즉시 로딩이므로 지연로딩으로 변경영속성 전이 설정 Order -&amp;gt; Delivery를 영속성 전이 ALL 설정 Order -&amp;gt; OrderItem을 영속성 전이 ALL 설정" }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 영속성 전이: CASCADE", "url": "/posts/22%EC%98%81%EC%86%8D%EC%84%B1-%EC%A0%84%EC%9D%B4-CASCADE/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-27 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.영속성 전이: CASCADE 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들도 싶을 때 예: 부모 엔티티를 저장할 때 자식 엔티티도 함께 저장. 영속성 전이: 저장@OneToMany(mappedBy=&quot;parent&quot;, cascade=CascadeType.PERSIST)@Entitypublic class Parent { @Id @GeneratedValue private Long ..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 즉시 로딩과 지연 로딩", "url": "/posts/21%EC%A6%89%EC%8B%9C-%EB%A1%9C%EB%94%A9%EA%B3%BC-%EC%A7%80%EC%97%B0-%EB%A1%9C%EB%94%A9/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-27 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.Member를 조회할 때 Team도 함께 조회해야 할까?단순히 member 정보만 사용하는 비즈니스 로직 println(member.getName()) 메소드가 있다고 해보자.지연 로딩 LAZY을 사용해서 프록시로 조회@Entitypublic class Member { @Id @GeneratedValue private Long id; @Column(name = &quot;USERNAME&quot;) private String name;..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 프록시와 연관관계 관리", "url": "/posts/20%ED%94%84%EB%A1%9D%EC%8B%9C%EC%99%80-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EA%B4%80%EB%A6%AC/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-27 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.프록시Member를 조회할 때 Team도 함께 조회해야 할까?회원과 팀 함께 출력public void printUserAndTeam(String memberId) { Member member = em.find(Member.class, memberId); Team team = member.getTeam(); System.out.println(&quot;회원 이름: &quot; + member.getUsername()); System.out.p..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 실전 예제4 - 상속관계 매핑", "url": "/posts/19%EC%8B%A4%EC%A0%84-%EC%98%88%EC%A0%9C4-%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-27 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.요구사항 추가 상품의 종류는 음반, 도서, 영화가 있고 이후 더 확장될 수 있다. 모든 데이터는 등록일과 수정일이 필수다.도메인 모델도메인 모델 상세테이블 설계실습 코드BaseEntity.java@MappedSuperclasspublic abstract class BaseEntity { private String createdBy; private LocalDateTime createdDate; private String lastModified..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] Mapped Supperclass - 매핑 정보 상속", "url": "/posts/18Mapped-Supperclass-%EB%A7%A4%ED%95%91-%EC%A0%95%EB%B3%B4-%EC%83%81%EC%86%8D/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-27 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.@MappedSuperclass공통 매핑 정보가 필요할 때 사용(id, name)한다. 상속관계 매핑X 엔티티X, 테이블과 매핑X 부모 클래스를 상속 받는 자식 클래스에 매핑 정보만 제공 조회, 검색 불가(em.find(BaseEntity) 불가) 직접 생성해서 사용할 일이 없으므로 추상 클래스 권장 테이블과 관계 없고, 단순히 엔티티가 공통으로 사용하는 매핑정보를 모으는 역할 주로 등록일, 수정일, 등록자, 수정자 같은 전체 엔티티에서 공통으로 적..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 상속관계 매핑", "url": "/posts/17%EC%83%81%EC%86%8D%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-27 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.상속관계 매핑 관계형 데이터베이스는 상속 관계X 슈퍼타입 서브타입 관계라는 모델링 기법이 객체 상속과 유사 상속관계 매핑: 객체의 상속과 구조와 DB의 슈퍼타입 서브타입 관계를 매핑 슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 3가지 방법 각각 테이블로 변환 -&amp;gt; 조인 전략 통합 테이블로 변환 -&amp;gt; 단일 테이블 전략 서브타입 테이블로 변환 -&amp;gt; 구현 클래스마다 테이블 전략..." }, { "title": "[에센셜 스크럼] Chapter7 - 추정 및 속도", "url": "/posts/Chapter7-%EC%B6%94%EC%A0%95-%EB%B0%8F-%EC%86%8D%EB%8F%84/", "categories": "책, 에센셜스크럼", "tags": "agile, scrum", "date": "2021-10-26 00:00:00 +0900", "snippet": "개요제품 개발을 계획하고 관리할 때 우리는 “얼마나 많은 제품 기능을 완성 시킬 것인가?” “언제 일을 마칠 것이며 비용은 얼마나 들 것인가?” 와 같은 중요한 질문에 답을 내야 한다.스크럼에선 위 질문에 답을 내기 위해 우리가 만들고 있는 것의 크기 를 추정해야 하고 일을 할 수 있는 속도 혹은 비율 도 측정해야 한다. 이 정보를 가지고 우리는 제품 기능 목록의 크기를 팀의 속도로 나누어 가능한 예상 개발 기간을 얻을 수 있다. 크기: 각 제품 백로그 항목의 크기를 추정 후 합한 값 속도: 스프린트 기간 동안 완성된 모든..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 실전 예제3 - 다양한 연관관계 매핑", "url": "/posts/16%EC%8B%A4%EC%A0%84-%EC%98%88%EC%A0%9C3-%EB%8B%A4%EC%96%91%ED%95%9C-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-26 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.배송, 카테고리 추가 - 엔티티 주문과 배송은 1:1(@OneToOne) 상품과 카테고리는 N:M(@ManyToMany)배송, 카테고리 추가 - ERD배송, 카테고리 추가 - 엔티티 상세만약 상위 카테고리가 존재한다면 아래처럼 활용할 수 있다.@Entitypublic class Category { @Id @GeneratedValue private Long id; private String name; @ManyToOne @Joi..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 다양한 연관관계 매핑", "url": "/posts/15%EB%8B%A4%EC%96%91%ED%95%9C-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-26 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.연관관계 매핑시 고려사항 3가지 다중성 단방향, 양방향 연관관계의 주인다중성 다대일: @ManyToOne 일대다: @OneToMany 일대일: @OneToOne 다대다: @ManyToMany위의 관점이 헤깔릴땐 대칭적인 관점으로 보면 쉽다.일대일의 반대는 일대일, 다대다의 반대는 다대다일대다의 반대는 다대일, 다대일의 반대는 일대다 Note: 사실 다대다는 실무에서 쓰면 안되는 것이다.단방향, 양방향 테이블 외래 키 하나로 양쪽 ..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 실전 예제2 - 연관관계 매핑 시작", "url": "/posts/14%EC%8B%A4%EC%A0%84-%EC%98%88%EC%A0%9C2-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91-%EC%8B%9C%EC%9E%91/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-26 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.테이블 구조 테이블 구조는 이전과 같다.객체 구조 참조를 사용하도록 변경" }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 양방향 연관관계와 연관관계의 주인", "url": "/posts/13%EC%96%91%EB%B0%A9%ED%96%A5-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84%EC%99%80-%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84%EC%9D%98-%EC%A3%BC%EC%9D%B81/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-26 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.양방향 매핑 테이블 의 연관관계에는 외래키 하나로 양방향이 다 있는 것이다. (사실상 방향이란 개념 자체가 없다) Member에서 내가 속한 팀을 알고 싶으면 Member의 TEAM_ID(FK)와 TEAM의 TEAM_ID(PK)를 조인하면 됨 TEAM에서 속한 멤버들을 알고 싶으면 TEAM의 TEAM_ID(PK)와 Member의 TEAM_ID(FK)를 조인하면 됨 객체 는 양쪽으로 가려면 둘 다 레퍼런스를 가질 수 있는 필..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 연관관계 매핑 기초", "url": "/posts/12%EC%97%B0%EA%B4%80%EA%B4%80%EA%B3%84-%EB%A7%A4%ED%95%91-%EA%B8%B0%EC%B4%88/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-26 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.목표 객체와 테이블 연관관계의 차이를 이해 객체의 참조와 테이블의 외래 키를 매핑 용어 이해 방향(Direction): 단방향, 양방향 다중성(Multiplicity): 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:M) 이해 연관관계의 주인(Owner): 객체 양방향 연관관계는 관리 주인이 필요 연관관계가 필요한 이유‘객체지향 설계의 목표는 자율적인 객체들의 협력 공동체를 만드는 것이다.’ -조..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 실전 예제1 - 요구사항 분석과 기본 매핑", "url": "/posts/11%EC%8B%A4%EC%A0%84-%EC%98%88%EC%A0%9C1-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD-%EB%B6%84%EC%84%9D%EA%B3%BC-%EA%B8%B0%EB%B3%B8-%EB%A7%A4%ED%95%91/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-26 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.요구사항 분석 회원은 상품을 주문할 수 있다. 주문 시 여러 종류의 상품을 선택할 수 있다.기능 목록 회원 기능 회원등록 회원조회 상품 기능 상품등록 상품수정 상품조회 주문 기능 상품주문 주문내역조회 주문취소도메인 모델 분석 회원과 주문의 관계: 회원은 여러 번 주문할 수 있다. (일대다) 주문과 상품의 관계: 주문할 때 여러 상품을 선택할 수 있다. 반대로 같은 상품도 여러 번 주문될 수 있다. 주문상품 이라는 모델을 만들어서 다대다..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 기본키 매핑", "url": "/posts/10%EA%B8%B0%EB%B3%B8%ED%82%A4%EB%A7%A4%ED%95%91/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-26 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.기본 키 매핑 어노테이션 @Id @GeneratedValue@Entityclass Product { @Id @GeneratedValue(strategy = GenerationType.AUTO) private Long id; ...}기본 키 매핑 방법 직접 할당: @Id 만 사용 자동 생성(@GeneratedValue) IDENTITY: 데이터베이스에 위임, MYSQL SEQUENCE: 데이터베이스 시퀀스 오브젝트 사용, OR..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 필드와 컬럼 매핑", "url": "/posts/9%ED%95%84%EB%93%9C%EC%99%80-%EC%BB%AC%EB%9F%BC-%EB%A7%A4%ED%95%91/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-25 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.요구사항 추가1)회원은 일반 회원과 관리자로 구분해야 한다.2)회원 가입일과 수정일이 있어야 한다.3)회원을 설명할 수 있는 필드가 있어야 한다. 이 필드는 길이 제한이 없다.package hellojpa;import javax.persistence.*;import java.util.Date;@Entitypublic class Member { @Id private Long id; @Column(name = &quot;name&quot;) p..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 데이터베이스 스키마 자동 생성", "url": "/posts/8%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%8A%A4%ED%82%A4%EB%A7%88-%EC%9E%90%EB%8F%99-%EC%83%9D%EC%84%B1/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-25 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.데이터베이스 스키마 자동 생성 DDL을 애플리케이션 실행 시점에 자동 생성 테이블 중심 -&amp;gt; 객체 중심 데이터베이스 방언을 활용해서 데이터베이스에 맞는 적절한 DDL 생성 Oracle은 varchar2, MySQL은 varchar 이렇게 생성된 DDL은 개발 장비에서만 사용 생성된 DDL은 운영서버에서는 사용하지 않거나, 적절히 다듬은 후 사용데이터베이스 스키마 자동 생성 - 옵션hibernate.hbm2ddl.a..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 객체와 테이블 매핑", "url": "/posts/7%EA%B0%9D%EC%B2%B4%EC%99%80-%ED%85%8C%EC%9D%B4%EB%B8%94-%EB%A7%A4%ED%95%91/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-25 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.실제 객체와 RDB를 어떻게 매핑해서 쓰는지? JPA를 실무에 적용할 때 가장 중요한 부분 중 하나이다.엔티티 매핑 소개 객체와 테이블 매핑: @Entity, @Table 필드와 컬럼 매핑: @Column 기본 키 매핑: @Id 연관관계 매핑: @ManyToOne, @JoinColumn@Entity @Entity가 붙은 클래스는 JPA가 관리, 엔티티라 한다. JPA를 사용해서 테이블과 매핑할 클래스는 @Entity 필수 주의 기본 ..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 준영속 상태", "url": "/posts/6%EC%A4%80%EC%98%81%EC%86%8D-%EC%83%81%ED%83%9C/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-25 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.준영속 상태 영속 -&amp;gt; 준영속 영속 상태의 엔티티가 영속성 컨텍스트에서 분리(detached) 영속성 컨텍스트가 제공하는 기능을 사용 못함 update, dirty checking 등 … JPA 조회시 1차 캐시에 없으면 DB에서 가져와서 1차 캐시에 올린다. 1차 캐시에 올라간 상태가 영속 상태(JPA가 관리하는 상태)인데 만약 find()메서드로 조회 후 1차 캐시에 없어서 DB에서 가져온다면 해당 entity는 영..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 플러시", "url": "/posts/5%ED%94%8C%EB%9F%AC%EC%8B%9C/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-25 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.영속성 컨텍스트의 변경내용을 데이터베이스에 반영하는 것이 플러시 이다. 즉, 영속성 컨텍스트의 변경사항과 실제 DB를 맞춰주는 것이다.플러시 발생 변경 감지 수정된 엔티티 쓰기 지연 SQL 저장소에 등록 쓰기 지연 SQL 저장소의 쿼리를 DB에 전송 (등록, 수정, 삭제 쿼리) 영속성 컨텍스트를 플러시하는 방법 em.flush() - 직접 호출 트랜잭션 커밋 - 플러시 자동 호출 JPQL 쿼리 실행 - 플러시 자동 호출flus..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 영속성 컨텍스트", "url": "/posts/4%EC%98%81%EC%86%8D%EC%84%9D-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-25 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.JPA에서 가장 중요한 2가지 객체와 관게형 데이터베이스 매핑하기(Object Relational mapping) DB를 어떻게 설계하고 객체를 어떻게 설계해서 중간에 어떻게 JPA로 매핑해서 쓸건지 영속성 컨텍스트 실제 내부에서 JPA가 어떻게 동작하는지 엔티티 매니저 팩토리와 엔티티 매니저EntityManagerFactory를 통해 고객의 요청이 올때마다 EntityManager를 생성하고 내부적으로 D..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] JPA 소개", "url": "/posts/3JPA-%EC%86%8C%EA%B0%9C/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-25 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.JPA란? Java Persistence API의 준말 자바 진영의 ORM 기술 표준ORM이란? Object-relational mapping(객체 관계 매핑) 객체는 객체대로 설계 관계형 데이터베이스는 관계형 데이터베이스대로 설계 ORM 프레임워크가 중간에서 매핑 대중적인 언어에는 대부분 ORM 기술이 존재JPA는 애플리케이션과 JDBC 사이에서 동작개발자가 직접 JDBC API를 사용하는게 아닌 JPA를 사..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] SQL 중심적인 개발의 문제점", "url": "/posts/2SQL-%EC%A4%91%EC%8B%AC%EC%A0%81%EC%9D%B8-%EA%B0%9C%EB%B0%9C%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-22 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.대부분의 기업들은 객체 지향 언어(java, scala)를 사용한다. 또한 DB로는 관계형 DB를 많이 사용하고 있다. 그래서 지금 시대는 객체를 관계형 DB에 관리하는 시대이다.문제는 애플리케이션은 객체 지향 개발하면서 하는데 딱 코드를 까보면 SQL만 천지이다.결국엔 SQL 중심적인 개발이 되게 많은 문제점을 야기한다.1. 무한 반복, 지루한 코드 CRUD 쿼리 무한 반복해야됨, 테이블이 10개면 10개를 다해줘야해서 생산성이 저하되고 힘듬(객체에 필드가 ..." }, { "title": "[자바 ORM 표준 JPA 프로그래밍-기본편] 강좌 소개", "url": "/posts/1%EA%B0%95%EC%A2%8C-%EC%86%8C%EA%B0%9C/", "categories": "Backend, JPA, 인프런JPA-기본편", "tags": "java, spring, jpa", "date": "2021-10-22 00:00:00 +0900", "snippet": "본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.JPA? - Java Persistance APIJdbc -&amp;gt; MyBatis, JdbcTemplate -&amp;gt; JPA과거에는 JdbcTemplate이나 MyBatis를 통해 sql을 한땀한땀 작성하여 개발을 했으나 이는 개발 생산성이 뒤떨어진다.JPA를 사용하면 개발 생산성을 혁신 시킬 수 있고 개발 속도와 유지보수 측면에서 확연히 차이가 날 것이다.JPA 실무에서 어려운 이유! 인터넷에 있는 튜토리얼 보는 정도로는 무조건 한계가 있다. ..." }, { "title": "[에센셜 스크럼] 기능적 요구사항 vs 비기능적 요구사항", "url": "/posts/%EA%B8%B0%EB%8A%A5%EC%A0%81-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD-vs-%EB%B9%84%EA%B8%B0%EB%8A%A5%EC%A0%81-%EC%9A%94%EA%B5%AC%EC%82%AC%ED%95%AD/", "categories": "책, 에센셜스크럼", "tags": "agile, scrum", "date": "2021-10-21 00:00:00 +0900", "snippet": "기능적 요구사항 제품의 동작에 대한 요구사항(제품이 동작하는 내용에 대해 정의 한 것) Ex1. 관리자는 회원의 권한을 추가할 수 있다. Ex2. 관리자는 상품을 등록 할 수 있다. 비기능적 요구사항 제품의 속성 및 시스템의 제약사항들을 정의하는 요구사항 품질 요구사항과 제약사항으로 나눠서 볼 수 있다.품질 요구사항성능, 신뢰성, 보안성, 안정성, 가용성 이 있다. 성능: 시스템의 자원을 얼마나 효율적으로 사용하는가 예) 사용자가 통화버튼을 누르면 2초 이내에 통화 연결..." }, { "title": "[에센셜 스크럼] Chapter6 - 제품 백로그", "url": "/posts/Chapter6-%EC%A0%9C%ED%92%88-%EB%B0%B1%EB%A1%9C%EA%B7%B8/", "categories": "책, 에센셜스크럼", "tags": "agile, scrum", "date": "2021-10-19 00:00:00 +0900", "snippet": "개요 - 제품 백로그가 무엇인가?제품 백로그는 원하는 제품 기능에 대한 우선 순위 목록이다. 이는 무엇을 어떤 순서로 개발하느냐에 초점을 두고 있다. 제품 백로그는 가시성이 높은 산출물이며, 프로젝트에 참가하는 누구나 접근할 수 있다.제품 백로그 항목제품 백로그는 백로그 항목으로 구성된다. 대부분의 제품 백로그 항목은 제품 기능이다. 이는 사용자나 고객에게 실질적인 가치가 있는 기능 항목을 뜻한다. 제품 백로그는 종종 사용자 스토리로 작성된다.제품 백로그 항목으로는 아래와 같은 것들이 있을 수 있다. (Page. 115 예시)..." }, { "title": "[에센셜 스크럼] Chapter5 - 요구 사항과 사용자 스토리", "url": "/posts/Chapter5-%EC%9A%94%EA%B5%AC-%EC%82%AC%ED%95%AD%EA%B3%BC-%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%8A%A4%ED%86%A0%EB%A6%AC/", "categories": "책, 에센셜스크럼", "tags": "agile, scrum", "date": "2021-10-18 00:00:00 +0900", "snippet": "개요대화 사용점진적인 개선사용자 스토리란 무엇인가?카드대화확인세부 사항 수준좋은 스토리의 기준, INVEST독립성(Independent)독립성 기준을 적용하라 때, 목표는 모든 의존성을 없애는 것이 아니라 의존성을 최소화하는 방향으로 스토리를 작성하는 것!협상 가능성(Negotiable)협상 가능한 스토리를 작성하는 것은 대화가 필요하다는 것을 명확히해 미리 상세한 요구 문서를 만드는 것과 연관된 문제를 방지힌다!!!(즉, 기획팀과 개발팀 사이의 대화를 통한 협상으로 인해 서로 옳은 가치를 만들어내기 위해)협상 가능성이 지켜지..." }, { "title": "[React] setState의 비동기성", "url": "/posts/setState%EC%9D%98-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%84%B1/", "categories": "Frontend, React", "tags": "react, setstate", "date": "2021-10-07 00:00:00 +0900", "snippet": "리액트에서는 상태 관리를 위해 useState 훅을 통하여 state를 만들고 setState를 통해 state 값을 변화시킨다.아래 코드를 한 번 실행해보자.import React, { useState } from &quot;react&quot;;const App2: React.FC = () =&amp;gt; { const [state, setState] = useState(1); const addState = () =&amp;gt; { setState(state + 1); console.log(state); ..." }, { "title": "[React] reset css", "url": "/posts/React%EC%97%90%EC%84%9C%EC%9D%98-reset-css/", "categories": "Frontend, React", "tags": "react", "date": "2021-10-04 00:00:00 +0900", "snippet": "html로 코드를 작성하고 브라우저로 실행해보면 적용하지 않았는데도 불구하고, 자동으로 style(margin, padding 등)이 들어가게 될 것이다.웹 브라우저마다 default 값으로 스타일이 적용되어 있기 때문이다.브라우저마다의 기본 디폴트 스타일 값이 아니라 동일한 CSS 스타일을 보여주기 위해 이런 default 디폴트 값을 초기화 해주어야 한다.실제 적용 방법은 아래 출처 또는 여기를 참고하자.출처 HwanE Develop Blog https://velog.io/@eunjeong/React-Style-%EC%..." }, { "title": "[에센셜 스크럼] Chapter4 - 스프린트", "url": "/posts/Chapter4-%EC%8A%A4%ED%94%84%EB%A6%B0%ED%8A%B8/", "categories": "책, 에센셜스크럼", "tags": "agile, scrum", "date": "2021-10-03 00:00:00 +0900", "snippet": "스크럼은 최대 1개월 길이로 반복되는 주기적인 스프린트 라는 방식으로 일을 조직한다. 이 포스팅에서는 스프린트가 무엇인지에 대해 더 자세히 설명할 예정이다. 그러고나서 다음과 같은 스프린트의 몇 가지 주요 특징들에 대해 논의할 것이다. 스프린트 는 타임박스(timebox) 로 구성되어 있다. 짧거나 지속적인 기간을 가진다. 한 번 시작한 이상 바뀌어서는 안 되는 목표를 가지며, 팀이 정의 정의한 완료에 최종적으로 도달해야 한다.개요스프린트는 스크럼 프레임워크의 뼈대이다. 모든 스프린트는 타임박스 로 구성되어 있는데, 이는..." }, { "title": "[에센셜 스크럼]] Chapter3-애자일 원칙", "url": "/posts/Chapter3-%EC%95%A0%EC%9E%90%EC%9D%BC-%EC%9B%90%EC%B9%99/", "categories": "책, 에센셜스크럼", "tags": "agile, scrum", "date": "2021-09-30 00:00:00 +0900", "snippet": "개요순수한 전통적, 계획 주도적 계획법 중 하나를 흔히 폭포수(waterfall) 모델 이라고 한다.계획 주도적 프로세스는 종종 순차적 프로세스라고도 하는데, 처음부터 제품에 대한 모든 요구사항을 정의하고 이에 대해 설계를 진행하고, 그 다음 순서대로 코딩 그리고 테스팅 이렇게 순차적으로 이뤄지기 때문이다.계획 주도적인 개발은 요구사항이 명확하게 정의되어 있고 예측 가능하며 큰 변화가 없는 문제에 잘 작동한다.하지만 소프트웨어 개발에 있어서 대부분은 예측 불가능하다는 것이다. 스크럼은 이러한 불확실성 때문에 예상하기 어려운 ..." }, { "title": "[에센셜 스크럼] Chapter2 - 스크럼 프레임워크", "url": "/posts/Chapter2-%EC%8A%A4%ED%81%AC%EB%9F%BC-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC/", "categories": "책, 에센셜스크럼", "tags": "agile, scrum", "date": "2021-09-30 00:00:00 +0900", "snippet": "스크럼 개요스크럼은 고품질 제품의 생산을 보장하는 표준화된 공정이 아닌 일을 조직하고 관리하는 프레임워크이다. 스크럼은 일련의 가치, 원칙, 실천법을 바탕으로 조직에 기초를 제공하고 여기에 해당 기업 특유의 기술 개발 실천법과 스크럼을 실현하는 구체적인 접근법이 더해진다. 그 결과 조직 특유의 스크럼이 만들어진다. 즉, 스크럼은 모든 조직에 정형화된 형태로 적용해야 된다는 것이 아니란 얘기다. 조직에 맞는 스크럼 방법을 얻을 때까지 유연하게 변경 가능하다.스크럼은 정직, 개방, 용기, 존중, 집중, 믿음, 권한 분산, 협동의 ..." }, { "title": "[React] Virtual DOM", "url": "/posts/React%EC%97%90%EC%84%9C%EC%9D%98-Virtual-DOM/", "categories": "Frontend, React", "tags": "react, virtualdom", "date": "2021-09-29 00:00:00 +0900", "snippet": "virutal dom 을 알아보기에 앞서 dom이란 무엇인가? Document Object Model 의 약자 객체로 문서 구조를 표현하는 방법(html 파일로부터 브라우저 화면을 표현하는 방법) 트리 형태로 구성되며 javascript로 특정 노드의 CRUD 작업이 가능DOM 자체는 빠르더라도, 요소의 개수가 수 백개, 수천 개로 늘어날 경우에는 당연히 느려질 수 밖에 없다.DOM의 변화가 변화가 일어나면 다음과 같은 과정들이 일어나게 된다. css 재연산: DOM트리의 모든 노드들이 attach 메소드 실행, 스타일..." }, { "title": "세미콜론 자동 삽입 ASI", "url": "/posts/%EC%84%B8%EB%AF%B8%EC%BD%9C%EB%A1%A0-%EC%9E%90%EB%8F%99-%EC%82%BD%EC%9E%85-ASI/", "categories": "Frontend, Javascript", "tags": "javscript, es6, asi", "date": "2021-09-27 00:00:00 +0900", "snippet": "ASIAutomatic Semicolon Insertion(자동 세미콜론 삽입) 이란?자바스크립트 코드에서 ;(세미콜론) 이 필요한 곳인데도 불구하고, 단 하나의 ;이 누락되면 자바스크립트 프로그램은 돌아가지 않는다.ASI는 자바스크립트 프로그램의 세미콜론(;)이 누락된 곳에 엔진이 자동으로 ;을 삽입하는 것을 말한다.ASI는 새 줄(행바꿈Line Break)에만 적용된다. (어떠한 경우에도 줄 중간에 삽입되는 일은 없다)자바스크립트 파서parser는 줄 단위로 파싱을 하다가 (;가 빠져) 에러가 나면, ;을 넣어보고 타당한 ..." }, { "title": "[Javascript] 웹 스토리지(localStorage, sessionStorage)", "url": "/posts/%EC%9B%B9-%EC%8A%A4%ED%86%A0%EB%A6%AC%EC%A7%80(localStorage-sessionStorage)/", "categories": "Frontend, Javascript", "tags": "javscript, localstorage, sessionstorage", "date": "2021-09-23 00:00:00 +0900", "snippet": "자바스크립트로 웹 개발을 하다보면 아무리 간단한 애플리케이션이라도 데이터를 어딘가에 저장해야 할 일이 생긴다. 보통 이럴 때 데이터베이스(DB)서버나 클라우드(Cloud)플랫폼에 데이터를 저장하는 경우가 많을 것이다.하지만 저장해야할 데이터가 별로 중요하지 않거나,유실되도 무방할 데이터라면 서버 단에 데이터를 저장하는 것이 낭비일 수가 있다. 이때 사용되는 것이 웹 스토리지이다.클라이언트 단, 즉 브라우저 상에 데이터를 저장할 수 있는 기술이 웹 스토리지이다.로컬 스토리지 vs 세션 스토리지웹 스토리지(web storage)에..." }, { "title": "[Javascript] 가독성 좋은 코드를 위한 function에 주석달기", "url": "/posts/%EA%B0%80%EB%8F%85%EC%84%B1-%EC%A2%8B%EC%9D%80-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9C%84%ED%95%9C-function%EC%97%90-%EC%A3%BC%EC%84%9D%EB%8B%AC%EA%B8%B0/", "categories": "Frontend, Javascript", "tags": "javscript, es6, function, comment", "date": "2021-09-20 00:00:00 +0900", "snippet": "JavaScript는 type이 불명확하므로 문서화를 통해 그 상세정보를 남겨야 한다. 그러나 소스코드와 분리된 문서는 사실상 그 활용가치가 매우 떨어진다. 소스코드와 일원화된 방식으로 문서화가 되려면 주석 을 사용해야 한다. 아래는 어떤 클래스의 특정함수에 대한 주석을 통한 문서화에 대한 간단한 예시이다./** * todo 항목을 추가한다. * @param {string} todoContents todo 항목 내용 * @returns {void} */ TodoListPage.prototype.addItem = function..." }, { "title": "[Javascript] var let const 차이", "url": "/posts/var-let-const-%EC%B0%A8%EC%9D%B4/", "categories": "Frontend, Javascript", "tags": "javscript, es6, var, let, const", "date": "2021-09-20 00:00:00 +0900", "snippet": "ES6는 var 키워드의 단점을 보완하기 위해 let과 const 키워드를 도입하였다.var let const 를 아래와 같은 세 가지 기준으로 비교할 수 있다. 1)변수 값의 변환 2)변수의 유효범위 3)호이스팅1) 변수 값의 변환var를 사용하면 변수 선언의 경우 할당되는 값이 유동적으로 변경될 수 있는 단점을 가지고 있다.var name = &quot;Marcus&quot;;console.log(name);var name = &quot;Jogeonsang&quot;;console.log(name);output: Ma..." }, { "title": "[Javascript] innerText와 innerHTML 차이점", "url": "/posts/innerText%EC%99%80-innerHTML-%EC%B0%A8%EC%9D%B4%EC%A0%90/", "categories": "Frontend", "tags": "jekyll, codepen, devlog", "date": "2021-09-20 00:00:00 +0900", "snippet": "innerText와 innerHTML은 단순한 텍스트만 다룰 경우에는 차이가 없어 보인다.이 두 속성은 다루는 값이 text element인지, html element인지에 따라 차이가 난다.값 가져오기 (innerText vs innerHTML)element.innerText;element 안의 text 값들만을 가져옵니다.element.innerHTML;innerText와는 달리 innerHTML은 element 안의 HTML이나 XML을 가져옵니다.값 설정하기 (innerText vs innerHTML)element.in..." }, { "title": "[HTML] 인라인요소와 블록요소 구분하기", "url": "/posts/%EC%9D%B8%EB%9D%BC%EC%9D%B8%EC%9A%94%EC%86%8C%EC%99%80-%EB%B8%94%EB%A1%9D%EC%9A%94%EC%86%8C-%EA%B5%AC%EB%B6%84%ED%95%98%EA%B8%B0/", "categories": "Frontend, HTML", "tags": "html5, inline, block", "date": "2021-09-20 00:00:00 +0900", "snippet": "HTML 태그는 크게 블록 요소(block element)와 인라인 요소(inline-element)로 나누어 진다. 이 부분을 명확히 이해하고 있어야 CSS 를 사용하는데 어려움이 없다.각 두 요소 모두 적용되는 CSS가 별도로 존재한다.예를 들어, 블록 요소는 text-align, vertical-align 이 적용되지 않는다. 인라인 요소는 width, height 이 적용되지 않는다.블록 요소블록 요소는 모든 인라인 요소를 포함할 수 있고, 다른 블록 요소도 일부 포함 할 수 있다. 그리고 기본적으로 가로폭 전체의 ..." }, { "title": "[Frontend] jekyll블로그에 codepen 삽입하기", "url": "/posts/jekyll%EB%B8%94%EB%A1%9C%EA%B7%B8%EC%97%90-codepen-%EC%82%BD%EC%9E%85%ED%95%98%EA%B8%B0/", "categories": "Frontend, Javascript", "tags": "es6, vanilajs, innertext, innerhtml", "date": "2021-09-20 00:00:00 +0900", "snippet": "See the Pen hello by jeonyoungho (@jeonyoungho) on CodePen.출처 https://0xd00d00.github.io/2021/07/06/embedCodepen.html" }, { "title": "[PoiemaWeb] 5.33 이벤트", "url": "/posts/PoiemaWeb-Javascript-5.33-%EC%9D%B4%EB%B2%A4%ED%8A%B8/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-09 00:00:00 +0900", "snippet": "2. 이벤트 루프(Event Loop)와 동시성(Concurrency)브라우저는 단일 쓰레드(single-thread)에서 이벤트 드리븐(event-driven) 방식으로 동작한다.단일 쓰레드는 쓰레드가 하나뿐이라는 의미이며 이말은 곧 하나의 작업(task)만을 처리할 수 있다는 것을 의미한다. 하지만 실제로 동작하는 웹 애플리케이셩ㄴ은 많은 task가 동시에 처리되는 것처럼 느껴진다. 이철머 자바스크립트의 동시성(Concurrency)을 지원하는 것이 바로 이벤트 루프(Event Loop)이다.브라우저의 환경을 그림으로 표현..." }, { "title": "[PoiemaWeb] 5.32 동기식 처리 모델 vs 비동기식 처리 모델", "url": "/posts/PoiemaWeb-Javascript-5.32-%EB%8F%99%EA%B8%B0%EC%8B%9D-%EC%B2%98%EB%A6%AC-%EB%AA%A8%EB%8D%B8-vs-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%8B%9D-%EC%B2%98%EB%A6%AC-%EB%AA%A8%EB%8D%B8/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-09 00:00:00 +0900", "snippet": "출처 https://poiemaweb.com/js-async" }, { "title": "[PoiemaWeb] 5.31 문서 객체 모델(Document Object Model)", "url": "/posts/PoiemaWeb-Javascript-5.31-%EB%AC%B8%EC%84%9C-%EA%B0%9D%EC%B2%B4-%EB%AA%A8%EB%8D%B8(Document-Object-Model)/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-09 00:00:00 +0900", "snippet": "출처 https://poiemaweb.com/js-dom" }, { "title": "[PoiemaWeb] 5.30 배열 고차 함수", "url": "/posts/PoiemaWeb-Javascript-5.30-%EB%B0%B0%EC%97%B4-%EA%B3%A0%EC%B0%A8-%ED%95%A8%EC%88%98/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-09 00:00:00 +0900", "snippet": "고차 함수(Higher order function)는함수를 인자로 전달받거나 함수를 결과로 반환하는 함수를 말한다. 다시 말해, 고차 함수는 인자로 받은 함수를 필요한 시점에 호출하거나 클로저를 생성하여 반환한다. 자바스크립트의 함수는 일급 객체이므로 값처럼 인자로 전달할 수 있으며 반환할 수도 있다.// 함수를 인자로 전달받고 함수를 반환하는 고차 함수function makeCounter(predicate) { // 자유 변수. num의 상태는 유지되어야 한다. let num = 0; // 클로저. num의 상태를 유지..." }, { "title": "[PoiemaWeb] 5.29 자바스크립트 배열은 배열이 아니다", "url": "/posts/PoiemaWeb-Javascript-5.29-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EB%B0%B0%EC%97%B4%EC%9D%80-%EB%B0%B0%EC%97%B4%EC%9D%B4-%EC%95%84%EB%8B%88%EB%8B%A4/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-09 00:00:00 +0900", "snippet": "일반적으로 배열이라는 자료 구조의 개념은 동일한 크기의 메모리 공간이 빈틈없이 연속적으로 나열된 자료 구조를 말한다. 즉, 배열의 요소는 하나의 타입으로 통일되어 있으며 서로 연속적으로 인접해 있다. 이러한 배열을 밀집 배열(dense array)이라 한다.이처럼 배열의 요소는 동일한 크기를 갖으며 빈틈없이 연속적으로 이어져 있으므로 아래와 같이 인덱스를 통해 단 한번의 연산으로 임의의 요소에 접근(임의 접근(random access), 시간 복잡도 O(1))할 수 있다. 이는 매우 효율적이며 고속으로 동작한다. Note: ..." }, { "title": "[PoiemaWeb] 5.28 배열", "url": "/posts/PoiemaWeb-Javascript-5.28-%EB%B0%B0%EC%97%B4/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-09 00:00:00 +0900", "snippet": "배열(array)은 1개의 변수에 여러 개의 값을 순차적으로 저장할 때 사용한다. 자바스크립트의 배열은 객체이며 유용한 내장 메소드를 포함하고 있다.배열은 Array 생성자로 생성된 Array 타입의 객체이며 프로토타입 객체는 Array.prototype이다.1. 배열의 생성1.1 배열 리터럴0개 이상의 값을 쉼표로 구분하여 대괄호([])로 묶는다. 첫번째 값은 인덱스 ‘0’으로 읽을 수 있다. 존재하지 않는 요소에 접근하면 undefined를 반환한다.const emptyArr = [];console.log(emptyArr[..." }, { "title": "[PoiemaWeb] 5.27 String 레퍼 객체", "url": "/posts/PoiemaWeb-Javascript-5.27-String-%EB%A0%88%ED%8D%BC-%EA%B0%9D%EC%B2%B4/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-09 00:00:00 +0900", "snippet": "String 객체는 원시 타입인 문자열을 다룰 때 유용한 프로퍼티와 메소드를 제공하는 레퍼(wrapper) 객체이다. 변수 또는 객체 프로퍼티가 문자열을 값으로 가지고 있다면 String 객체의 별도 생성없이 String 객체의 프로퍼티와 메소드를 사용할 수 있다.원시 타입이 wrapper 객체의 메소드를 사용할 수 있는 이유는 원시 타입으로 프로퍼티나 메소드를 호출할 때 원시 타입과 연관된 wrapper 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 되기 때문이다.const str = &#39;Hello world!&..." }, { "title": "[PoiemaWeb] 5.26 정규표현식", "url": "/posts/PoiemaWeb-Javascript-5.26-%EC%A0%95%EA%B7%9C%ED%91%9C%ED%98%84%EC%8B%9D/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-09 00:00:00 +0900", "snippet": "1. 정규표현식(Regular Expression)정규표현식(Regular Expression)은 문자열에서 특정 내용을 찾거나 대체 또는 발췌하는데 사용한다.예를 들어 회원가입 화면에서 사용자로 부터 입력 받는 전화번호가 유효한지 체크할 필요가 있다. 이때 정규표현식을 사용하면 간단히 처리할 수 있다.const tel = &#39;0101234567팔&#39;;// 정규 표현식 리터럴const myRegExp = /^[0-9]+$/;console.log(myRegExp.test(tel)); // false반복문과 조건문을 사..." }, { "title": "[PoiemaWeb] 5.25 날짜와 시간을 위한 Date 객체", "url": "/posts/PoiemaWeb-Javascript-5.25-%EB%82%A0%EC%A7%9C%EC%99%80-%EC%8B%9C%EA%B0%84%EC%9D%84-%EC%9C%84%ED%95%9C-Date-%EA%B0%9D%EC%B2%B4/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-09 00:00:00 +0900", "snippet": "Date 객체는 날짜와 시간(년, 월, 일, 시, 분, 초, 밀리초(천분의 1초(millisecond, ms)))을 위한 메소드를 제공하는 빌트인 객체이면서 생성자 함수이다.Date 생성자 함수로 생성한 Date 객체는 내부적으로 숫자값을 갖는다. 이 값은 1970년 1월 1일 00:00(UTC)을 기점으로 현재 시간까지의 밀리초를 나타낸다.UTC(협정 세계시: Coordinated Universal Time)는 GMT(그리니치 평균시: Greenwich Mean Time)로 불리기도 하는데 UTC와 GMT는 초의 소숫점 단위..." }, { "title": "[PoiemaWeb] 5.24 수학 상수와 함수를 위한 Math객체(PoiemaWeb-Javascript)", "url": "/posts/PoiemaWeb-Javascript-5.24-%EC%88%98%ED%95%99-%EC%83%81%EC%88%98%EC%99%80-%ED%95%A8%EC%88%98%EB%A5%BC-%EC%9C%84%ED%95%9C-Math%EA%B0%9D%EC%B2%B4/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-09 00:00:00 +0900", "snippet": "Math 객체는 수학 상수와 함수를 위한 프로퍼티와 메소드를 제공하는 빌트인 객체이다. Math 객체는 생성자 함수가 아니다. 따라서 Math 객체는 정적(static) 프로퍼티와 메소드만을 제공한다.사용 빈도가 높은 프로퍼티와 메소드만을 설명한다.출처 https://poiemaweb.com/js-math" }, { "title": "[PoiemaWeb] 5.23 Number 레퍼 객체(PoiemaWeb-Javascript)", "url": "/posts/PoiemaWeb-Javascript-5.23-Number-%EB%A0%88%ED%8D%BC-%EA%B0%9D%EC%B2%B4/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-09 00:00:00 +0900", "snippet": "Number 객체는 원시 타입 number를 다룰 때 유용한 프로퍼티와 메소드를 제공하는 레퍼(wrapper) 객체이다. 변수 또는 객체의 프로퍼티가 숫자를 값으로 가지고 있다면 Number 객체의 별도 생성없이 Number 객체의 프로퍼티와 메소드를 사용할 수 있다.원시 타입이 wrapper 객체의 메소드를 사용할 수 있는 이유는 원시 타입으로 프로퍼티나 메소드를 호출할 때 원시 타입과 연관된 wrapper 객체로 일시적으로 변환되어 프로토타입 객체를 공유하게 되기 때문이다.var num = 1.5;console.log(nu..." }, { "title": "[PoiemaWeb] 5.22 전역 객체(PoiemaWeb-Javascript)", "url": "/posts/PoiemaWeb-Javascript-5.22-%EC%A0%84%EC%97%AD-%EA%B0%9D%EC%B2%B4/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-09 00:00:00 +0900", "snippet": "전역 객체(Global Object)는 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 Browser-side에서는 window, Server-side(Node.js)에서는 global 객체를 의미한다. 전역 객체는 실행 컨텍스트에 컨트롤이 들어가기 이전에 생성이 되며 constructor가 없기 때문에 new 연산자를 이용하여 새롭게 생성할 수 없다. 즉, 개발자가 전역 객체를 생성하는 것은 불가능하다. 전역 객체는 전역 스코프(Global Scope)를 갖게 된다. 전역 객체의 자식 객체를 사용할 때 전역 객체의..." }, { "title": "[PoiemaWeb] 5.21 빌트인 객체(PoiemaWeb-Javascript)", "url": "/posts/PoiemaWeb-Javascript-5.21-%EB%B9%8C%ED%8A%B8%EC%9D%B8-%EA%B0%9D%EC%B2%B4/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-09 00:00:00 +0900", "snippet": "자바스크립트의 객체는 아래와 같이 크게 3개의 객체로 분류할 수 있다.1. 네이티브 객체네이티브 객체(Native objects or Built-in objects or Global Objects)는 ECMAScript 명세에 정의된 객체를 말하며 애플리케이션 전역의 공통 기능을 제공한다. 네이티브 객체는 애플리케이션의 환경과 관계없이 언제나 사용할 수 있다.Object, String, Number, Function, Array, RegExp, Date, Math와 같은 객체 생성에 관계가 있는 함수 객체와 메소드로 구성된다...." }, { "title": "[PoiemaWeb] 5.20 객체 지향 프로래밍(PoiemaWeb-Javascript)", "url": "/posts/PoiemaWeb-Javascript-5.20-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EB%9E%98%EB%B0%8D/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-08 00:00:00 +0900", "snippet": "2.2 프로토타입 기반 언어객체 지향의 상속, 캡슐화(정보 은닉) 등의 개념은 프로토타입 체인과 클로저 등으로 구현할 수 있다. 상속 -&amp;gt; 프로토타입 체인 캡슐화(정보 은닉) -&amp;gt; 클로저4. 프로토타입 체인과 메소드의 정의프로토타입 객체는 상속할 것들이 저장되는 장소이다.아래는 더글라스 크락포드가 제안한 프로토타입 객체에 메소드를 추가하는 방식이다./** * 모든 생성자 함수의 프로토타입은 Function.prototype이다. 따라서 모든 생성자 함수는 Function.prototype.metho..." }, { "title": "[PoiemaWeb] 5.19 클로저(PoiemaWeb-Javascript)", "url": "/posts/PoiemaWeb-Javascript-5.19-%ED%81%B4%EB%A1%9C%EC%A0%80/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-08 00:00:00 +0900", "snippet": "1. 클로저(closure)의 개념function outerFunc() { var x = 10; var innerFunc = function () { console.log(x); }; return innerFunc;}/** * 함수 outerFunc를 호출하면 내부 함수 innerFunc가 반환된다. * 그리고 함수 outerFunc의 실행 컨텍스트는 소멸한다. */var inner = outerFunc();inner(); // 10위의 예제 코드처럼 자신을 포함하고 있는 외부함수보다 내부함수가 더 오래 유지되는 경우..." }, { "title": "[PoiemaWeb] 5.18 실행 컨텍스트와 자바스크립트의 동작 원리(PoiemaWeb-Javascript)", "url": "/posts/PoiemaWeb-Javascript-5.18-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EC%99%80-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-08 00:00:00 +0900", "snippet": "해당 포스팅의 내용은 ES3를 기반으로 하고 있다.1. 실행 컨텍스트실행 컨텍스트(Execution Context)는 scope, hoisting, this, function, closure 등의 동작원리를 담고 있는 자바스크립트의 핵심원리이다. 실행 컨텍스트를 바로 이해하지 못하면 코드 독해가 어려워지며 디버깅도 매우 곤란해 질 것이다.ECMAScript 스펙에 따르면 실행 컨텍스트를 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이라고 정의한다. 좀 더 쉽게 말하자면 실행 컨텍스트는 실행 가능한 코드가 실행되기 위해 ..." }, { "title": "[PoiemaWeb] 5.17 this(PoiemaWeb-Javascript)", "url": "/posts/PoiemaWeb-Javascript-5.17-this/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-08 00:00:00 +0900", "snippet": "자바스크립트의 함수는 호출될 때, 매개변수로 전달되는 인자값 이외에, arguments 객체와 this를 암묵적으로 전달 받는다.function square(number) { console.log(arguments); console.log(this); return number * number;}square(2);자바스크립트의 this는 자바에서의 this의 개념과는 다르다. 자바의 this는 객체 자기 자신을 참조하는 변수이다.하지만 자바스크립트의 경우 Java와 같이 this에 바인딩되는 객체는 한가지가 아니라 해당 함..." }, { "title": "[Javascript] 상수 및 리터럴", "url": "/posts/%EC%83%81%EC%88%98-%EB%B0%8F-%EB%A6%AC%ED%84%B0%EB%9F%B4/", "categories": "Frontend, Javascript", "tags": "javascript, es6, constant, literal", "date": "2021-09-08 00:00:00 +0900", "snippet": "프로그래밍 언어를 학습하다보면 보면 상수와 리터럴이란 단어를 자주 접할 수 있다. 이 둘의 차이는 아래와 같다.상수(constant)단 한 번만 값을 저장할 수 있는 저장공간을 뜻한다. 즉, 변하지 않는 변수를 의미하며 참조하는 메모리 값(메모리 위치)을 변경할 수 없다.final int i = 10;이라는 코드에서 변수 i엔 절대 다른 값을 다시 할당 할 수 없기에 상수가 된다.리터럴(literal)그 자체로, 존재 자체만으로 값을 의미하는 것을 뜻한다. 즉, 변수의 값이 변하지 않는 데이터(메모리 위치 안의 값)을 의미한다..." }, { "title": "[PoiemaWeb] 5.16 보다 안정적인 자바스크립트 개발 환경을 위한 Strict mode(PoiemaWeb-Javascript)", "url": "/posts/PoiemaWeb-Javascript-5.16-%EB%B3%B4%EB%8B%A4-%EC%95%88%EC%A0%95%EC%A0%81%EC%9D%B8-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B0%9C%EB%B0%9C-%ED%99%98%EA%B2%BD%EC%9D%84-%EC%9C%84%ED%95%9C-Strict-mode-d/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-07 00:00:00 +0900", "snippet": "1. strict mode란?function foo() { x = 10;}console.log(x); // ?foo 함수 내에서 선언하지 않은 변수 x에 값 10을 할당하였다. 이때 변수 x를 찾아야 x에 값을 할당할 수 있기 때문에 자바스크립트 엔진은 변수 x가 어디에서 선언되었는지 스코프 체인을 통해 검색하기 시작한다.자바스크립트 엔진은 먼저 foo 함수의 스코프에서 변수 x의 선언을 검색한다. foo 함수의 스코프에는 변수 x의 선언이 없으므로 검색에 실패할 것이고, 자바스크립트 엔진은 변수 x를 검색하기 위해 foo ..." }, { "title": "[PoiemaWeb] 5.15 스코프(PoiemaWeb-Javascript)", "url": "/posts/PoiemaWeb-Javascript-5.15-%EC%8A%A4%EC%BD%94%ED%94%84/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-07 00:00:00 +0900", "snippet": "1. 스코프란?스코프(Scope, 유효범위)는 자바 스크립트를 포함한 모든 프로그래밍 언어의 기본적인 개념으로 확실한 이해가 필요하다.스코프는 참조 대상 식별자(identifier, 변수, 함수의 이름과 같이 어떤 대상을 다른 대상과 구분하여 식별할 수 있는 유일한 이름)를 찾아내기 위한 규칙이다. 자바 스크립트는이 규칙대로 식별자를 찾는다.프로그래밍은 변수를 선언하고 값을 할당하며 변수를 참조하는 기본적인 기능을 제공하며 이것으로 프로그램의 상태를 관리할 수 있다. 변수는 전역 또는 코드 블록(if, for, while, t..." }, { "title": "[PoiemaWeb] 5.14 프로토타입(PoiemaWeb-Javascript)", "url": "/posts/PoiemaWeb-Javascript-5.14-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-07 00:00:00 +0900", "snippet": "1. 프로토타입 객체자바스크립트의 모든 객체는 자신의 부모 역할을 담당하는 객체와 연결되어 있다. 그리고 이것은 마치 객체 지향의 상속 개념과 같이 부모 객체의 프로퍼티 또는 메소드를 상속받아 사용할 수 있게 한다. 이러한 부모 객체를 Prototype(프로토타입) 객체 또는 줄여서 Prototype(프로토타입)이라 한다.객체를 생성할 때 프로토타입은 결정된다. 결정된 프로토타입 객체는 다른 임의의 객체로 변경할 수 있다. 이것은 부모 객체인 프로토타입을 동적으로 변경할 수 있다는 것을 의미한다. 이러한 특징을 활용하여 객체의..." }, { "title": "[PoiemaWeb] 5.12 함수(PoiemaWeb-Javascript)", "url": "/posts/PoiemaWeb-Javascript-5.12-%ED%95%A8%EC%88%98/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-06 19:30:00 +0900", "snippet": "2. 함수 호이스팅자바스크립트는 ES6의 let, const를 포함하여 모든 선언(var, let, const, function, function*, class)을 호이스팅(Hoisting)한다. 호이스팅이란 var 선언문이나 function 선언문 등 모든 선언문이 해당 Scope의 선두로 옮겨진 것처럼 동작하는 특성을 말한다. 즉, 자바스크립트는 모든 선언문(var, let, const, function, function*, class)이 선언되기 이전에 참조 가능하다.var res = square(5);function ..." }, { "title": "[PoiemaWeb] 5.10 객체(PoiemaWeb-Javascript)", "url": "/posts/PoiemaWeb-Javascript-5.10-%EA%B0%9D%EC%B2%B4/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-06 19:20:00 +0900", "snippet": "2. 객체 생성 방법자바와 같은 클래스 기반 객체 지향 언어는 클래스를 사전에 정의하고 필요한 시점에 new 연산자를 이용하여 인스턴스를 생성하는 방식으로 객체를 생성한다. 하지만 자바스크립트는 프로토타입 객체 지향 언어로서 클래스라는 개념이 없고 별도의 객체 생성 방법이 존재한다. Note: ECMAScript 6에서 새롭게 클래스가 도입되었다. 프로토타입 기반 프로그래밍은 클래스가 존재하지 않는 객체지향 프로그래밍 스타일이다. 클래스없이 프로토타입 체인과 클로저 등으로 객체 지향 언어의 상속, 캡슐화(정보 은닉) 등의 개..." }, { "title": "[PoiemaWeb] 5.9 타입 변환과 단축 평가(PoiemaWeb-Javascript)", "url": "/posts/PoiemaWeb-Javascript-5.9-%ED%83%80%EC%9E%85-%EB%B3%80%ED%99%98%EA%B3%BC-%EB%8B%A8%EC%B6%95-%ED%8F%89%EA%B0%80/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-06 19:10:00 +0900", "snippet": "1. 타입 변환이란?암묵적 타입 변환은 변수 값을 재할당해서 변경하는 것이 아니라 자바스크립트 엔진이 표현식을 에러없이 평가하기 위해 기존 값을 바탕으로 새로운 타입의 값을 만들어 단 한번 사용하고 버린다.5. 단축 평가논리곱 연산자 &amp;amp;&amp;amp;와 논리합 연산자 ||는 논리 평가를 결정한 피연산자의 평가 결과를 그대로 반환한다. 이를 단축 평가(Short-Circuit evaluation)라 부른다.// 논리합(||) 연산자&#39;Cat&#39; || &#39;Dog&#39; // &#39;Cat&#3..." }, { "title": "[PoiemaWeb] 5.8 제어문(PoiemaWeb-Javascript)", "url": "/posts/PoiemaWeb-Javascript-5.8-%EC%A0%9C%EC%96%B4%EB%AC%B8/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-06 19:00:00 +0900", "snippet": "4. break 문레이블 문(Label statement)이란 식별자가 붙은 문을 말한다.// foo라는 레이블 식별자가 붙은 레이블 문foo: console.log(&#39;foo&#39;);레이블 문은 프로그램의 실행 순서를 제어하기 위해 사용한다. 사실 switch 문의 case 문과 default 문도 레이블 문이다. 레이블 문을 탈출하려면 break 문에 레이블 식별자를 지정한다.// foo라는 식별자가 붙은 레이블 블록문foo: { console.log(1); break foo; // foo 레이블 블록문을 탈출..." }, { "title": "[PoiemaWeb] 5.7 연산자(PoiemaWeb-Javascript)", "url": "/posts/PoiemaWeb-Javascript-5.7-%EC%97%B0%EC%82%B0%EC%9E%90/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-06 18:50:00 +0900", "snippet": "2. 문과 표현식자바스크립트 statement 끝에 세미콜론을 안 붙여줘도 되는 이유는 자바스크립트 엔진에는 statement 끝이라고 예측되는 지점에 세미콜론을 자동으로 붙여주는 세미콜론 자동 삽입 기능(ASI, automatic semicolon insertion)이 있기 때문이다.세미콜론을 반드시 붙여야 한다는 주장이 대다수를 차지하지만 붙이지 말아야 한다 주장도 설득력이 있다. 하지만 ESLint와 같은 정적 분석 도구에서도 세미콜론 사용을 기본으로 설정하고 있고 TC39(ECMAScript 기술 위원회)도 세미콜론 사..." }, { "title": "[PoiemaWeb] 5.6 데이터 타입과 변수(PoiemaWeb-Javascript)", "url": "/posts/PoiemaWeb-Javascript-5.6-%EB%8D%B0%EC%9D%B4%ED%84%B0-%ED%83%80%EC%9E%85%EA%B3%BC-%EB%B3%80%EC%88%98/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-06 18:40:00 +0900", "snippet": "1.1.1 numberJavascript는 모든 수를 실수(일반적으로 소수를 가리킴)로 처리한다.console.log(3/2);=&amp;gt; 결과: 1.51.1.2 string문자열은 배열처럼 인덱스를 통해 접근할 수 있으며 immutable특징을 가진다.var str = &quot;string&quot;str[0] = &#39;S&#39;위의 코드 처럼 이미 생성된 문자열의 일부 문자를 변경해도 반영되지 않는다(이때 에러가 발생하지 않는다). 한 번 생성된 문자열은 read only로서 변경할 수 없다.(immutable..." }, { "title": "[PoiemaWeb] 5.4 브라우저 동작 원리(PoiemaWeb-Javascript)", "url": "/posts/PoiemaWeb-Javascript-5.4-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC/", "categories": "Frontend, PoiemaWeb, Javascript", "tags": "poiemaweb, javascript, es6", "date": "2021-09-06 18:30:00 +0900", "snippet": "자바 스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다. HTML파서는 script태그를 만나면 자바 스크립트 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어 권한을 넘긴다.제어 권한을 넘겨 받은 자바스크립트 엔진은 script 태그 내의 자바스크립트 코드 또는 script 태그의 src 어트리뷰트에 정의된 자바스크립트 파일을 로드하고 파싱하여 실행한다. 자바스크립트의 실행이 완료되면 다시 HTML 파서로 제어 권한을 넘겨서 브라우저가 중지했던 시점부터 DOM 생성을 재개한다.이처럼 브..." }, { "title": "[Css] CSS3 TIP", "url": "/posts/Css3-TIP/", "categories": "Frontend, Css", "tags": "css", "date": "2021-09-03 00:00:00 +0900", "snippet": "2021년 8월 31일1) 요소 세로 가운데 정렬할때 부모 요소의 display를 flex로 선언하고 align-items: center; 를 추가하면 된다.2) 요소 세로 가운데 정렬할때 부모 요소의 display를 flex로 선언하고 justify-content: center; 를 추가하면 된다.3) width요소의 퍼센티지 비율을 줄때 부모 요소의 기준으로 해당 퍼센티지만큼 계산된다.2021년 9월 1일1) line-height 영향 받는 것: 인라인요소, 인라인블록 요소(블록요소는 line-height로 수직 정렬할 수..." }, { "title": "[Swagger] Open API 3.0 Swagger v3 상세설정", "url": "/posts/Open-API-3.0-Swagger-v3-%EC%83%81%EC%84%B8%EC%84%A4%EC%A0%95/", "categories": "Spring", "tags": "spring, springboot, oas3, swagger", "date": "2021-09-02 00:00:00 +0900", "snippet": "※ 실습 프로젝트는 Github에서 확인 할 수 있습니다.Api문서를 쉽게 알아보기 위해선 Schemas 에 대한 설명과 들어갈 값에 대한 정보가 필요하다. 또한 api method에 대한 설명도 있어야 api구성 목록을 원활하게 식별할 수 있다.이번 포스팅에서는 Swagger v3 Annotation을 이용하여 API 문서의 설명을 구체적으로 작성하고, Java Bean Validation 을 이용하여 api 사용시 유효성 체크를 하도록 한다.1) api 그룹 설정: @TagTarget: ANNOTATION_TYPE, MET..." }, { "title": "[Swagger] Open API 3.0 그리고 Swagger v3", "url": "/posts/Open-API-3.0-Swagger-v3/", "categories": "Spring", "tags": "spring, springboot, oas3, swagger", "date": "2021-08-29 00:00:00 +0900", "snippet": "※ 실습 프로젝트는 Github에서 확인 할 수 있습니다.Swagger란?API에 대한 정보를 전달하기 위해 일일이 문서화하는 것은 매우 번거로운 작업이다. 매번 Rest API를 개발하고 수정하면서 API문서를 변경하는 것은 개발자의 생산성 또한 떨어뜨린다.Swagger는 이러한 API문서를 자동으로 생성하여 HTML로 만들어주는 오픈 소스 프레임워크이다.OAS란?Open API Specification의 약자로 RESTful API 를 기술하는 표준이다. 서비스에서 제공하는 API의 기능과 End Point를 개발자나 시스..." }, { "title": "[HTML5] 시맨틱 요소와 검색 엔진", "url": "/posts/PoiemaWeb-HTML5-%EC%8B%9C%EB%A7%A8%ED%8B%B1-%EC%9A%94%EC%86%8C%EC%99%80-%EA%B2%80%EC%83%89-%EC%97%94%EC%A7%84/", "categories": "Frontend, PoiemaWeb, Html", "tags": "poiemaweb, html5", "date": "2021-08-26 00:00:00 +0900", "snippet": "시멘틱 웹(Semantic Web)&amp;lt;font size=&quot;6&quot;&amp;gt;&amp;lt;b&amp;gt;Hello&amp;lt;/b&amp;gt;&amp;lt;/font&amp;gt;&amp;lt;h1&amp;gt;Hello&amp;lt;/h1&amp;gt;HelloHello위의 코드를 보면 1행과 2행은 브라우저에서 동일한 외형을 갖는다. 이는 h1태그의 디폴트 스타일이 1행과 같기 때문이다.그러나 1행의 요소는 의미론적으론 어떤 의미도 가지고 있지 않다. 그러나 2행의 요소는 header(제목..." }, { "title": "[Java] Stream(스트림)", "url": "/posts/Stream/", "categories": "Backend, Java", "tags": "java, stream", "date": "2021-08-16 00:00:00 +0900", "snippet": "출처 https://mangkyu.tistory.com/112 https://velog.io/@adam2/JAVA8%EC%9D%98-%EC%8A%A4%ED%8A%B8%EB%A6%BC-%EC%95%8C%EC%95%84%EB%B3%B4%EA%B8%B0 https://futurecreator.github.io/2018/08/26/java-8-streams/" }, { "title": "[Java] Exception", "url": "/posts/Exception/", "categories": "Backend, Java", "tags": "java, exception", "date": "2021-08-11 00:00:00 +0900", "snippet": "개발하는데 있어 예외 처리는 없어서는 안되는 필수불가결한 요소이다. 그러기에 관련 내용을 한 번 정리하고 싶어졌다. 예외 처리와 관련된 다양한 포스팅들이 존재하지만 여기 블로그 작성자님께서 정리한 내용이 가장 명확하였고, 거의 그대로 정리해보고자 한다.Excetpion(예외)Java에서 예외란 “우리가 예상한, 혹은 예상치도 못한 일이 발생하는 것을 미리 예견하고 안정장치를 하는 것”을 말한다.Java에서는 세 종류의 예외가 존재한다. error checked exception runtime exception 혹은 unc..." }, { "title": "[Backend] Cloud Computing, Packaged Software, IasS, PasS, SaaS", "url": "/posts/Cloud-Computing,-Packaged-Software,-IasS,-PasS,-SaaS/", "categories": "Backend", "tags": "cloud-computing, packaged-software, iaas, saas, paas, saas", "date": "2021-07-25 00:00:00 +0900", "snippet": "클라우드 컴퓨팅(Cloud Computing)이란?클라우드 컴퓨팅에 대해 다양한 정의들이 존재하지만 쉽게 정리하자면 다음과 같다. 인터넷으로 가상화된 IT 리소스를 서비스를 제공하는 것이다. 예를 들면, 일반적인 IT기업에서 서비스를 하기 위해 실제 서버 1대를 구입할 것이다. 하지만 클라우드 컴퓨팅을 사용한다면 이처럼 실제로 물리적인 서버를 구입할 필요가 없게 될 것이다.그리고 클라우드 컴퓨팅에서 가상화하여 서비스로 제공하는 대상은 서버, 플랫폼, , 스토리지, 소프트웨어 등이 존재한다. 서버: 가상화된 물리적 자원 (CP..." }, { "title": "[개발자 블로그] Spring에서 Service ServiceImpl 사용해야하는지", "url": "/posts/spring%EC%97%90%EC%84%9C-Service-ServiceImpl%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC%ED%95%98%EB%82%98/", "categories": "Spring, Spring DI", "tags": "spring, springdi", "date": "2021-07-22 00:00:00 +0900", "snippet": "스프링 코드를 보면 Service인터페이스를 두고 ServiceImpl로 이를 구현하는 경우를 자주 볼 수 있다. 이 전에 정리했던 ‘스프링 의존성 주입과 인터페이스’에 이어 다시 한 번 더 정리를 하고 싶어졌다.Service인터페이스 ServiceImpl로 나누는 이유1) Loose Coupling객체 간의 결합도를 낮추어 변화에 유연한 개발을 하기 위해서이다. 하나의 인터페이스를 구현하는 여러 구현체가 있고 기능에 따라 적절한 구현체가 들어가서 다형성을 주기 위함이다. 또 하나의 인터페이스만 바라보니 의존관계도 줄일 수 있..." }, { "title": "[개발자 블로그] JDK Dynamic Proxy와 CGLIB 차이.md", "url": "/posts/JDK-Dynamic-Proxy-CGLIB-%EC%B0%A8%EC%9D%B4/", "categories": "Spring, Spring AOP", "tags": "spring, aop, oop, aspect, proxy, cglib", "date": "2021-07-22 00:00:00 +0900", "snippet": "출처 https://gmoon92.github.io/spring/aop/2019/04/20/jdk-dynamic-proxy-and-cglib.html" }, { "title": "[개발자 블로그] Spring Security OAuth", "url": "/posts/Spring-Security-OAuth2/", "categories": "Spring", "tags": "spring, springsecurity, oauth", "date": "2021-07-13 00:00:00 +0900", "snippet": "출처 https://antdev.tistory.com/71 https://jsonobject.tistory.com/363 https://jyami.tistory.com/121" }, { "title": "[보안] 인증과 인가", "url": "/posts/Authentication-Authorization/", "categories": "Backend, Security", "tags": "authentication, authorization", "date": "2021-07-13 00:00:00 +0900", "snippet": "인증(Authentication)사용자가 누구인지 확인하는 것 ex) 건물 출입이 가능한 사람인지 확인 삼성전자 직원입니까? -&amp;gt; 정직원 바로 출입 가능 방문자 입니까? -&amp;gt; 정직원 아님. 출입증을 통해 인증해야함 인가(Authorization)사용자가 요청을 실행할 수 있는 권한 여부가 있는지 확인하는 것 ex) 출입할 수 잇는 건물 공간이 어디까지 인가? 건물 관리자 입니까? -&amp;gt; 모든 공간에 출입 가능 방문자 입니까? -&..." }, { "title": "[Backend] 서버 인증 방식의 종류", "url": "/posts/%EC%84%9C%EB%B2%84-%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D%EC%9D%98-%EC%A2%85%EB%A5%98/", "categories": "Backend", "tags": "authentication, authorization", "date": "2021-07-13 00:00:00 +0900", "snippet": "서버 인증 방식의 종류HTTP의 특징으로 stateless와 connectionless를 떠올릴 수 있다. 즉, 상태 및 접속 정보를 유지하지 않는다는 점이다. 그럼 서버에서 클라이언트를 식별하기 위해선 어떻게 해야할까?단순하게 HTTP의 헤더에 사용자의 계정 정보(Id/Password)를 넣음으로써 서버에서 식별할 수 있다. 하지만 이러한 방법은 제 3자에 의해 탈취당했을 때 개인정보가 드러나기 때문에 보안에 좋지 않은 방식이라 할 수 있다.위의 문제를 해결하기 위해서는 두 가지의 방법이 존재한다.세션 및 쿠키를 이용한 인증..." }, { "title": "[Backend] OAuth", "url": "/posts/OAuth/", "categories": "Backend, Security", "tags": "oauth, google, naver, kakao, facebook", "date": "2021-07-13 00:00:00 +0900", "snippet": "OAuth란? 특정 애플리케이션(sample.com)이 다른 애플리케이션(naver, google, facebook)의 정보에 접근할 수 있는 권한을 관리하는 오픈 스탠다드 프로토콜이다. 위키백과에서는 아래와 같이 설명하고 있다. 인터넷 사용자들이 비밀번호를 제공하지 않고 다른 웹 사이트 상의 자신들의 정보에 대해 웹사이트나 애플리케이션의 접근 권한을 부여할 수 있는 공통적인 수단으로서 사용되는 접근 위임을 위한 개방형 표준이다. OAuth가 생겨난 배경 OAuth가 나오기 이전에는 외부사이트와 ..." }, { "title": "[Backend] JWT와 OAuth의 관계", "url": "/posts/JWT%EC%99%80-OAuth%EC%9D%98-%EA%B4%80%EA%B3%84/", "categories": "Backend, Security", "tags": "jwt, oauth", "date": "2021-07-13 00:00:00 +0900", "snippet": "JWT와 OAuth를 한 번에 접하게 되면서 두 가지의 개념을 명확하게 정리하고 싶어졌다.쉽게 표현하면 JWT는 토큰의 종류이고, OAuth는 토큰을 발급하고 인증하는 오픈 스탠다드 프로토콜이다.기존의 /outh/token endpoint에 의해 발급되는 모든 토큰은 일종의 OAuth 프레임워크에 의해 관리된다고 볼 수 있다.{ &quot;token_type&quot;:&quot;bearer&quot;, &quot;access_token&quot;:&quot;eyJ0eXAiOiJKV1QiLCJh&quot;, &quot;expi..." }, { "title": "[개발자 블로그] Spring Security 개요 및 동작 과정", "url": "/posts/Spring-Security-%EA%B0%9C%EC%9A%94-%EB%B0%8F-%EB%8F%99%EC%9E%91%EA%B3%BC%EC%A0%95/", "categories": "Spring", "tags": "spring, springsecurity", "date": "2021-07-12 00:00:00 +0900", "snippet": "실습 코드Spring Security Spring은 매우 막강한 인증과 인가 권한을 가진 프레임워크이다. Spring Security는 Filter 기반으로 동작한다. Spring Security는 상당히 많은 Filter들을 기반으로 Filter체인을 구성한다.Filter기반이 아닌 Interceptor로는 불가능한가? 먼저 Filter와 Interceptor의 차이점으로는 작동 위치가 다르다. Filter는 DispatcherServlet 앞 단에서 작동하고 Interceptor는 Distpatche..." }, { "title": "[Java] String &amp; StringBuffer &amp; StringBuilder", "url": "/posts/String%EA%B3%BC-StringBuffer-%EA%B7%B8%EB%A6%AC%EA%B3%A0-StringBuilder/", "categories": "Backend, Java", "tags": "java, string, stringbuffer, stringbuilder", "date": "2021-07-11 00:00:00 +0900", "snippet": "Java에서 문자열을 다루는 대표적인 클랫스로 String, StringBuffer, StringBuilder가 있습니다. 연산이 많지 않을때는 어떤 클래스를 사용하더라도 이슈가 발생할 가능성은 거의 없지만 연산 횟수가 많아지거나 멀티쓰레드를 사용하는 경우라면 각 클래스의 특징을 이해하고 적절한 클래스를 사용해야 합니다.String vs StringBuffer, StringBuilderString과 StringBuffer/StringBuilder의 가장 큰 차이점은 String은 불변(immutable)의 속성을 갖는다는 것 ..." }, { "title": "[Java] OOP개념 및 특징", "url": "/posts/OOP%EA%B0%9C%EB%85%90-%EB%B0%8F-%ED%8A%B9%EC%A7%95/", "categories": "Backend, Java", "tags": "java, oop", "date": "2021-07-11 00:00:00 +0900", "snippet": "객체지향 프로그래밍(OOP: Object-Oriented Programming) 프로그래밍에서 필요한 데이터를 추상화 시켜 객체를 만들고, 객체들 간의 상호작용을 통해 로직을 구성하는 프로그래밍 방법론 예를 들어 C++과 Java가 있다.OOP의 장단점OOP의 장점1) 재사용성이 높다 남이 만든 클래스를 가져와서 사용할 수 있고 상속을 통해 확장해서 사용할 수도 있으므로2) 유지보수가 쉽다 캡슐화를 통해 주변 영향이 적기 때문에3) 대형 프로젝트에 적합하다. 클래스 단위로 모듈화시켜 개발할 수 있으므로 여러 사람이 개..." }, { "title": "[개발자 블로그] Logout With Spring Security", "url": "/posts/LogoutWithSpringSecurity/", "categories": "Spring", "tags": "spring, springsecurity", "date": "2021-07-01 00:00:00 +0900", "snippet": "1) Logout버튼을 누르면 /logout으로 POST방식으로 보냄. 그러면 spring에 의해 logout절차가 이뤄짐(사용자가 사용했던 쿠키 및 로그인에 관련된 정보를 제거함)2) 성공적으로 logout됐을때 /logout?logout으로 GET방식으로 리다이렉트 시켜준다.3) security-context.xml에 logout에 관련된 설정추가 logout성공시 /login에 logout이란 param을 같이 보내준다.4) 로그아웃에 대한 link나 버튼 추가 userPrincipal.name(로그인한 사용자의 이름..." }, { "title": "[개발자 블로그] Login With Spring Security", "url": "/posts/LoginWithSpringSecurity/", "categories": "Spring", "tags": "spring, springsecurity", "date": "2021-07-01 00:00:00 +0900", "snippet": "Spring Security spring security는 filter에 의해 구현됨(오고가는 request response를 가로채서 필터에서 거르는식으로 구현됨)1) filter패키지 및 filter 추가2) 관련 라이브러리 추가 config, web, core3) web.xml에 springSecurityFilterChain 등록4) web.xml에 명시했던 springSecurityFilterChain이 request를 가로채서 권한이 있는지 없는지 체크하는데 이를 위해 Autentication(인증)과 Author..." }, { "title": "[개발자 블로그] Custom Login Form With Spring Security", "url": "/posts/CustomLoginFormWithSpringSecurity/", "categories": "Spring", "tags": "spring, springsecurity", "date": "2021-07-01 00:00:00 +0900", "snippet": "1) security-context.xml에서 security탭에서 form-login추가 login-page -&amp;gt; 로그인이 필요한 경우에 /login으로 리다이렉트가 이뤄짐 authentication-failure-url -&amp;gt; 인증 실패시 /login?error로 리다이렉트가 이뤄짐2) LoginController추가3) login.jsp 추가 &amp;lt;c:url value=”/login”&amp;gt; -&amp;gt; ContextRoot가 자동적으로 들어감 csrf 토큰 추가 해줘야..." }, { "title": "[개발자 블로그] Spring Quartz", "url": "/posts/Spring-Quartz/", "categories": "Spring", "tags": "spring, quartz", "date": "2021-07-01 00:00:00 +0900", "snippet": "Spring-Quartz 주기적으로 특정 작업을 반복하여 스케줄링을 하기 위해 사용한다.(매 1시간 마다 또는 정해진 시간에 특정 프로세스를 수행)Spring을 활용한 Quartz 사용법1) Dependency추가 ※ spring-context-support는 QuartzJobBean을 상속받기 위해 추가해줘야함2) Quartz설정 파일 추가(quartz-context.xml) ※ QuartzJobBean을 상속하여 DB와 관련된 작업을 처리 할 서비스빈을 의존성 주입하기 위해 JobDetailFactoryBean에 jo..." }, { "title": "[개발자 블로그] MyBatis의 활용", "url": "/posts/MyBatis%EC%9D%98-%ED%99%9C%EC%9A%A9/", "categories": "Spring", "tags": "spring, mybatis", "date": "2021-07-01 00:00:00 +0900", "snippet": "MyBatis의 활용 #{}과 ${}의 차이 #{}: preparedStatement ${}: statement https://madplay.github.io/post/difference-between-dollar-sign-and-sharp-sign-in-mybatis &amp;lt;bind&amp;gt; 문법 외부에서 전달된 파라미터를 이용하여 변수 생성하는 엘리먼트, 동적 쿼리 변수를 생성할 때 사용한다. 형식 &amp;lt;selec..." }, { "title": "[개발자 블로그] MyBatis와 전통적인 JDBC프로그램의 비교", "url": "/posts/MyBatis%EC%99%80-%EC%A0%84%ED%86%B5%EC%A0%81%EC%9D%B8-JDBC%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EC%9D%98-%EB%B9%84%EA%B5%90/", "categories": "Spring", "tags": "spring, mybatis, jdbc", "date": "2021-07-01 00:00:00 +0900", "snippet": "MyBatis와 전통적인 JDBC프로그램의 비교 mybatis-spring이라는 라이브러리를 통해서 쉽게 연동 가능ArchitectureMyBatis설정1) 라이브러리 추가 spring-jdbc/spring-tx : 스프링에서 DB처리와 트랜잭션 처리(해당 라이브러리들은 MyBatis와 무관하게 보이지만 추가하지 않은 경우에 에러발생) mybatis/mybatis-spring : MyBatis와 스프링 연동용 라이브러리2) root-context.xml 에 SQLSessionFactory Bean등록 MyBatis에서 ..." }, { "title": "[개발자 블로그] HikariCP를 사용한 DataSource 설정", "url": "/posts/HikariCP%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%9C-DataSource-%EC%84%A4%EC%A0%95/", "categories": "Spring", "tags": "spring, hikaricp, datasource", "date": "2021-07-01 00:00:00 +0900", "snippet": "pom.xml에 HikariCP를 추가 pom.xml2) root-context.xml or RootConfig클래스 설정 root-context.xml RootConfig.java 3) Junit Test DataSourceTests.java" }, { "title": "[개발자 블로그] Spring Data Validation", "url": "/posts/Data-Validation/", "categories": "Spring", "tags": "spring, datavalidation", "date": "2021-07-01 00:00:00 +0900", "snippet": "1) pom.xml에 hibernate validator 라이브러리 추가2) Model에 제약조건 및 에러메시지 정의3) controller에 @Valid어노테이션 및 BindingResult객체 추가4) View에 에러메시지 출력 BindingResult객체도 model에 들어가므로 이 객체를 이용해 view에 출력 구현 5) 예시ControllerModelJSP" }, { "title": "[개발자 블로그] Spring Data Buffering", "url": "/posts/Data-Buffering/", "categories": "Spring", "tags": "spring, databuffering", "date": "2021-07-01 00:00:00 +0900", "snippet": "1) Spring form tag를 사용하여 Data Buffering구현 사용자가 열심히 form을 작성했는데 error발생시 처음부터 다시 다 작성하기에는 너무 수고 많이 들기에 데이터를 다시 input테그에 넣어줌2) spring의 form tag로 변경 modelAttribute에 있는 값으로 나중에 Buffering이 구현됨 name을 path로 변경3) 예시4) TIP View에서 Model에 있는 객체를 가져와서 Buffering 시켜주는 구조 따라서 form을 보여주는 컨트롤러에서 빈 ..." }, { "title": "[개발자 블로그] Spring Dependency Injection Test", "url": "/posts/Dependency-Injection-Test/", "categories": "Spring, Spring DI", "tags": "spring, springdi", "date": "2021-07-01 00:00:00 +0900", "snippet": "1) pom.xml 에 spring-test, lombok, log4j 라이브러리 추가(Log4j는 1.2.15로 설정되어 있으므로 1.2.17버전을 추가하고 기존라이브러리는 삭제)2) 기존 junit라이브러리 버전 4.12로 변경3) Chef 클래스 및 Restaurant클래스 작성4) xml 방식 -&amp;gt;root-context.xml , java 방식 -&amp;gt; RootConfig클래스 를 통하여 Bean설정5) Junit 테스트 설정 pom.xml의 junit과 spring-test의 test를 지워야 ..." }, { "title": "[개발자 블로그] Spring Boot 실습", "url": "/posts/SpringBoot%EC%8B%A4%EC%8A%B5/", "categories": "Spring, SpringBoot", "tags": "spring, springboot", "date": "2021-07-01 00:00:00 +0900", "snippet": "1) 프로젝트 생성2) 프로젝트 구조 src/main/java -&amp;gt; java코드가 들어가는 부분 src/main/resources static -&amp;gt; css, javascript, 이미지와 같은 정적인 파일들 templates -&amp;gt; html파일 application.properties -&amp;gt; 설정 파일 jar로 패키징할 경우 /src/main/webapp을 사용하지 마라3) pom.xml 아래를 꼭 넣어줘야함 Spring Boot Maven Pl..." }, { "title": "[개발자 블로그] Spring Boot 개요", "url": "/posts/SpringBoot%EA%B0%9C%EB%85%90/", "categories": "Spring, SpringBoot", "tags": "spring, springboot", "date": "2021-07-01 00:00:00 +0900", "snippet": "Spring Boot 생산성 높은 코드란? Cost -&amp;gt; 비용을 줄여 줄 수 있음 Time to Market (Perfection vs Done) -&amp;gt;덜 완전하더라도 적시에 출시하는게 중요하다 Spring MVC -&amp;gt; Spring Boot 스프링을 사용하는 것 보단 좀 더 생산성을 높여 주기 위해 1) 수동적인 설정 부분들을 줄여줄 수 있다. 2) dependency 충돌 해결을 도와줄 수 있다. 3) 내장..." }, { "title": "[개발자 블로그] Logging 실습", "url": "/posts/Logging%EC%8B%A4%EC%8A%B5/", "categories": "Spring, Logging", "tags": "spring, logging, slf4j, log4j, logback, log4j2", "date": "2021-07-01 00:00:00 +0900", "snippet": "1) 기본 pom.xml의 기본구조 jcl-over-slf4j : 스프링이나 다양한 라이브러리들이 jcl을 사용하기 때문에 SLF4J로 통합하기 위해서 추가하는 라이브러리 (중간다리역할)2) logback으로 migration2-1) pom.xml에 라이브러리 추가2-2) log4j.xml에 삭제 후 logback.xml파일 추가 및 설정2-3) logback.xml설정 확인 Run -&amp;gt; Run configurations logback의 디버그 기능을 활성화 시켜서 실행 2-4) run o..." }, { "title": "[개발자 블로그] Logging 개요", "url": "/posts/Logging%EA%B0%9C%EC%9A%94/", "categories": "Spring, Logging", "tags": "spring, logging, slf4j, log4j, logback, log4j2", "date": "2021-07-01 00:00:00 +0900", "snippet": "Logging 애플리케이션 실행을 추적하기 위해 콘솔, 파일, DB와 같은 어딘가에 메시지를 기록하는 것이다. 일반적으로 디버깅이나 사용자의 상호작용을 기록하기 위해 사용한다.Logging (vs. debugger)장점 애플리케이션의 정확한 수행 상태를 파악 할 수 있다. 코드에 로깅하는 코드만 삽입 되어있다면 사용자의 개입이 필요 없다. 영구적인 매체에 저장 할 수 있다. 로깅 프레임워크는 간단하고 배우기 쉽고 사용하기 쉽다.단점 기록을 해야되기 때문에 느려질 수 있다. 너무 로깅 메시지가 많이 나타나 장황해 ..." }, { "title": "[개발자 블로그] Log4j &amp; Logback &amp; Log4j2의 차이", "url": "/posts/Log4j%EC%99%80-Logback%EA%B3%BC-Log4j2%EC%9D%98-%EC%B0%A8%EC%9D%B4/", "categories": "Spring, Logging", "tags": "spring, logging, slf4j, log4j, logback, log4j2", "date": "2021-07-01 00:00:00 +0900", "snippet": "Log4j&amp;amp;Logback&amp;amp;Log4j2의차이log4j 콘솔로 출력하는 stdout 외에도 파일 출력도 제공한다. 하지만 2015년에 개발이 중단되었기 때문에 기존 시스템이 아니라면 사용할 이유가 없다.logback log4j2 전에 개발된 로깅프로그램으로 log4j에서 향상된 성능과 필터링 옵션을 제공한다. slf4j도 지원한다. 그리고 자동 리로드도 가능하다.log4j2 logback과 동일하게 자동 리로드 기능과 필터리 기능을 제공한다. Log4j 및 logback과 차이점은 Apach..." }, { "title": "[개발자 블로그] Spring welcome-file-list", "url": "/posts/spring-configuration-Welcome-file-list/", "categories": "Spring, Configuration", "tags": "spring, welcome-file-list", "date": "2021-07-01 00:00:00 +0900", "snippet": "welcome-file-list 서버의 루트(/)경로로 request가 들어올 때 띄워주는 파일을 지정 예시 다음과 같이 web.xml에 설정이 되어있을때 루트(/) 경로로 request가 들어온다면 main1.jsp를 띄워주게 된다. 만약 main1.jsp를 찾이 못한다면 그 다음 등록되 있는 main2.jsp를 띄워준다.출처 https://admm.tistory.com/82" }, { "title": "[개발자 블로그] MyBatis TypeHandlers", "url": "/posts/spring-configuration-Typehandlers/", "categories": "Spring, Configuration", "tags": "spring, typehandlers", "date": "2021-07-01 00:00:00 +0900", "snippet": "TypeHandlers 마이바티스가 PreparedStatement에 파라미터를 설정하고 ResultSet에서 값을 가져올때마다 TypeHandler는 적절한 자바 타입의 값을 가져오기 위해 사용&amp;lt;!-- java.sql.Timestamp 를 java.util.Date 형으로 반환 --&amp;gt; &amp;lt;typeHandlers&amp;gt; &amp;lt;typeHandler javaType=&quot;java.sql.Timestamp&quot; handler=&quot;org.apache.ibatis...." }, { "title": "[개발자 블로그] Spring Transaction", "url": "/posts/spring-configuration-Transaction/", "categories": "Spring, Configuration", "tags": "spring, transaction", "date": "2021-07-01 00:00:00 +0900", "snippet": "Spring 트랜잭션 처리 서비스단 비즈니스 로직에서의 트랜잭션 처리는 굉장히 중요하다. 이를 처리하기 위한 트랜잭션은 두 가지 설정 방법이 존재한다.1) Annotation을 이용한 설정 context에 다음과 같이 설정&amp;lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&amp;gt; 트랜잭션을 적용할 클래스, 인터페이스, 메소드에 @Transactional 어노테이션을 선언public interface MemberServi..." }, { "title": "[개발자 블로그] SimpleMappingExceptionResolver", "url": "/posts/spring-configuration-SimpleMappingExceptionResolver/", "categories": "Spring, Configuration", "tags": "spring, simplemappingexceptionresolver", "date": "2021-07-01 00:00:00 +0900", "snippet": "SimpleMappingExceptionResolver Spring MVC에서 Controller단에 발생한 Exception의 종류에 따라 에러 처리 뷰로 이동 sample-servlet.xml&amp;lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&amp;gt; &amp;lt;property name=&quot;defaultErrorView&quot; value=&quot;exception/C..." }, { "title": "[개발자 블로그] spring session configuration", "url": "/posts/spring-configuration-Session/", "categories": "Spring, Configuration", "tags": "spring, quartz", "date": "2021-07-01 00:00:00 +0900", "snippet": "session설정 세션: 웹 서버쪽의 웹 컨테이너에 상태를 유지하기 위한 정보 web.xml에 세션 유지 시간 지정 (단위: 분) 디폴트는 30분Spring Security 동시 세션 제어 session timeout만료 후에도 session이 제거되지 않는 현상을 해결 SessionDestroyedEvent 이벤트를 발생시켜주는 Event Publisher인 스프링에서 제공하는 HttpSessionEventPublisher를 listener로 다음과 같이 web.xml에 등록 HttpSessionEven..." }, { "title": "[개발자 블로그] spring quartz configuration", "url": "/posts/spring-configuration-Quartz/", "categories": "Spring, Configuration", "tags": "spring, quartz", "date": "2021-07-01 00:00:00 +0900", "snippet": "spring quartz configuration 주기적으로 작업이나 배치작업을 하기 위한 스케줄러기능을 위해서 Quartz라이브러리를 사용함 quartz를 통한 주기적인 작업을 실행하기 위해선 trigger와 job이 필요함 trigger는 쉽게 말하면 작업을 실행할 시간 단위고 job은 실제로 수행할 작업을 뜻함 다음과 같이 xml설정(scheduler.xml)이 필요하며 java 설정도 가능함&amp;lt;!-- job 설정 --&amp;gt;&amp;lt;bean id=&quot;testJob&quot; clas..." }, { "title": "[개발자 블로그] MessageSource", "url": "/posts/spring-configuration-MessageSource/", "categories": "Spring, Configuration", "tags": "spring, messagesource", "date": "2021-07-01 00:00:00 +0900", "snippet": "다국어 처리를 위한 MessageSource ‘messageSource’가 이름인 빈 객체 정의&amp;lt;bean id=&quot;messageSource&quot; class=&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;&amp;gt; &amp;lt;property name=&quot;basename&quot;&amp;gt; &amp;lt;value&amp;gt;message.label&amp;lt;/val..." }, { "title": "[개발자 블로그] Log4j location 설정", "url": "/posts/spring-configuration-Log4j/", "categories": "Spring, Configuration", "tags": "spring, log4j", "date": "2021-07-01 00:00:00 +0900", "snippet": "log4j location 설정 log4j.xml 또는 log4j.properties파일은 classes폴더에 있으면, 자동으로 읽어오지만 굳이 classes가 아닌 다른 곳에 위치하고 싶은 경우는 web.xml에 Log4jConfigListener를 등록하여 사용한다. 예시출처 https://regexr.tistory.com/15" }, { "title": "[개발자 블로그] Import", "url": "/posts/spring-configuration-Import/", "categories": "Spring, Configuration", "tags": "spring, import", "date": "2021-07-01 00:00:00 +0900", "snippet": "Import spring-context.xml에서 다른 context.xml을 import하여 등록하고 싶을 경우 다음과 같이 설정한다.&amp;lt;import resource=&quot;spring/datasource.xml&quot;/&amp;gt;&amp;lt;import resource=&quot;spring/mybatis.xml&quot;/&amp;gt;출처 https://cheershennah.tistory.com/77" }, { "title": "[개발자 블로그] HttpMessageConverters", "url": "/posts/spring-configuration-HttpMessageConverters/", "categories": "Spring, Configuration", "tags": "spring, httpmessageconverters", "date": "2021-07-01 00:00:00 +0900", "snippet": "HttpMessageConverters 컨트롤러에서 넘어온 데이터(JSON 같은)를 messageConverter로 사용하기 위해 사용&amp;lt;mvc:annotation-driven&amp;gt; &amp;lt;!--&amp;lt;mvc:message-converters&amp;gt;--&amp;gt; &amp;lt;!--&amp;lt;bean class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&amp;..." }, { "title": "[개발자 블로그] DispathcerServlet &amp; ContextLoaderListener", "url": "/posts/spring-configuration-DispatcherServlet-ContextLoaderListener/", "categories": "Spring, Configuration", "tags": "spring, dispatcherservlet, contextloaderlistener", "date": "2021-07-01 00:00:00 +0900", "snippet": "DispathcerServlet &amp;amp; ContextLoaderListener1) DispatcherServlet 해당 애플리케이션으로 들어오는 요청을 모두 처리 사용자 URL 요청 -&amp;gt; DispatcherServlet (url-pattern을 통해 인식)-&amp;gt; HandlerMapping -&amp;gt; Controller(Servlet) -&amp;gt; ViewResolver -&amp;gt; View -&amp;gt; DispatcherServlet -&amp;gt..." }, { "title": "[개발자 블로그] Spring BasicDataSource configuration", "url": "/posts/spring-configuration-Datasource/", "categories": "Spring, Configuration", "tags": "spring, datasource", "date": "2021-07-01 00:00:00 +0900", "snippet": "BasicDataSource&amp;lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp2.BasicDataSource&quot; destroy-method=&quot;close&quot;&amp;gt; &amp;lt;property name=&quot;driverClassName&quot; value=&quot;${jdbc.driver}&quot; /&amp;gt; &amp;lt;property name=&quot;url&quot; value=&quot;..." }, { "title": "[개발자 블로그] Spring Component-Scan configuration", "url": "/posts/spring-configuration-ComponentScan/", "categories": "Spring, Configuration", "tags": "spring, component-scan", "date": "2021-07-01 00:00:00 +0900", "snippet": "Component-Scan base-package에 지정된 패키지를 풀스캔하여 bean으로 등록&amp;lt;context:component-scan base-package=&quot;com.esum.web&quot; use-default-filters=&quot;false&quot;&amp;gt; &amp;lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.sterotype.Controller&quot; /&amp..." }, { "title": "[개발자 블로그] Spring classpath configuration", "url": "/posts/spring-configuration-Classpath/", "categories": "Spring, Configuration", "tags": "spring, classpath", "date": "2021-07-01 00:00:00 +0900", "snippet": "Spring의 classpath란? spring의 web.xml설정 중 classpath를 통해 파일 위치를 설정할 수 있다. 이클립스의 프로젝트 우클릭 =&amp;gt; build path =&amp;gt; configure build path =&amp;gt; 가장 왼쪽의 soucre메뉴를 클릭하면 classpath를 확인 할 수 있다. root-context.xml과 servlet-context.xml을 해당 경로에 위치 시켜두고 web.xml 설정을 다음과 같이 바꾸면 정상적으로 해당 파일들..." }, { "title": "[개발자 블로그] MyBatis Settings", "url": "/posts/mybatis-settings/", "categories": "Spring, Configuration", "tags": "spring, mybatis, settings", "date": "2021-07-01 00:00:00 +0900", "snippet": "MyBatis Settings&amp;lt;settings&amp;gt; &amp;lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot; /&amp;gt; &amp;lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;false&quot; /&amp;gt; &amp;lt;setting name=&quot;multipleResultSetsEnabled&quot; value=&quot;true&quot; /&amp..." }, { "title": "[개발자 블로그] MyBatis TypeAlias", "url": "/posts/mybatis-alias/", "categories": "Spring, Configuration", "tags": "spring, mybatis, typealias", "date": "2021-07-01 00:00:00 +0900", "snippet": "TypeAlias 설정 TypeAlias는 자바타입에 대한 간단하고 짧은 이름이며 XML설정에만 관계된다. 이를 통해 클래스 풀네임 대신 지정한 alias로 대신 명시해줄수 있다. 클래스 별로 설정&amp;lt;typeAliases&amp;gt; &amp;lt;typeAlias type=&quot;com.example.vo.MemberVO&quot; alias=&quot;MemberVO&quot; /&amp;gt; &amp;lt;typeAlias type=&quot;com.example.vo.SampleVO&quot; al..." }, { "title": "[Apache Tiles] Programming Tiles Pages", "url": "/posts/Programming-Tiles-Pages/", "categories": "Spring", "tags": "spring, apachetiles, templateengine", "date": "2021-07-01 00:00:00 +0900", "snippet": "Programming Tiles Pages1) pom.xml에 라이브러리 추가2) Spring 설정 이제 컨트롤러에서 view의 이름을 리턴하는 대신 definition의 이름 리턴3) /tiles-def/tiles.xml property작성 및 /tiles/menu.jsp, footer.jsp, template.jsp 생성 참고 자료: https://tiles.apache.org/framework/tutorial/basic/pages.html4) 추가 definition 정의5) layout.jsp작성6) home.jsp..." }, { "title": "[Apache Tiles] Apache Tiles", "url": "/posts/Apache-Tiles/", "categories": "Spring", "tags": "spring, apachetiles, templateengine", "date": "2021-07-01 00:00:00 +0900", "snippet": "Apache Tiles란? 중복된 코드를 제거하기 위한 Apache에서 제공하는 오픈소스 자바 어플리케이션을 위한 무료 오픈 소스 templating framework MVC구조와 함께 할 수 있는 쉽고 가장 우아한 복잡한 웹사이트를 위한 방법 runtime시에 page조각들을 구성해서 하나의 완성된 페이지를 내게됨 전체 application이 일관성 있는 look and feel을 가질 수 있음Apache Tiles의 필요성 웹사이트가 500개 이상의 동적,정적 뷰가 존재 할시 Tiles프레임워크를 사용 할 수 있..." }, { "title": "[Network] HTTP와 HTTPS의 차이", "url": "/posts/HTTP%EC%99%80HTTPS%EC%9D%98%EC%B0%A8%EC%9D%B4/", "categories": "CS, Network", "tags": "network, http, https", "date": "2021-07-01 00:00:00 +0900", "snippet": "HTTP와 HTTPS의 차이HTTP(Hyper Text Transfer Protocol) HTTP의 개요 서버/클라이언트 모델을 따라 데이터를 주고 받기 위한 프로토콜이다. 즉, HTTP는 인터넷에서 하이퍼텍스트를 교환하기 위한 통신 규약으로, 80번 포트를 사용한다. HTTP의 구조 애플리케이션 레벨의 프로토콜로 TCP/IP 위에서 작동한다. HTTP는 상태를 가지고 있는 읺는 Stateless 프로토콜이며 Method, Path, Version, Headers..." }, { "title": "[MSA] Spring Cloud 개요", "url": "/posts/Spring-Cloud-%EA%B0%9C%EC%9A%94/", "categories": "Backend, MSA", "tags": "msa, microservicearchitecture, springcloud", "date": "2021-07-01 00:00:00 +0900", "snippet": "Spring Cloud란? 마이크로서비스의 개발, 배포, 운영에 필요한 아키텍처를 쉽게 구성할 수 있도록 지원하는 Spring Boot기반의 프레임워크 즉, MSA구성을 지원하는 Springboot기반의 프레임워크이다.Spring Cloud의 핵심 ComponentSpring cloud 컴포넌트 메뉴얼 Spring cloud는 Spring community인 spring.io에서 오픈소스 프로젝트로 관리되고 있다. http://spring.io 를 들어가셔서 Projects &amp;gt; Spring Cloud에서 자..." }, { "title": "Kafka 컨슈머 Lag", "url": "/posts/Kafka-%EC%BB%A8%EC%8A%88%EB%A8%B8-Lag/", "categories": "Backend, Kafka", "tags": "kafka, lag, burrow", "date": "2021-07-01 00:00:00 +0900", "snippet": "카프카 컨슈머 Lag이란? 운영함에 있어 아주 중요한 모니터링 지표 중 하나 만약 프로듀서가 데이터를 넣는 속도보다 컨슈머가 가져가는 속도보다 빠르게 된다면? 프로듀서가 넣은 데이터의 오프셋, 컨슈머가 가져간 데이터의 오프셋간의 차이가 발생함, 이를 lag이라함 이 lag의 숫자를 통해 현재 해당 토픽에 대한 파이프라인으로 연계되어 있어는 프로듀서와 컨슈머의 상태를 유추 가능 Topic에 여러 파티션이 존재하게 된다면 lag이 여러 개 존재하게 될 수도 있음 만약 컨슈머..." }, { "title": "[JPA] Spring Data JPA 개요", "url": "/posts/SpringDataJPA%EA%B0%9C%EC%9A%94/", "categories": "Backend, JPA", "tags": "spring, jpa, springdatajpa", "date": "2021-07-01 00:00:00 +0900", "snippet": "Spring Data JPA JPA를 사용해서 관계형 DB와 쉽게 연동하기 위한 Spring에서 제공하는 Spring ORM Module중 하나 Spring에서 CRUD 구현체를 제공 이를 통해 boiler-pate DAO코드를 최소화 entity type과 primary key의 정보만 넣어주면 자동으로 dao클래스를 생성해줌 CrudRepository 클래스를 상속받아 추가적인 메소드만 구현해주면 된다. Spring Data JPA에서 제공하는 3가지 인터페이스1) ..." }, { "title": "[JPA] QueryDSL", "url": "/posts/QueryDSL/", "categories": "Backend, JPA", "tags": "spring, jpa, querydsl", "date": "2021-07-01 00:00:00 +0900", "snippet": "※ 실습 프로젝트는 Github에서 확인 할 수 있습니다.QueryDSL이란?Querydsl 정적 타입을 이용해서 SQL과 같은 쿼리를 생성할 수 있도록 해 주는 프레임워크다. 문자열로 작성하거나 XML 파일에 쿼리를 작성하는 대신, Querydsl이 제공하는 플루언트(Fluent) API를 이용해서 쿼리를 생성할 수 있다.QueryDSL를 사용해야 하는 이유Querydsl은 타입에 안전한 방식(type-safe)으로 HQL 쿼리를 실행하기 위한 목적으로 만들어졌다.try { tx = session.beginTra..." }, { "title": "[JPA] JPA N+1 문제", "url": "/posts/N+1%EB%AC%B8%EC%A0%9C/", "categories": "Backend, JPA", "tags": "spring, jpa, hibernate, multiplebagfetchexception", "date": "2021-07-01 00:00:00 +0900", "snippet": "N+1문제 JPA를 사용하면 자주 직면하게 되는 문제이다. 예를 들어, 아래와 같은 연관 관계를 가진 Entity가 있다고 가정해보자 구체적인 코드는 아래와 같고 ORM은 spring-data-jpa를 사용한다. Academy.java package com.example.domain; import lombok.Builder; import lombok.Getter; import lombok.NoArgsConstructor; import javax.persistence.*; ..." }, { "title": "[JPA] MultipleBagFetchException", "url": "/posts/MultipleBagFetchException/", "categories": "Backend, JPA", "tags": "spring, jpa, hibernate, multiplebagfetchexception", "date": "2021-07-01 00:00:00 +0900", "snippet": "MultipleBagFetchException JPA의 N+1문제에 대한 해결책으로 Fetch Join을 사용하다보면 자주 만나는 문제가 있다. 바로 MultipleBagFetchException이다. 이 문제는 2개 이상의 OneToMany 자식 테이블에 Fetch Join을 선언햇을때 발생한다. OneToOne, ManyToOne과 같이 단일 관계의 자식 테이블에는 Fetch Join을 써도 된다. 이 문제에 대한 해결책으로는 보통 2가지를 언급한다. 자식 테이블 하나에만 F..." }, { "title": "[JPA] JPA 양방향 Entity 무한재귀 문제", "url": "/posts/JPA-%EC%96%91%EB%B0%A9%ED%96%A5-Entity-%EB%AC%B4%ED%95%9C%EC%9E%AC%EA%B7%80-%EB%AC%B8%EC%A0%9C/", "categories": "Backend, JPA", "tags": "spring, jpa", "date": "2021-07-01 00:00:00 +0900", "snippet": "JPA 양방향 Entity 무한재귀 문제 @JsonIgnoreProperties 어노테이션으로 무시할 속성 지정출처 https://thxwelchs.github.io/JPA%20%EC%96%91%EB%B0%A9%ED%96%A5%20Entity%20%EB%AC%B4%ED%95%9C%20%EC%9E%AC%EA%B7%80%20%EB%AC%B8%EC%A0%9C%20%ED%95%B4%EA%B2%B0/" }, { "title": "[JPA] JPA vs Hibernate", "url": "/posts/JPA-vs-Hibernate/", "categories": "Backend, JPA", "tags": "spring, jpa, hibernate", "date": "2021-07-01 00:00:00 +0900", "snippet": "JPA vs Hibernate JPA(Java Persistence API): 구현물이 없는 인터페이스 Hibernate: JPA의 구현체 JPA만 가지고는 프로그래밍할 순 없고 Hibernate, EclipseLink, DataNucleus와 같은 구현체를 가지고 사용해야한다. SessionFactory(Hibernate): JPA에 정의된 EntityManager Factory를 상속 받은 인터페이스이고 이를 실제 구현한게 SessionFactoryImplementation 클래스 Session(Hibe..." }, { "title": "[JPA] Hibernate", "url": "/posts/Hibernate%EA%B0%9C%EC%9A%94/", "categories": "Backend, JPA", "tags": "spring, hibernate", "date": "2021-07-01 00:00:00 +0900", "snippet": "ORM Framework (Object Relational Mapping) Object Persistence 를 위한 프레임워크 객체와 테이블 사이에는 mismatch가 발생한다. 이를 위해 mapping시켜주는 프레임워크DB에 데이터 persist를 위한 3가지 방법1) JDBC2) Spring JDBC3) Hibernate (ORM Framework)ORM libraries1) DB의 데이터 구조와 자바의 객체 모델 간의 차이를 줄여준다.2) 개발자는 객체 모델을 사용하여 프로그래밍을 하는데 집중 할 수 있다!3) SQ..." }, { "title": "[JPA] Hibernate With Spring", "url": "/posts/HibernateWithSpring%EA%B0%9C%EC%9A%94/", "categories": "Backend, JPA", "tags": "spring, hibernate", "date": "2021-07-01 00:00:00 +0900", "snippet": "spring과 hibernate 연동을 위한 4가지 단계1. spring과 hibernate 연동을 위한 메이븐 디펜던시 설정(pom.xml)&amp;lt;!– Spring에서 ORM을 지원하기 위해 디펜던시 --&amp;gt;&amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;org.springframework&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-orm&amp;lt;/artifactId&amp;gt; &amp;lt;v..." }, { "title": "[JPA] JPA Entity Relationships", "url": "/posts/Entity-Relationships%EA%B0%9C%EC%9A%94/", "categories": "Backend, JPA", "tags": "spring, jpa, entityrelationships", "date": "2021-07-01 00:00:00 +0900", "snippet": "Entity Relationships 총 4가지 타입이 존재 1) @OneToOne 2) @OneToMany, @ManyToOne 3) @ManyToMany 총 2가지 방향성이 존재 1) bidirectional(양방향) 2) unidirectional(단방향) Entity Relation 속성1) Cascading: 연관된 개체에 같은 연산을 적용할 것인지의 여부 CascadeType: ALL, PERSIST, MERGE, REMOVE, RE..." }, { "title": "[Database] Inner Join", "url": "/posts/Inner-Join/", "categories": "Backend, Database", "tags": "database, sql, innerjoin", "date": "2021-06-30 21:15:00 +0900", "snippet": "Inner Join INNER JOIN은 조인될 조건이 부합하는 행에 대해서만 Join이 발생하는 것(교집합의 영역) 대개의 업무에서 조인은 Inner Join을 주로 사용하며, 일반적으로 Join이라 하면, Inner Join을 지칭하는 것이다.Inner Join 구조SELECT &amp;lt;열 목록&amp;gt;FROM &amp;lt;첫 번째 테이블&amp;gt; INNER JOIN &amp;lt;두 번째 테이블&amp;gt; ON &amp;lt;조인될 조건&amp;gt;[WHERE 검색조건]Inner Jo..." }, { "title": "[Database] Join", "url": "/posts/Join/", "categories": "Backend, Database", "tags": "database, sql, join", "date": "2021-06-30 21:10:00 +0900", "snippet": "Join 여러 테이블에 흩어져 있는 정보 중 사용자가 필요한 정보만 가져와 가상의 테이블을 만들어 보여주는 것으로 2개의 테이블을 조합하여 하나의 열로 표현하는 것이다.Join의 종류 1) INNER JOIN 2) CROSS JOIN 3) OUTER JOIN 4) SELF JOIN1. INNER JOIN INNER JOIN은 키 값이 있는 테이블의 컬럼 값을 비교 후 조건에 맞는 값을 가져오는 것이다. 즉, 서로 연관된 내용만 검색하는 조인 방법이다.사용법 SQL은 명시적 조인 표현과 암시적 조인 표현으로 구분을 ..." }, { "title": "[Database] Outer Join", "url": "/posts/Outer-Join/", "categories": "Backend, Database", "tags": "database, sql, outerjoin", "date": "2021-06-30 21:05:00 +0900", "snippet": "Outer Join Inner Join이 Join조건에 부합하는 행만 Join이 발생하는 것이라면, Outer Join은 조건에 부합하지 않는 행까지도 포함시켜 결합하는 것을 의미한다.(합집합의 영역) 자주는 아니지만, 가끔 유용하게 사용될 수 있으므로 꼭 알아둘 필요는 있다.Outer Join 구조SELECT &amp;lt;열 목록&amp;gt;FROM &amp;lt;첫번째 테이블 (LEFT 테이블)&amp;gt; &amp;lt;LEFT | RIGHT | FULL&amp;gt; OUTER JOIN &amp;lt;두번..." }, { "title": "[디자인패턴] 디자인 패턴 정리", "url": "/posts/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4%EC%A0%95%EB%A6%AC/", "categories": "CS, 디자인패턴", "tags": "designpattern", "date": "2021-06-30 17:10:00 +0900", "snippet": "디자인 패턴 정리1. 객체지향 모델링 연관 관계(association): 클래스들이 개념상 서로 연결되었음을 나타냄(실선이나 화살표로 표시하며 보통은 한 클래스가 다른 클래스에서 제공하는 기능을 사용하는 상황일때 표시) 일반화 관계(generalization): 객체지향 개념에서는 상속 관계라고 함(한 클래스가 다른 클래스를 포함하는 상위 개념일때의 관계이며 속이 빈 화살표를 사용해 표시) 집합 관계(Composition, aggregation): 클래스들 사이의 전체 또는 부분 같은 관계를 나타냄(집약 관계와 합성 관계..." }, { "title": "[디자인패턴] 커맨드 패턴(Command Pattern)", "url": "/posts/%EC%BB%A4%EB%A7%A8%EB%93%9C%ED%8C%A8%ED%84%B4/", "categories": "CS, 디자인패턴, 행위패턴", "tags": "designpattern, commandpattern", "date": "2021-06-30 17:05:00 +0900", "snippet": "커맨드 패턴(Command Pattern) 이벤트가 발생했을 때 실행될 기능이 다양하면서 변경이 필요한 경우 이벤트를 발생시키는 클래스의 변경없이 재사용하고자 할 때 사용하는 디자인 패턴 커맨드 패턴은 실행될 기능을 캡슐화함으로써 기능의 실행을 요구하는 호출자 클래스(Invoker)와 실제 기능을 실행하는 수신자 클래스(Receiver) 사이의 의존성을 제거한다. 따라서 실행될 기능의 변경에도 호출자 클래스를 수정없이 그대로 사용할 수 있도록 해준다. 알고리즘군을 정의하고 알고리즘 각각을 클래스로..." }, { "title": "[디자인패턴] 템플릿 메서드 패턴(Template Method Pattern)", "url": "/posts/%ED%85%9C%ED%94%8C%EB%A6%BF%EB%A9%94%EC%84%9C%EB%93%9C%ED%8C%A8%ED%84%B4/", "categories": "CS, 디자인패턴, 행위패턴", "tags": "designpattern, templatemethodpattern", "date": "2021-06-30 17:00:00 +0900", "snippet": "템플릿메서드패턴(Template Method Pattern) 전체적으로 동일하면서 부분적으로 상이한 문장을 가지는 메소드의 코드 중복을 최소화할 때 유용 템플릿 메소드 패턴은 전체적인 알고리즘을 구현하면서 상이한 부분은 하위 클래스에서구현할 수 있도록 해 주는 디자인 패턴으로서 전체적인 알고리즘의 코드를 재사용하는 데 유용하다. 전체적인 틀은 상위클래스에게 상속받고 변경되는 부분만 하위클래스에서 오버라이딩 하는 패턴 변화되는 부분만 추상 메소드로 만들어준다엘리베이터 제어 프로그램 Example 엘리베이터 제어 시스템에..." }, { "title": "[Backend] 동기&amp;비동기&amp;block&amp;non-block", "url": "/posts/%EC%BB%B4%ED%8C%8C%EC%9D%BC%EC%97%90%EB%9F%AC%EC%99%80-%EB%9F%B0%ED%83%80%EC%9E%84%EC%97%90%EB%9F%AC/", "categories": "Backend", "tags": "synchronous, asynchronous, block, non-block", "date": "2021-06-30 17:00:00 +0900", "snippet": "컴파일에러와 런타임에러컴파일에러 문법을 잘못 작성해 프로그램을 컴파일 할 수 없는 에러이다. 에러메시지를 통해 에러가 발생한 부분을 확인해 비교적 쉽게 해결할 수 있다. 예시 1)’;’(세미콜론)이 누락되거나 괄호가 맞지 않는 구문 에러(Syntax error) 2)interface 사용시 함수의 구체적인 내용을 적지 않은 에러 3)classpath에 누락 된 클래스(컴파일 시) 런타임에러 프로그래머의 설계 미숙으로 프로그램 실행 중 발생하는 에러로 프로그래머가 역추적해 원인을..." }, { "title": "[Backend] Restful API의 개요", "url": "/posts/RestfulAPI%EA%B0%9C%EC%9A%94/", "categories": "Backend", "tags": "rest, restful-api", "date": "2021-06-30 17:00:00 +0900", "snippet": "Rest란? Representational State Transfer의 약자(상태를 전달한다) 웹 표준에 기반한 아키텍처 스타일 데이터 커뮤니케이션을 위해서 HTTP프로토콜을 사용 HTTP 표준 프로토콜을 사용한 인터페이스를 통해 접근한 리소스를 중심으로 동작 Rest아키텍처에서 Rest서버는 단순하게 자원에 대한 접근성을 제공하고 Rest클라이언트는 자원에 접근하여 해당 자원을 사용하여 표현한다. HTTP표준 메소드와 URI를 통해서만으로도 어떤 요청인지 알 수 있음 REST는 T..." }, { "title": "[디자인패턴] 스트래티지 패턴(Strategy Pattern)", "url": "/posts/%EC%8A%A4%ED%8A%B8%EB%9E%98%ED%8B%B0%EC%A7%80%ED%8C%A8%ED%84%B4/", "categories": "CS, 디자인패턴, 행위패턴", "tags": "designpattern, strategypattern", "date": "2021-06-30 16:55:00 +0900", "snippet": "스트래티지 패턴(Strategy Pattern) 전략을 쉽게 바꿀 수 있도록 해주는 디자인 패턴이다. 여기에서 전략이란 어떤 목적을 달성하기 위해 일을 수행하는 방식, 비즈니스 규칙, 문제를 해결하는 알고리즘 등으로 이해할 수 있다. 프로그램에서 전략을 실행할 때는 쉽게 전략을 바꿔야 할 필요가 있는 경우가 많이 발생한다. 특히 게임 프로그래밍에서 게임 캐릭터가 자신이 처한 상황에 따라 공격이나 행동하는 방식을 바꾸고 싶을 때 스트래티지 패턴은 매우 유용하다.로봇 만들기 Example문제점 1) 기존 로봇의 공격 또는 이동..." }, { "title": "[디자인패턴] 옵서버 패턴(Observer Pattern)", "url": "/posts/%EC%98%B5%EC%84%9C%EB%B2%84%ED%8C%A8%ED%84%B4/", "categories": "CS, 디자인패턴, 행위패턴", "tags": "designpattern, observerpattern", "date": "2021-06-30 16:50:00 +0900", "snippet": "옵서버 패턴(Observer Pattern) 데이터의 변경이 발생하였을 때 상대 클래스 및 객체에 의존하지 않으면서 데이터 변경을 통보하고자 할 때 옵서버 패턴은 통보 대상 객체의 관리를 Subject 클래스와 Observer 인터페이스로 일반화한다. 그러면 데이터 변경을 통보하는 클래스(ConcreteSubject)는 통보 대상 클래스/객체ConcreteObserver)에 대한 의존성을 제거할 수 있다. 결과적으로 옵서버 패턴은 통보 대상 클래스나 대상 객체의 변경에도 ConcreteSubject 클래스를 수정 없이 그대..." }, { "title": "[디자인패턴] 컴퍼지트 패턴(Composite Pattern)", "url": "/posts/%EC%BB%B4%ED%8D%BC%EC%A7%80%ED%8A%B8%ED%8C%A8%ED%84%B4/", "categories": "CS, 디자인패턴, 구조패턴", "tags": "designpattern, compositepattern", "date": "2021-06-30 16:45:00 +0900", "snippet": "컴퍼지트 패턴(Composite Pattern) 부분(part)-전체(whole)의 관계를 가지는 객체들을 정의할 때 유용 클라이언트는 전체와 부분을 구분하지 않고 동일한 인터페이스를 사용할 수가 있다.컴퓨터에 추가 장치 지원하기 Example 소스 코드public class Keyboard { private int price; private int power; public Keyboard(int power, int price) { this.power = power; this.price = price; } public ..." }, { "title": "[디자인패턴] 데커레이터 패턴(Decorator Pattern)", "url": "/posts/%EB%8D%B0%EC%BB%A4%EB%A0%88%EC%9D%B4%ED%84%B0%ED%8C%A8%ED%84%B4/", "categories": "CS, 디자인패턴, 구조패턴", "tags": "designpattern, decoratorpattern", "date": "2021-06-30 16:40:00 +0900", "snippet": "데커레이터 패턴(Decorator Pattern) 기본 기능에 추가할 수 있는 기능의 종류가 많은 경우에 사용하는 패턴이다. 데커레이터 패턴은 기본 기능에 추가될 수 있는 많은 수의 부가 기능에 대해서 다양한 조합을 동적으로 구현할 수 있는 패턴이다. 동적으로 클래스의 기능을 확장시키고자 할 때 사용하는 패턴 (추가되는 기능을 갖는 클래스만 만들어주면 됨)도로 표시 방법 조합 프로그램 example 도로 표시 RoadDisplay 클래스: 기본 도로 표시 기능을 제공하는 클래스 RoadDispl..." }, { "title": "[디자인패턴] 팩토리 메서드 패턴(Factory Method Pattern)", "url": "/posts/%ED%8C%A9%ED%86%A0%EB%A6%AC%EB%A9%94%EC%84%9C%EB%93%9C%ED%8C%A8%ED%84%B4/", "categories": "CS, 디자인패턴, 생성패턴", "tags": "designpattern, factorymethodpattern", "date": "2021-06-30 16:35:00 +0900", "snippet": "팩토리 메서드 패턴(Factory Method Pattern) 객체의 생성 코드를 별도의 클래스/메소드로 분리함으로써 객체 생성의 변화를 대비하는 데 유용 팩토리 메소드 패턴은 객체의 생성 코드를 별도의 클래스/메소드로 분리함으로써 객체 생성 방식의 변화를 대비하는 데 유용하다.여러 방식의 엘리베이터 스케줄링 방법 지원하기 Example ElevatorManager 클래스: 여러 엘리베이터 중에서 스케줄링에 따라서 하나의 엘리베이터를 선택하고 이동시킴 ElevatorController 클래스: 하나의 엘리..." }, { "title": "[디자인패턴] 빌더 패턴(Builder Pattern)", "url": "/posts/%EB%B9%8C%EB%8D%94%ED%8C%A8%ED%84%B4/", "categories": "CS, 디자인패턴, 생성패턴", "tags": "designpattern, builderpattern", "date": "2021-06-30 16:30:00 +0900", "snippet": "Builder패턴(Builder Pattern) 객체의 생성과정과 표현을 분리하는 패턴입니다.왜 Builder패턴을 사용하느가? 다음의 UserInfo클래스가 있다고 가정해보자./*** 다음과 같이 객체를 만듭니다.*/public class UserInfo { private String name; private int age; private String addr; public UserInfo(String name, int age, String addr){ this.name = name; ..." }, { "title": "[디자인패턴] 추상 팩토리 메서드 패턴(Abstract Factory Method Pattern)", "url": "/posts/%EC%B6%94%EC%83%81%ED%8C%A9%ED%86%A0%EB%A6%AC%EB%A9%94%EC%84%9C%EB%93%9C%ED%8C%A8%ED%84%B4/", "categories": "CS, 디자인패턴, 생성패턴", "tags": "designpattern, abstractfactorymethodpattern", "date": "2021-06-30 16:25:00 +0900", "snippet": "추상 팩토리 메서드 패턴(Abstract Factory Method Pattern) 관련성이 있는 여러 종류의 객체를 일관된 방식으로 생성하는 경우에 유용엘리베이터 부품 업체의 변경하기 Example LG와 현대 업체의 모터와 문을 지원하는 클래스 템플릿 메서드의 적용 public abstract class Door { private DoorStatus doorStatus ; public Door() { doorStatus = DoorStatus.CLOSED ; } public DoorStatus g..." }, { "title": "[디자인패턴] 싱글톤 패턴(Singleton Pattern)", "url": "/posts/%EC%8B%B1%EA%B8%80%ED%84%B4%ED%8C%A8%ED%84%B4/", "categories": "CS, 디자인패턴, 생성패턴", "tags": "designpattern, singletonpattern", "date": "2021-06-30 16:20:00 +0900", "snippet": "싱글톤 패턴(Singleton Pattern) Singleton 패턴은 인스턴스를 불필요하게 생성하지 않고 오직 JVM내에서 한 개의 인스턴스만 생성하여 재사용을 위해 사용되는 디자인패턴프린터 관리자 Example 단 하나의 프린터 객체를 만들어 사용자 객체가 사용하려 한다.public class User { private String name; public User(String name) { this.name = name; } public void print() { P..." }, { "title": "[디자인패턴] 디자인 패턴", "url": "/posts/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4/", "categories": "CS, 디자인패턴", "tags": "designpattern", "date": "2021-06-30 16:15:00 +0900", "snippet": "디자인 패턴 소프트웨어를 설계할 때 특정 맥락에서 자주 발생하는 고질적인 문제들이 또 발생했을 떄 재사용할 수 있는 훌륭한 해결책 패턴이란? 공통의 언어를 만들어 의사 소통을 원활하게 한다. 각기 다른 소프트웨어 모듈이나 기능을 가진 다양한 응용 소프트웨어 시스템들을 개발할 때도 서로 간에 공통되는 설계 문제가 존재하며 이를 처리하는 해결책 사이에도 공통점이 있다. 이러한 유사점을 패턴이라 한다. 디자인 패턴의 구조 콘텍스트: 문제가 발생하는 여러 상황을 기술한다. 즉, 패턴이 적용될 수..." }, { "title": "[디자인패턴] SOLID 원칙", "url": "/posts/SOLID%EC%9B%90%EC%B9%99/", "categories": "CS, 디자인패턴", "tags": "designpattern, solid", "date": "2021-06-30 16:10:00 +0900", "snippet": "SOLID 원칙 - 로버트 마틴이 주장한 다섯 가지 설계 원칙1) SRP(단일 책임 원칙, Siingle Responsibility Principle) 단일 책임 원칙이다. 즉, 클래스는 단 하나의 책임만을 가지도록 설계해야 한다는 의미 책임은 ‘해야 하는 것’과 ‘변경 이유’ 두 가지로 해석 될 수 있음 다음 그림은 SRP를 만족하지 않음 하는 일의 관점: 하나는 임금을 계산하는 것이고 다른 하나는 영역의 합을 콘솔에 출력하는 일이다. 변경 이유의 관점: 임금을 구하는 방식이 변경되면 클래스..." }, { "title": "[디자인패턴] 객체지향 원리", "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9B%90%EB%A6%AC/", "categories": "CS, 디자인패턴", "tags": "designpattern", "date": "2021-06-30 16:00:05 +0900", "snippet": "객체지향 원리캡슐화 요구사항의 변경 소프트웨어 개발의 골치거리 해결책은 요구사항 변경을 당연한 것으로 받아들이고 이에 대비하는 것이다. 캡슐화를 통해 높은 응집도와 낮은 결합도를 갖는 설계 다음과 같이 클래스 멤버 변수의 접근 제어자를 private으로 설정함으로써 외부에서는 직접 itemArray클래스에 접근할 수 가 없고 push(), pop()메서드를 통해서만 접근이 가능하게 된다 일반화 관계 일반화(상속)을 속성이나 기능의 재사용 관점에서만 보..." }, { "title": "[디자인패턴] 객체지향 모델링", "url": "/posts/%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EB%AA%A8%EB%8D%B8%EB%A7%81/", "categories": "CS, 디자인패턴", "tags": "designpattern", "date": "2021-06-30 16:00:00 +0900", "snippet": "객체지향 모델링소프트웨어 모델의 역할 서로의 해석을 공유해 합의를 이루거나 해석의 타당성을 검토한다. 현재 시스템 또는 앞으로 개발할 시스템의 원하는 모습을 가시화한다. 시스템의 구조와 행위를 명세할 수 있으며 시스템을 구축하는 틀을 제공한다.UML(Unified Modeling Language) 대표적인 소프트웨어 모델링 언어 (시스템을 모델로 표현해주는 언어) UML다이어그램의 종류 구조 다이어그램: 클래스 다이어그램, 객체 다이어그램, 복합체 구조 다이어그램, 배치 다이어그램, 컴포넌트 다이어그램..." }, { "title": "IntelliJ 디버깅", "url": "/posts/IntelliJ-%EB%94%94%EB%B2%84%EA%B9%85/", "categories": "개발환경, IntelliJ", "tags": "intelliJ, debugging", "date": "2021-06-30 00:00:00 +0900", "snippet": "IntelliJ 디버깅 프로그래밍에 있어 디버깅은 필수적인 요소이며 실제 개발할 때에도 가장 중요한 부분이다. 디버깅을 얼마나 잘하느냐에 따라 프로그래머의 실력이 갈릴 정도로 프로그래머에게 있어 가장 중요한 능력이 디버깅 능력이다. 디버깅에 대해서는 여기를 참고하자.디버깅을 하기 전에 습관적으로 run을 실행하지만, 로컬 개발에선 웬만하면 debug로 실행하자! 애플리케이션 실행 중에 break point를 사용하려면 debug여야만 한다. 코드 좌측의 여백을 우클릭하면 Show Line Numbers가 나오는데 이를..." }, { "title": "[React] Lifecycle 생명주기", "url": "/posts/React-Lifecycle-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/", "categories": "Frontend, React", "tags": "react", "date": "2021-06-30 00:00:00 +0900", "snippet": "출처 https://ko.reactjs.org/docs/state-and-lifecycle.html https://velog.io/@st2702/React-Lifecycle-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0" }, { "title": "[React] 리액트 개요", "url": "/posts/React%EA%B0%9C%EC%9A%94/", "categories": "Frontend, React", "tags": "react, ssr, csr", "date": "2021-06-30 00:00:00 +0900", "snippet": "리액트(React) UI를 효과적으로 구축하기 위해 사용하는 자바스크립트(JavaScript) 기반의 라이브러리 기존에 웹 사이트를 만들 때에는 보통 프론트엔드 부분을 객체 지향적으로 작성하지는 않았다. 백엔드에서나 객체지향 기법을 적절히 따르면서 개발했었다. 하지만 리액트는 프론트엔드 또한 매우 객체지향적으로 구현하도록 해주는 라이브러리이다. 리액트 오픈소스: https://github.com/facebook/react 리액트 학습 사이트: https://reactjs.org/docs/getting-started.ht..." }, { "title": "[Bootstrap] Bootstrap 활용", "url": "/posts/bootstrap%ED%99%9C%EC%9A%A9/", "categories": "Frontend, Bootstrap", "tags": "bootstrap", "date": "2021-06-30 00:00:00 +0900", "snippet": "1) 프로젝트설정2) resources(정적파일) 설정3) home.jsp 코드 수정 및 resources파일 경로재지정4) 테스트" }, { "title": "[Bootstrap] Bootstrap 설치", "url": "/posts/bootstrap%EC%84%A4%EC%B9%98/", "categories": "Frontend, Bootstrap", "tags": "bootstrap", "date": "2021-06-30 00:00:00 +0900", "snippet": "BootStrap 공식 홈페이지https://getbootstrap.com/1. Download버튼 클릭 1) download받아서 로컬에 저장하는 방식 2)CDN을 활용하는 방식 CDN에는 컴파일된 css와 javascript에 대한 cached 버전을 가지고 있어서 동적으로 url을 통해 가져오는 방식 bootstrap.css 와 boostrap.min.css 둘 중 아무거나 사용해도 상관없음 bootstrap.js 와 boostrap.min.js 둘 중 아무거나 사용..." }, { "title": "[Bootstrap] Bootstrap 개요", "url": "/posts/bootstrap%EA%B0%9C%EC%9A%94/", "categories": "Frontend, Bootstrap", "tags": "bootstrap", "date": "2021-06-30 00:00:00 +0900", "snippet": "BootStrap 공식 홈페이지https://getbootstrap.com/BootStrap의 두 가지 특징1) 반응형(responsive) 웹페이지 페이지로 다양한 디바이스(데스크탑, 테블릿pc, 모바일)나 브라우저의 크기에 맞춰서 적절한 사이즈로 보여주는 방식 사이즈가 줄어들게 되면 Stacked to Horizontal 방식으로 세로 방향으로 줄어들게 됨 2) Mobile-first 웹페이지를 디자인할때 모바일 환경을 먼저 고려해야한다. 모바일 환경에서 꼭 필요한 컨텐트들을 고려하고 브라우..." }, { "title": "[CICD] Jenkins를 활용하여 Tomcat에 war배포", "url": "/posts/Tomcat%EC%97%90war%EB%B0%B0%ED%8F%AC/", "categories": "DevOps, CICD", "tags": "cicd, jenkins, tomcat", "date": "2021-06-30 00:00:00 +0900", "snippet": "출처 https://stage-diary.tistory.com/591?category=1130150" }, { "title": "[CICD] CI 구축 실습 With 도커", "url": "/posts/CI%EA%B5%AC%EC%B6%95%EC%8B%A4%EC%8A%B5With%EB%8F%84%EC%BB%A4/", "categories": "DevOps, CICD", "tags": "cicd, jenkins, docker", "date": "2021-06-30 00:00:00 +0900", "snippet": "Ec2인스턴스에 Docker 설치 Docker 설치Docker를 활용하여 JDK11을 활용한 Jenkins설치 현재 jenkins의 Global Tool Configuration -&amp;gt; install automatically에서 Oracle JDK를 설치하는 것을 9 버전 까지만 지원하고 오라클의 라이선스 정책 변경 때문에 10 이상 버전은 더 이상 지원하지 않는다. https://issues.jenkins-ci.org/browse/JENKINS-54305 docker hub의 jen..." }, { "title": "[CICD] CI/CD 란?", "url": "/posts/CICD%EB%9E%80/", "categories": "DevOps, CICD", "tags": "cicd, jenkins, travice-ci, bamboo, circle-ci, teamcity", "date": "2021-06-30 00:00:00 +0900", "snippet": "CI/CD란?CI Continuous Integration(지속적 통합)으로 ‘코드에 대한 통합’을 ‘지속적’으로 진행함으로써 품질을 유지하자는 개념 예를 들면, 여러 명의 개발자가 하나의 프로젝트를 진행할 때 아래와 같은 과정을 거쳐야 한다. 1)모든 개발자는 퇴근하기 전에 자신의 코드를 중앙 코드와 통합한다. 2)통합된 코드에서 본인의 코드가 제대로 동작하는지 테스트한다. 3)통합된 코드가 제대로 빌드되는지 테스트한다. 4)결과..." }, { "title": "[Tomcat] Tomcat 배포 오류", "url": "/posts/Tomcat%EB%B0%B0%ED%8F%AC%EC%98%A4%EB%A5%98/", "categories": "DevOps, Tomcat", "tags": "tomcat", "date": "2021-06-30 00:00:00 +0900", "snippet": "Tomcat 배포 오류 Tomcat War파일 배포시 위 처럼 업로드가 되지 않을때 Tomcat의 Log파일을 확인해보니 위와 같이 SizeLimitExceededException이 발생하였다. 톰캣의 최대 파일 업로드 사이즈가 52428800인데 65705825크기의 파일을 업로드하려하니 Exception이 발생하였다. webapps/manager/WEB-INF/web.xml을 확인해보았다. 최대 파일 업로드사이즈가 52428800로 설정되있었다. 이를 657..." }, { "title": "Message Queue", "url": "/posts/MessageQueue/", "categories": "DevOps, MessageQueue", "tags": "messagequeue", "date": "2021-06-30 00:00:00 +0900", "snippet": "MessageQueue 프로세스(프로그램)간에 데이터를 교환할 때 사용하는 통신 방법 중에 하나 MOM(Message Oriented Middleware: 비동기 메시지를 사용하는 프로그램 간의 데이터 송수신을 의미)을 구현한 시스템 작업을 늦출 수 있는 유연성을 제공 메시지를 교환할때 AMQP(Advanced Message Queuing Protocol: MQ의 오픈소스에 기반한 표준 프로토콜)을 이용 kafka, RabbitMQ, Active MQ, AWS SQS, Java JMS등이 존재MessageQueue를 ..." }, { "title": "[운영체제] 프로세스(Process)", "url": "/posts/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/", "categories": "CS, OperationSystem", "tags": "operationsystem, os, process", "date": "2021-06-30 00:00:00 +0900", "snippet": "프로세스(Process) 실행중인 프로그램! 프로그램 자체는 디스크 내 파일로 존재하고 동작을 하지 않는 정적이며 수동적인 개체이다. 프로그램을 실행시키려면 운영체제로 부터 프로그램이 동작하는데 필요한 CPU, 메모리, 입출력장치, 파일 드으이 자원을 할당 받아 동작을 시작해야 한다.프로세스의 상태 변화 1) 생성상태 -&amp;gt; 준비상태 미리 정의된 정책에 따라 스케줄러에 의해 호출, 이때 메모리의 이용 가능성과 어떤 장치가 요구되는지를 검사한다. 2) 준비상태 -&amp;gt; 실행..." }, { "title": "[운영체제] 스레드와 프로세스", "url": "/posts/%EC%8A%A4%EB%A0%88%EB%93%9C%EC%99%80%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/", "categories": "CS, OperationSystem", "tags": "operationsystem, os, process, thread", "date": "2021-06-30 00:00:00 +0900", "snippet": "프로그램 일반적으로 특정 작업을 수행하는 소프트웨어프로세스 메모리나 CPU와 같은 자원을 할당받아 실행 중인 프로그램 독자적인 메모리를 할당받아서 서로 다른 프로세스끼리는 일반적으로 서로의 메모리 영역을 침범하지 못함스레드: 프로세스를 구성하는 하나의 단위, 작업의 실행 단위 하나의 프로세스는 여러 스레드가 작동하고 있을 수 있음 하나의 프로세스에 존재하는 여러 스레드들은 같은 자원을 공유하여 사용 할 수 있음 이로 인해 병렬성의 향상이라는 장점이 있는 반면에 동시성 문제, 데드락과 같은 여러 가지 문제점도 발생 ..." }, { "title": "[DataStructure] red-black 트리 &amp; AVL 트리", "url": "/posts/red-black-%ED%8A%B8%EB%A6%AC%EC%99%80-AVL-%ED%8A%B8%EB%A6%AC/", "categories": "DataStructure, Tree", "tags": "datastructure, tree, red-black-tree, avl-tree", "date": "2021-06-30 00:00:00 +0900", "snippet": "red-black 트리와 AVL트리가 생겨난 배경 이진 탐색 트리는 평균적으로 O(logN)의 삽입, 삭제, 검색 연산속도를 가진다. 이진 검색 트리의 구성 조건은 left &amp;lt; root &amp;lt; right이다. 만약 순차정렬된 데이터가 들어온다면 이진 검색트리는 위의 그림과 같이 편향트리가 될 것이다. 트리의 속도는 트리의 깊이에 따라 결정 되기에 편향 트리의 시간복잡도는 O(N)까지 늘어난다. 이러한 일을 방지하기 위해 균형 이진 트리가 발생하였고 이의 종류로는 red-black트리와 AV..." }, { "title": "[DataStructure] Tree(트리)", "url": "/posts/Tree/", "categories": "DataStructure, Tree", "tags": "datastructure, tree", "date": "2021-06-30 00:00:00 +0900", "snippet": "트리란? 계층적인 자료를 표현하기 위한 자료구조 데이터 요소들의 단순한 나열이 아닌 부모-자식 관계의 계층적 구조로 표현 트리는 그래프의 한 종류이며 사이클이 없다. 실제 나무를 거꾸로 한 것과 같은 모양을 하고 있기 때문에 트리라고 부른다. node: 트리를 구성하고 있는 각 요소 Edge(간선): 트리를 구성하기 위해 노드와 노드를 연결하는 선 RootNode: 최상위 계층에 존재하는 노드 level: 트리의 특정 깊이를 가지는 노드의 집합 degree:(차수): 하위 트리 개수 / 간선 수(degree) ..." }, { "title": "[DataStructure] Binary Tree(이진트리)", "url": "/posts/Binary-Tree/", "categories": "DataStructure, Tree", "tags": "datastructure, tree, binarytree", "date": "2021-06-30 00:00:00 +0900", "snippet": "이진트리(Binary Tree) 이진트리는 트리를 구성하는 노드들의 최대 차수(degree)가 2인 노드들로 구성되는 트리이다. 이진트리의 레벨i에서 가질 수 있는 최대 노드의 2^i이다.(i&amp;gt;=0) 깊이가 k인 이진트리가 가질 수 있는 최대 노드의 수는 2^k-1이다.(k&amp;gt;=1) 이진트리는 완전 이진 트리(Completable Binary Tree)와 포화 이진 트리(Perfect Binary Tree), 전 이진 트리(Full Binary Tree)라고 하는 ..." }, { "title": "[DataStructure] Binary Search Tree(이진 탐색 트리)", "url": "/posts/Binary-Search-Tree/", "categories": "DataStructure, Tree", "tags": "datastructure, tree, binary-search-tree", "date": "2021-06-30 00:00:00 +0900", "snippet": "Binary Search Tree(이진 탐색 트리) 모든 노드가 자신의 왼쪽 서브트리에는 현재노드보다 작은 키값이, 오른쪽 서브트리에는 현재 노드보다 큰 값이 오는 규칙을 만족하는 이진트리 모든 왼쪽 자식들 &amp;lt;= n &amp;lt; 모든 오른쪽 자식들 (모든 노드 n에 대해서 반드시 참) 이진 탐색 트리는 이진 탐색을 쉽게 할 수 있도록 만들어진 트리 이진 탐색 트리의 조건 이진 탐색 트리의 노드에 저장된 키는 유일하다. 루트 노드의 키가 왼쪽 서브 트리를 구성하는 어떠한 노드의 키..." }, { "title": "[DataStructure] Balanced Binary Search Tree(균형 이진탐색 트리)", "url": "/posts/Balanced-Binary-Search-Tree/", "categories": "DataStructure, Tree", "tags": "datastructure, tree, balanced-binary-search-tree", "date": "2021-06-30 00:00:00 +0900", "snippet": "Balanced Binary Search Tree(균형 이진탐색 트리) 이진 탐색트리에 새로운 노드가 삽입이 되면 부모의 노드보다 작은 값은 왼쪽으로 큰 값은 오른쪽으로 추가하면서 서브트리가 계속 구성되어진다. 이진탐색트리의 치명적인 단점은 자료가 많아질수록 트리의 높이(height)가 커지기 때문에 검색에 불리해지고 최악의 경우 (worst case) 특정 노드를 탐색하는데 log(n) 이 소요될수도 있다. 예를들어 지금까지 배운 방식대로 1 , 2, 3, 4 를 이진트리에 추가한다면 아래의 그림과 같..." }, { "title": "[DataStructure] Stack(스택)", "url": "/posts/Stack/", "categories": "DataStructure, Stack", "tags": "datastructure, stack", "date": "2021-06-30 00:00:00 +0900", "snippet": "스택이란? 마지막에 들어온 데이터를 먼저 내보내는 후입선출(LIFO: Last-In-First-Out)을 표현하기 위한 자료구조 예를 들어 접시 쌓기를 예로 들 수 있습니다. 접시를 쌓을 때 위에서부터 차곡차곡 쌓지만 빼낼때는 가장 맨위의(마지막에 들어온) 접시부터 빼내게 됩니다.스택의 장점 스택에서 데이터를 추가하거나 삭제하는 연산은 상수 시간(O(1))에 가능 배열처럼 원소들을 하나씩 옆으로 밀어 줄 필요가 없다.스택의 단점 배열과 달리 스택은 상수 시간에(O(1)) 특정 원소를 접근할 수 없다.스택의 연산 pu..." }, { "title": "[DataStructure] 우선순위 큐(Priority Queue)", "url": "/posts/%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84-%ED%81%90(Heap)/", "categories": "DataStructure, Queue", "tags": "datastructure, priorityqueue", "date": "2021-06-30 00:00:00 +0900", "snippet": "우선순위 큐(Priority Queue)란? 우선순위에 따라 우선순위가 높은 객체가 먼저 나오는 자료구조 우선순위 큐는 3가지 방법으로 구현할 수 있다. 1)배열 사용 데이터 삽입, 삭제과정에서 데이터를 밀고 당기는 연산을 해야 하는 단점이 존재 2)연결리스트 사용 연결리스트로 우선순위 큐를 구현하였을 경우 삽입의 위치를 찾기 위해 첫 번째 노드부터 마지막에 저장된 노드까지 순회해야 하는 단점 ..." }, { "title": "[DataStructure] Queue(큐)", "url": "/posts/Queue/", "categories": "DataStructure, Queue", "tags": "datastructure, queue", "date": "2021-06-30 00:00:00 +0900", "snippet": "Queue(큐)란? 먼저 들어온 데이터를 먼저 내보내는 선입선출(FIFO: First-In-First-Out) 구조의 자료구조 예를 들어, 영화관 매표소에서 예매를 하기 위해 손님들은 순서대로 줄을 스게 되며 먼저 온 손님부터 영화를 예매하게 됩니다. Java에서는 Queue를 사용하기 위해 java.util.Queue를 구현한 클래스를 사용한다.큐의 연산 add() : queue에 데이터 삽입. peek() : 제일 먼저 들어와 상단에 위치한 데이터를 리턴합니다. poll() : 상단에 위치한 데이터를 추출하고 q..." }, { "title": "[DataStructure] Deque(덱)", "url": "/posts/Deque(%EB%8D%B1)/", "categories": "DataStructure, Queue", "tags": "datastructure, deque", "date": "2021-06-30 00:00:00 +0900", "snippet": "Deque(덱) Deque(덱 혹은 데크)은 Double-Ended Queue의 줄임말로 큐의 양쪽으로 엘리먼트의 삽입과 삭제를 수행할 수 있는 자료구조이다. 카프카의 소스코드 내부에서 Deque 클래스를 사용한다. 덱(Deque)은 어떤 쪽으로 입력하고 어떤 쪽으로 출력하느냐에 따라서 스택(Stack)으로 사용할 수도 있고, 큐(Queue)로도 사용할 수 있다. 특히 한쪽으로만 입력 가능하도록 설정한 덱을 스크롤(scroll)이라고 하며, 한쪽으로만 출력 가능하도록 설정한 덱을 셸프(shelf)라고 한다.Deque 연..." }, { "title": "[DataStructure] Array 와 List(그리고 Java List)", "url": "/posts/Array%EC%99%80List(%EA%B7%B8%EB%A6%AC%EA%B3%A0-Java-List)/", "categories": "DataStructure, List", "tags": "datastructure, array, list", "date": "2021-06-30 00:00:00 +0900", "snippet": "Array의 개념 같은 타입의 여러 데이터를 하나의 이름으로 그룹핑해서 관리하기 위한 자료구조 index와 값의 쌍으로 구성 index는 값에 대한 유일무이한 식별자(List에서 인덱스는 몇 번째 데이터인가 정도의 의미를 가짐) 연속된 메모리의 공간으로 이루어져 있다. 논리적 저장 순서와 물리적 저장 순서가 일치 =&amp;gt; index로 해당 원소에 접근할 수 있다. (시간복잡도: O(1)) 배열은 선언과 동시에 길이를 지정하며 길이를 변경할 수 없다.Array의 장점 인덱스를 통한 검색이 용이함 연속적이므..." }, { "title": "[DataStructure] Array &amp; ArrayList &amp; LinkedList의 비교", "url": "/posts/Array%EC%99%80-ArrayList%EC%99%80-LinkedList%EC%9D%98-%EB%B9%84%EA%B5%90/", "categories": "DataStructure, List", "tags": "datastructure, array, arraylist, linkedlist", "date": "2021-06-30 00:00:00 +0900", "snippet": "Array&amp;amp;ArrayList&amp;amp;LinkedList의 비교 ArrayList와 LinkedList는 모두 Java에서 제공하는 List 인터페이스를 구현한 Collection 구현체이며, 인터페이스만 같을 뿐 내부적으로 동작하는 방식은 다르다1) Array 같은 타입의 여러 데이터를 하나의 이름으로 그룹핑해서 관리하기 위한 자료구조 index와 값의 쌍으로 구성 논리적 저장 순서와 물리적 저장 순서가 일치함Array의 장점 만약 인덱스 값을 알고 있다면 Big-O(1)으로 접근 가능 rand..." }, { "title": "[DataStructure] 시간복잡도", "url": "/posts/%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84/", "categories": "DataStructure", "tags": "datastructure, timecomplexity", "date": "2021-06-30 00:00:00 +0900", "snippet": "시간 복잡도(Time Complexity) 알고리즘을 수행하기 위해 프로세스가 수행해야하는 명령어의 실행 횟수(연산 횟수)를 수치화 한것 왜 실행시간이 아닌 연산수치로 판별할까? 명령어의 실행시간은 컴퓨터의 하드웨어 또는 프로그래밍 언어에 따라 편차가 크게 달라지기 때문에 명령어의 실행 횟수만을 고려하는 것이다.Big-O 표기법 시간 복잡도를 표기하는 방법 실행 시간 n을 O(n)으로 표기 Big-O에서 차수가 가장 높은 최고차항만 두고 나머지는 버림 1) O(1) - Constant Time 입력되..." }, { "title": "[TDD] TDD 관련 블로그", "url": "/posts/TDD%EA%B4%80%EB%A0%A8%EB%B8%94%EB%A1%9C%EA%B7%B8/", "categories": "Backend, TDD", "tags": "tdd, junit", "date": "2021-06-30 00:00:00 +0900", "snippet": "TDD 관련 블로그 https://sunghs.tistory.com/134?category=673786 https://scshim.tistory.com/321?category=961195" }, { "title": "[TDD] Junit", "url": "/posts/Junit5/", "categories": "Backend, TDD", "tags": "tdd, junit, jupiter, vintage", "date": "2021-06-30 00:00:00 +0900", "snippet": "Junit5 Spring boot 2.2부터는 기본으로 junit5 모듈을 사용하게 된다. Junit4 는 단일 모듈이였던 반면, Junit5는 크게 Junit Jupiter, Junit Platform, Junit Vintage모듈로 구성되어진다.Junit Platform 테스트들을 실행하기 위한 뼈대 테스트를 발견하고 테스트 계획을 생성하는 TestEngine인터페이스를 가지고 있다. Platform은 TestEngine을 통해서 테스트를 발견하고, 실행하고, 결과를 보고한다. 또한 콘솔출력, 각종 IDE들의 연동..." }, { "title": "[보안] 정보보안 개요", "url": "/posts/%EC%A0%95%EB%B3%B4%EB%B3%B4%EC%95%88%EC%9D%98-%EA%B0%9C%EC%9A%94/", "categories": "Backend, Security", "tags": "security", "date": "2021-06-30 00:00:00 +0900", "snippet": "정보보안 개요 ※OWASP(sw의 보안성을 개선하기 위해 노력하는 비영리재단) 에서 제안한 10개의 웹 취약점 분석을 통해 웹에 안전하단걸 검증하고 웹 서비스를 배포해야함1) 보안에서 중요한 3가지 측면(CIA) alice:은행 설립자 bob:은행 고객 trudy:침입자 AOB(Alice open Bank) ① Confidentiality(기밀성) 정보를 허가 받지 않는 사람이 읽는 걸 막아야함 아예 접근을 하지 못하게하는방법 + 암호를 하여 읽더라도 해석을 못하게 하는방법 ..." }, { "title": "[보안] 암호 기초", "url": "/posts/%EC%95%94%ED%98%B8%EA%B8%B0%EC%B4%88/", "categories": "Backend, Security", "tags": "security", "date": "2021-06-30 00:00:00 +0900", "snippet": "보안1) Confidentiality(기밀성) 허가 받지 않은 사람이 정보를 해독하지 못하도록 하는것2) Encryption Algorithms(암호 알고리즘)1) Symmetric Key Cryptography(대칭키암호) 암호할때 사용하는 키랑 복호할때 사용하는 키가 같음 Stream Ciphter(비트단위로 암호화) *Block Ciphers(블록단위로 암호화) -&amp;gt; round function을 반복함으로써 Ciphertext가 얻어짐 -&amp;gt; round function의 입력값으로..." }, { "title": "[보안] Apache Tomcat SSL Configuration", "url": "/posts/Apache-Tomcat-SSL-Configuration/", "categories": "Backend, Security", "tags": "security, ssl, tomcat", "date": "2021-06-30 00:00:00 +0900", "snippet": "1) Creating the KeyStore 서버는 인증서가 반드시 있어야하는데 KeyStore를 만들고 인증서를 저장한다 자바에서는 keytool이라 불리는 command-line tool을 제공한다 이를 사용해서 KeyStore를 만들수 있고 여기에 인증서를 넣어 둘 수 있다 인증서로서 test목적으로 self-signed인증서를 사용한다 ( 자기 자신이 직접 서명한 인증서) keytool을 사용해서 self-signed인증서를 만들어서 KeyStore에 저장1-1) keystore라는 디렉토리 생성1-2) Key..." }, { "title": "[보안] AES", "url": "/posts/AES/", "categories": "Backend, Security", "tags": "security, aes", "date": "2021-06-30 00:00:00 +0900", "snippet": "대칭키 암호 알고리즘 암호화키 = 복호화키1) DES(56bit key): 2^56 2의 56승의 전수 조사를 하면 풀릴 수 있는 단점이 존재함. 해결책이 아래의 3DES2) 3DES(112bit key) : 2^1123) AES(128,192,256 bit Key) 반복적으로 block cipher(like DES) Not a Feistel cipher(unlike DES) 각 라운드마다 4개의 function사용 한 바이트를 S-Box를 통해서 대치된다 Ex) 9a(16진수) -&amp;gt;b8(1..." }, { "title": "[보안] Java로 구현한 AES CBC", "url": "/posts/AES-CBC-IN-JAVA/", "categories": "Backend, Security", "tags": "security, aes, cbc", "date": "2021-06-30 00:00:00 +0900", "snippet": "Programming Aes Cbc In Java Base64인코딩 : binary를 텍스트로 인코딩하는 Scheme 일반적인 binary값은 출력하면 깨질수도 있기에 a~/까지 텍스트로 인코딩하는 방식 64진수 -&amp;gt;6비트로 자름출처 https://www.javacodegeeks.com/2018/03/aes-encryption-and-decryption-in-javacbc-mode.html https://www.devglan.com/online-tools/aes-encryption-decryption" }, { "title": "Kafka 카프카 클러스터 구축 실습 with AWS EC2", "url": "/posts/Kafka-%EC%B9%B4%ED%94%84%EC%B9%B4-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0-%EA%B5%AC%EC%B6%95-%EC%8B%A4%EC%8A%B5-with-AWS-EC2/", "categories": "Backend, Kafka", "tags": "kafka", "date": "2021-06-30 00:00:00 +0900", "snippet": "Kafka 카프카 클러스터 구축 실습 with AWS EC2 aws의 ec2 서버 3대를 발급받아서 카프카를 설치 후 console producer와 console consumer로 연동해보는 실습 아파치 카프카를 실행하기 위해선 2가지의 애플리케이션의 요구 zookeeper: 카프카 관련 정보를 저장하는 역할 kafka 설치 1) ec2 t2.micro 인스턴스 3대 발급 받기2) 발급받은 인스턴스 3대 모두 wget명령어로 zookeeper다운 받고 압축 풀기 ..." }, { "title": "Kafka 기본 실습", "url": "/posts/Kafka-%EA%B8%B0%EB%B3%B8-%EC%8B%A4%EC%8A%B5/", "categories": "Backend, Kafka", "tags": "kafka", "date": "2021-06-30 00:00:00 +0900", "snippet": "Kafka-실습1Kafka 설치1) homebrew를 통한 kafka 설치brew install kafkaKafka 실행2) Kafka를 실행하기 전 zookeeper를 먼저 시작brew services start zookeeper3) Kafka 시작brew services start kafka4) Kafka에서 기본적으로 제공하는 테스트를 위한 다양한 script의 위치 확인brew info kafka5) Topic생성 (파티션1개 replication은 1이고 Topic이름은 test)./kafka-topics --crea..." }, { "title": "Kafka 개요", "url": "/posts/Kafka-%EA%B0%9C%EC%9A%94/", "categories": "Backend, Kafka", "tags": "kafka", "date": "2021-06-30 00:00:00 +0900", "snippet": "MessageQueue 데이터를 전송하는 애플리케이션과 데이터를 수신 받는 애플리케이션의 개수가 늘어날 수 록 데이터 전송라인이 많아 지게 됨 데이터 전송라인이 많아지면 배포와 장애에 대응하기 어려움 데이터를 전송할 때의 프로토콜의 파편화가 심각해짐 추후 데이터의 포맷내부에 변경이 있을 때 유지보수하기 매우 어려워짐 카프카는 이런 복잡함을 해결하기 위해 링크드인에서 내부적으로 개발하였고 현재는 오픈 소스로 제공 Source Application과 TargetAppliction의 커플링을 약하게 해줌 Source A..." }, { "title": "[Java] JVM 구조", "url": "/posts/JVM%EA%B5%AC%EC%A1%B0/", "categories": "Backend, Java", "tags": "java, jvm", "date": "2021-06-30 00:00:00 +0900", "snippet": "JVM이란? java 가상머신으로 java 바이트 코드를 실행할 수 있는 주체JVM의 구성 요소 1) Class Loader 예를 들어 자바에서 코딩시 a.java파일이 생성된다고 하면 .java소스를 자바컴파일러(javac)가 컴파일하여 a.class와 같은 클래스 파일(바이트코드)로 변환해준다. Class Loader는 이러한 class파일들을 모아 JVM이 운영체제로 부터 할당받은 메모리 영역인 Runtime Data Area로 적재하는 역할을 한다. 2) Execution Engine ..." }, { "title": "[Java] JAXB", "url": "/posts/JAXB/", "categories": "Backend, Java", "tags": "java, jaxb", "date": "2021-06-30 00:00:00 +0900", "snippet": "JAXB JAXB(Java Architecture for XML Binding)는 Java Object를 XML로 직렬화(마샬링)하고, XML을 Java Object로 역직렬화(언마샬링)해주는 자바 API JDK6 ~ 9 버전은 JAXB가 내장되어 있어 라이브러리를 추가 할 필요가 없음Annotation @XmlRootElement - XML의 Root Element 명을 정의합니다. @XmlElement - XML의 Element 명을 정의합니다. @XmlType - XML 스키마 이름과 namespace를 정의합니..." }, { "title": "[Java] GC(Garbage Collection)의 개요", "url": "/posts/GC(Garbage-Collection)%EA%B0%9C%EC%9A%94/", "categories": "Backend, Java", "tags": "java, gc, garbage-collection", "date": "2021-06-30 00:00:00 +0900", "snippet": "GC(Garbage Collection)의 개요가비지 컬렉션 과정 GC에 대해 알아보기 전에 ‘stop-the-world’라는 용어를 알아 둬야 함 ‘stop-the-world’란 GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것 ‘stop-the-world’가 발생하면 GC를 실행하는 스레드를 제외한 나머지 스레드는 모두 작업을 멈추게 됨 GC작업을 완료한 이후에야 중단했던 작업을 다시 시작함 어떤 GC알고리즘을 사용하더라도 ‘stop-the-world’는 반드시 발생함 대개의 경우 GC 튜닝이란 ‘st..." }, { "title": "[Java] Collection", "url": "/posts/Collection/", "categories": "Backend, Java", "tags": "java, collection", "date": "2021-06-30 00:00:00 +0900", "snippet": "Collection의 개념 Java에서 컬렉션(Collection)이란 데이터의 집합, 그룹을 의미 JCF(Java Collections Framework)는 이러한 데이터, 자료구조인 컬렉션과 이를 구현하는 클래스를 정의하는 인터페이스를 제공Java 컬렌션 프레임워크의 상속구조 Collection 인터페이스는 List, Set, Queue로 크게 3가지 상위 인터페이스로 분류할 수 있다. Map의 경우 Collection 인터페이스를 상속받고 있지 않지만 Collection으로 분류한다.Collection 인터페이스의..." }, { "title": "[Java] Call by value와 Call by reference", "url": "/posts/CallByValue%EC%99%80-CallByReference/", "categories": "Backend, Java", "tags": "callbyvalue, callbyreference", "date": "2021-06-30 00:00:00 +0900", "snippet": "Call by value와 Call by reference Call by value와 Call by reference는 메소드 호출 시 인자 값을 어떤식으로 받아오는지에 대한 차이이다. Call by value: 값에 의한 호출 Call by reference: 참조에 의한 호출 Java는 Call by value형식이다.Call by value 메소드 호출 시에 사용되는 인자의 메모리에 저장되어 있는 값(value)을 복사하여 보냄public class Main { private s..." }, { "title": "[Java] Array&amp;List변환", "url": "/posts/Array%EC%99%80-List%EB%B3%80%ED%99%98/", "categories": "Backend, Java", "tags": "java, array, list", "date": "2021-06-30 00:00:00 +0900", "snippet": "1) List -&amp;gt; Array 변환case1 - 반복문 이용ArrayList&amp;lt;String&amp;gt; arrayList = new ArrayList&amp;lt;&amp;gt;();arrayList.add(&quot;Test1&quot;);arrayList.add(&quot;Test2&quot;);arrayList.add(&quot;Test3&quot;);String[] array = new String[arrayList.size()];int size=0;for(String temp : arrayLi..." }, { "title": "[Backend] 테스트 코드 개요", "url": "/posts/%ED%85%8C%EC%8A%A4%ED%8A%B8%EC%BD%94%EB%93%9C%EA%B0%9C%EC%9A%94/", "categories": "Backend", "tags": "software-testing, test-code, tdd", "date": "2021-06-30 00:00:00 +0900", "snippet": "테스트코드를 작성해야 하는 이유 1) 잘 작동하는, 깔끔한 코드를 얻기 위해서(궁극적 목표) 테스트를 쉽게 하기 위해서는, 어플리케이션 코드를 테스트하기 쉽게 짜야됨 결국 테스트 코드를 짜기 위해 노력하다보면 코드가 깔끔해지게 됨 2) SW개발 시간의 단축 테스트 코드 작성 전 테스트 과정 1. 코드를 수정한다. 2. 서버를 동작시킨다. 3. 필요에 따라 테스트에 필요한 데이터를 DB에 입력한다. 4. 브라우저를 통해 우리의 서버에 접속하고, 테스트 ..." }, { "title": "[Backend] 쿠키와 세션", "url": "/posts/%EC%BF%A0%ED%82%A4%EC%99%80%EC%84%B8%EC%85%98/", "categories": "Backend", "tags": "cookie, session, http", "date": "2021-06-30 00:00:00 +0900", "snippet": "HTTP의 특징 일단, HTTP란 인터넷상에서 데이터를 주고 받기 위해 서버/클라이언트 모델을 따르는 통신규약이다. 서버의 자원을 절약학기 위해 모든 사용자의 요청마다 연결과 해제의 과정을 거치기 때문에 연결상태가 유지 되지 않고(비연결성-Connectionless), 연결 해제 후에 상태 정보가 저장되지 않는다(비상태성-Stateless) 하지만 웹사이트에 로그인을 한 번 하고나면 그 사이트에서는 다시 로그인할 필요 없이 여러 페이지의 기능들을 이용할 수 있고 심지어 브라우저를 종료했다가 다시 접속했을 때도 그 로그인 ..." }, { "title": "[Backend] 분산 서버 처리를 위한 기술", "url": "/posts/%EB%B6%84%EC%82%B0-%EC%84%9C%EB%B2%84-%EC%B2%98%EB%A6%AC-%EA%B8%B0%EC%88%A0/", "categories": "Backend", "tags": "distributed-server-processing", "date": "2021-06-30 00:00:00 +0900", "snippet": "1) 로드 밸런싱(Load Balancing) 부하 분산을 위해 가상 IP를 통해 각 서버에 Request를 분배하는 기능 LoadBalancer2) Scale Up, Scale Out 서버의 부하를 체크하여 서버를 늘리거나 성능을 향상 시키는 방식 스케일 업(Scale Up): 서버에 CPU나 RAM 등을 추가하여 서버의 하드웨어 스펙을 향상시키는 방법 스케일 아웃(Scale Out): 서버를 여러 대 추가하여 시스템을 증가시키는 방법 대부분의 클라우드 서비스 제공 업체들은 Auto Scaling기능을 지원3) S..." }, { "title": "[Backend] 로드 밸런서 사용 시의 이슈 중 세션 관리 문제", "url": "/posts/%EB%A1%9C%EB%93%9C-%EB%B0%B8%EB%9F%B0%EC%84%9C-%EC%82%AC%EC%9A%A9-%EC%8B%9C%EC%9D%98-%EC%9D%B4%EC%8A%88-%EC%A4%91-%EC%84%B8%EC%85%98-%EA%B4%80%EB%A6%AC-%EB%AC%B8%EC%A0%9C/", "categories": "Backend", "tags": "distributed-server-processing, loadbalancer, session, sticky-session, session clustering, redis, session-server", "date": "2021-06-30 00:00:00 +0900", "snippet": "로드 밸런서 사용 시의 이슈 중 세션 관리 문제 로드 밸런서에 의해 이전 요청과 현 요청에 분배되는 서버가 다를 경우 세션 관리 일관성에 문제가 발생한다.로드 밸런서 세션 관리 문제의 예시 1) 먼저 로그인 요청을 A서버로 보낸다. A서버의 세션에는 martin이라는 값이 저장되고 A서버에서는 로그인 성공이라는 응답을 보낸다. 2) 동일한 클라이언트는 다시 로드 밸런서에 유저 정보를 조회하는 요청을 보낸다. 3) 하지만 이 요청은 로드 밸런서를 통해 C서버로 전달되며 C 서버의 세션에는 이 사용자가 로그인 한 사용자라는..." }, { "title": "[Backend] 동기&amp;비동기&amp;block&amp;non-block", "url": "/posts/%EB%8F%99%EA%B8%B0%EC%99%80-%EB%B9%84%EB%8F%99%EA%B8%B0-%EA%B7%B8%EB%A6%AC%EA%B3%A0-blocking%EC%99%80-non-blocking/", "categories": "Backend", "tags": "synchronous, asynchronous, block, non-block", "date": "2021-06-30 00:00:00 +0900", "snippet": "동기 &amp;amp; 비동기(데이터를 받는 방식)동기(synchronous : 동시에 일어나는) 말 그대로 동시에 일어난다는 뜻 요청과 그 결과가 동시에 일어난다는 약속 바로 요청을 하면 시간이 얼마가 걸리던지 요청한 자리에서 결과가 주어져야 함 시간을 맞추는 것, 즉 요청을 하면 응답 데이터가 올때가지 기다리며 시간을 맞춤 요청과 결과가 한 자리에서 동시에 일어남 A노드와 B노드 사이의 작업 처리 단위(transaction)를 동시에 맞추겠다는 뜻 비동기(Asynchronous : ..." }, { "title": "[Backend] Semantic Versioning", "url": "/posts/SemanticVersioning/", "categories": "Backend", "tags": "versioncontrol, semantic-versioning", "date": "2021-06-30 00:00:00 +0900", "snippet": "Versioning? 소프트웨어의 패키지가 새롭게 업데이트 될 때, 생각보다 다양한 문제에 직면하게 된다. 기능의 사용법을 바꾸어버리거나 동작 방식의 변경 같은 변화들은 그에 의존하는 다른 소프트웨어를 의도대로 동작하지 못하게 하므로, 새로운 변화와 기존의 것을 구분할 필요가 생겼다. 이로 인해, 버전이라는 개념은 소프트웨어 패키지의 변화를 구분하기 위해 사용한다.Semantic versioning? 기존의 버전 명시 방법은 모든 소프트웨어마다 제 각각 미묘하게 다르다는 문제점이 있음 위의 문제점을 해결하기 위해 Git..." }, { "title": "[Backend] Refactoring(리팩토링)", "url": "/posts/Refactoring%EA%B0%9C%EC%9A%94/", "categories": "Backend", "tags": "refactoring", "date": "2021-06-30 00:00:00 +0900", "snippet": "리팩토링의 개념 소프트웨어를 보다 쉽게 이해할 수 있도록 외부 동작을 바꾸지 않으면서 내부 구조를 개선하는 방법(이해하기 쉬운 코드가 수정하기도 쉬움)리팩토링의 목적 소프트웨어를 보다 이해하기 쉽고, 수정하기 쉽도록 만드는 것리팩토링을 하는 이유 유지 보수를 쉽게 하기 위해(코드를 이해하기 쉽고, 수정하기 쉽도록 하기 위해) 이해하기 쉽기 때문에 버그가 있다면 훨씬 쉽게 발견 코드의 중복을 제거 하여 수정하는데 쉬워짐 코드의 디자인을 유지하기 좋음 프로그램을 개발 생산성을 높..." }, { "title": "[Backend] LoadBalancer(로드 밸런서)", "url": "/posts/LoadBalancer/", "categories": "Backend", "tags": "distributed-server-processing, loadbalancer", "date": "2021-06-30 00:00:00 +0900", "snippet": "로드 밸러서란? 부하 분산을 위해 가상 IP를 통해 각 서버에 Request를 분배하는 기능 즉, 대용량 트래픽을 장애없이 처라히기 위해 여러 대의 서버에 적절히 트래픽을 분배해주는 기능로드 밸런서의 예시 다음 그림과 같이 Request A~F는 로드 밸런서 알고리즘에 의해 적절하게 분배된다. 만약 라운드 로빈 방식으로 분배된다하면 다음과 같이 분배된다." }, { "title": "[Docker] Docker", "url": "/posts/Docker/", "categories": "Backend", "tags": "docker", "date": "2021-06-30 00:00:00 +0900", "snippet": "Docker도커를 사용해야 하는 이유? 수평적 확장에 편리성 (ex. 테스트 서버에서 운영서버로 작업을 하려면 단순하게 똑같이 서버를 세팅할 필요없이 Dockerfile로만 가능하기에 편리함) 서버의 견고함을 보장하면서도 컨테이너를 실행시킬때 마다 주는 환경변수를 달리 할 수 있어 운영에 있어 유연성을 가짐 여러 대에 배포 할 수 있어 편리함 도커 파일의 내용을 통해 히스토리를 공유 할 수 있어 팀원들 간의 서버 구성 내용을 공유하기에 편리함도커 파일의 내용을 통해 히스토리를 공유하는 방식 도커 파일 == 서버 운영 ..." }, { "title": "[Backend] Debugging(디버깅)", "url": "/posts/Debugging/", "categories": "Backend", "tags": "debugging", "date": "2021-06-30 00:00:00 +0900", "snippet": "디버깅이란? 디버깅의 뜻은 프로그램 실행 시 문제를 일으키는 오류, 즉 ‘버그’를 찾아 해결하는 과정을 의미한다. 이 버그는 크게 문법적 오류와 논리적 오류로 분류할 수 있다. 문법적 오류는 말 그대로 프로그래밍 언어의 문법에 맞지 않는 코드가 있을 경우 발생하며 대체로 IDE로 해결할 수 있기에 디버깅이 쉬운편이다. 논리적 오류는 문법적으로 문제가 없지만, 의도와는 맞지 않게 프로그램이 실행되는 오류이다. 이 부분은 IDE의 기능만으로는 해결되지 않으며, 프로그래머가 가장 골치아파하는 오류이다. ..." }, { "title": "[AWS-EC2] Ec2에 Chrome 및 ChromeDriver 설치", "url": "/posts/InstallChromeInCentOs/", "categories": "AWS, EC2", "tags": "aws, ec2, chrome, chromedriver", "date": "2021-06-30 00:00:00 +0900", "snippet": "Chrome 설치1) yum 저장소 생성sudo vi /etc/yum.repos.d/google-chrome.repo1-2) 아래와 같이 파일 내용작성[google-chrome]name=google-chromebaseurl=http://dl.google.com/linux/chrome/rpm/&amp;lt;br&amp;gt;stable/$basearchenabled=1gpgcheck=1gpgkey=https://dl-ssl.google.com/linux/&amp;lt;br&amp;gt;linux_signing_key.pub2) ..." }, { "title": "[AWS-EC2] Ec2에 jdk, tomcat, mysql 설치", "url": "/posts/Install-JDK-Tomcat-MySql/", "categories": "AWS, EC2", "tags": "docker, aws, ec2, jdk, tomcat, mysql", "date": "2021-06-30 00:00:00 +0900", "snippet": "ec2 기본 설정1. 키 파일의 접근권한 변경$ chmod 400 ~/Desktop/AWSkey/keyfile.pem2. 맥 터미널을 이용한 접속$ ssh -i ~/Desktop/AWSkey/keyfile.pem ec2-user@[서버 아이피 또는 도메인]&amp;lt;br&amp;gt;3. ec2 시간대 변경1) 기본 시간대 설정은 UTC로 설정되있는데 이거를 한국표준시간대로 변경해줘야함2) 적용 가능한 시간대 확인3) 시스템 표준시간대 설정 파일을 Asia/Seoul로 변경4) /etc/localtime을 해당 표준시간대 ..." }, { "title": "[AWS-EC2] Ec2에 Jenkins설치", "url": "/posts/Ec2%EC%97%90-Jenkins%EC%84%A4%EC%B9%98/", "categories": "AWS, EC2", "tags": "aws, ec2, jenkins", "date": "2021-06-30 00:00:00 +0900", "snippet": "Docker를 활용한 Jenkins설치https://dbjh.tistory.com/71" }, { "title": "[AWS-EC2] Ec2에 Docker설치", "url": "/posts/Ec2%EC%97%90-Docker%EC%84%A4%EC%B9%98/", "categories": "AWS, EC2", "tags": "docker, aws, ec2", "date": "2021-06-30 00:00:00 +0900", "snippet": "도커 설치인스턴스에 접속 후 아래 커맨드 실행[ec2-user@ip-172-31-18-132 ~]$ $ sudo yum -y upgrade[ec2-user@ip-172-31-18-132 ~]$ $ sudo yum -y install dockerDocker 설치 확인하기[ec2-user@ip-172-31-18-132 ~]$ docker -vDocker version 18.09.1, build 4c52b90Docker 시작하기[ec2-user@ip-172-31-18-132 ~]$ sudo service docker start그룹에..." }, { "title": "[개발자 블로그] Spring AOP", "url": "/posts/Spring-AOP/", "categories": "Spring, Spring AOP", "tags": "spring, aop, oop, aspect", "date": "2021-06-27 00:00:00 +0900", "snippet": "AOP란? Aspect Oriented Programming의 약자로 관점 지향 프로그래밍을 뜻함 핵심 비지니스 로직과 공통 모듈(횡단 관심사)을 분리함으로써 개발자가 좀 더 비지니스 로직에만 집중해서 처리할 수 있는 방법을 제공하는 프로그래밍 패러다임 핵심기능 관점은 위의 그림과 같이 각 Service모듈이 각각 자신만의 역할을 수행하기에 공통된 모듈을 발견할 수가 없을 것이다. 위의 그림처럼 부가기능의 관점에서 바라보면 각각의 Service는 before()메서드와 after()메서드가 공통됨을 알 수 있을 것이다...." }, { "title": "[개발자 블로그] ThreadPoolTaskExecutor", "url": "/posts/ThreadPoolTaskExecutor/", "categories": "Spring", "tags": "spring, threadpooltaskexecutor, threadpool, multi thread", "date": "2021-06-27 00:00:00 +0900", "snippet": "ThreadPoolTaskExecutor 스레드 풀을 사용하는 Executor java.util.concurrent.Executor를 Spring에서 구현한 것 org.springframework.scheduling.concurrent 패키지에서 제공 주로 spring에서 비동기처리를 위해 사용 스레드풀을 사용하여 멀티스레드 구현을 쉽게 해줌 기본 생성자 하나만 존재ConfigurationPool size configuration@Bean(&quot;simpleTas..." }, { "title": "[개발자 블로그] Spring MVC", "url": "/posts/Spring-MVC/", "categories": "Spring", "tags": "spring, springmvc, model, view, controller, maven", "date": "2021-06-27 00:00:00 +0900", "snippet": "Spring MVC란? Spring 프레임워크에서 제공하는 웹 모듈이다. MVC는 Model, View, Controller의 약자로 기본 시스템 모듈을 MVC로 나누어 구현되어있다.Model 애플리케이션 상태(data)를 나타낸다. 일반적으로 POJO로 구성된다. Java BeansView 디스플레이 데이터 또는 프리젠테이션 Model data의 렌더링을 담당하며, HTML ouput을 생성 JSP 및 Thymeleaf, Groovy, Freemarker 등 여러 Template Engine이 있다.Contro..." }, { "title": "[개발자 블로그] Spring MVC 동작 과정", "url": "/posts/Spring-MVC-%EB%8F%99%EC%9E%91-%EA%B3%BC%EC%A0%95/", "categories": "Spring", "tags": "spring, springmvc, model, view, controller, maven", "date": "2021-06-27 00:00:00 +0900", "snippet": " Spring MVC는 DispatcherServlet, View Resolver, Interceptor, Handler, View 등으로 구성되어있다. 이중에 DispatcherServlet이 가장 앞단의 front controller역할을 하며 가장 핵심적인 역할을 한다. Spring MVC의 구체적인 동작 과정은 다음과 같다. 1)DispatcherServlet이 모든 웹 브라우저로부터의 요청을 받는다. 2)DispatcherServlet은 HandlerMapping으로 부터 주어진 requ..." }, { "title": "[개발자 블로그] Spring Interceptor 개념 및 흐름", "url": "/posts/Spring-Interceptor-%EA%B0%9C%EB%85%90-%EB%B0%8F-%ED%9D%90%EB%A6%84/", "categories": "Spring", "tags": "spring, aop, oop, aspect", "date": "2021-06-27 00:00:00 +0900", "snippet": "Spring Request FlowFilter 사용자의 어떠한 요청이 있을 경우, 가장 앞단에서 거치는 곳. 예를 들어, UTF-8 인코딩을 처리하는 기본 필터 중에 CharacterEncodingFilter를 호출 할 수 있다. Spring MVC 기준으로 web.xml에서 설정DispatcherServlet 서블릿과 마찬가지로 Java 구성 또는 web.xml을 사용하여 서블릿 규격에 따라 선언 및 매핑한다. 그 다음, DispatcherServlet은 Spring Config를 사용하여 Requset Mapping..." }, { "title": "[개발자 블로그] Spring Annotation 활성화", "url": "/posts/Spring-Annotation-%ED%99%9C%EC%84%B1%ED%99%94/", "categories": "Spring", "tags": "spring, springboot, annotation", "date": "2021-06-27 00:00:00 +0900", "snippet": "Annotation 기본 개념 xml 설정이 너무 길어짐에 따라 그 대안으로 생겨났다. 클래스/메서드/필드에 Annotation을 달아 그 자체로 설정이 가능하도록 한다.(단, xml의 우선순위가 더 높음) 기본적으로 활성화되지 않기 때문에 xml에 명시적인 활성화 설정이 필요하다.(IDE에서 체크하면 자동으로 추가되도록 지원)Annotation 활성화Configurtion with Java@Configuration@EnableWebMvc@ComponentScan(&quot;package-name&quot;)public ..." }, { "title": "[개발자 블로그] ContextLoaderListener와 DispatcherServlet의 차이", "url": "/posts/ContextLoaderListener%EC%99%80-DispatcherServlet%EC%9D%98-%EC%B0%A8%EC%9D%B4/", "categories": "Spring", "tags": "spring, springboot, contextloaderlistener, dispatcherservlet", "date": "2021-06-27 00:00:00 +0900", "snippet": "ContextLoaderListener와 DispatcherServlet의 차이 ContextLoaderListener와 DispatcherServlet 모두 자체적으로 스프링 컨테이너를 만듬 ContextLoaderListener안에 있는 Bean들은 shared beans(공유하는 bean들 - DAO, DataSource, Service) DispatcherServlet안에 있는 bean들은 requset가 왔을때 처리하는 컨트롤러를 주로 가지고 있음 나중에 war파일로 패키징하게 되면 webapp이 root가 ..." }, { "title": "[개발자 블로그] @Bean vs @Component", "url": "/posts/@Bean-vs-@Component/", "categories": "Spring", "tags": "spring, springboot, annotation, bean, component", "date": "2021-06-27 00:00:00 +0900", "snippet": "@Bean 어노테이션 개발자가 컨트롤이 불가능한 외부 라이브러리들을 Bean으로 등록하고 싶은 경우에 사용한다. 예를 들어, RestTemplate 등@Component 어노테이션 직접 컨트롤이 가능한 Class들을 Bean으로 등록하고 싶은 경우에 사용한다.개발자가 생성한 Class에 @Bean은 설정이 가능한가? 불가능하다. @Bean과 Component는 각자 선언할 수 있는 타입이 정해져 있어 해당 용도외에는 컴파일 에러를 발생시킨다.출처 https://jojoldu.tistory.com/27" }, { "title": "[Backend] 카나리 배포", "url": "/posts/%EC%B9%B4%EB%82%98%EB%A6%AC%EB%B0%B0%ED%8F%AC/", "categories": "Backend", "tags": "deploy, canari", "date": "2021-06-24 17:00:00 +0900", "snippet": "운영중인 서비스에 새로운 버전을 배포할 때 이상적인 방법으로 카나리 배포를 알게 되었다. 수 많은 클라이언트들이 사용중인 상황에서 배포하는 가장 이상적인 방법이라 한다.카나리 배포는 흔히 단계별 배포 또는 점진적 배포라 불리었다. 기존 서버로 들어오는 트래픽을 10%, 20%, 30% 조금씩 신규 서버로 옮긴다. 조금씩 트래픽을 옮기면서 이슈 사항이 있는지 확인하며 문제가 발생한다면 쉽게 롤백할 수 있다.카나리 배포와 A/B테스팅을 구현하는 하나의 방법이 될 수 있지만 둘은 다른 개념이다. 카나리 배포는 조금씩 트래픽을 옮기며..." }, { "title": "[개발자 블로그] 스프링 의존성 주입과 인터페이스", "url": "/posts/%EC%8A%A4%ED%94%84%EB%A7%81-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%A3%BC%EC%9E%85%EA%B3%BC-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4/", "categories": "Spring, Spring DI", "tags": "spring, di, interface, ocp", "date": "2021-06-24 16:00:00 +0900", "snippet": "Spring을 활용하여 개발하면서 꼭 인터페이스 타입으로 의존성을 주입받아야 하는지에 대해 생각해보게 되었다.(CustomerService인터페이스를 만들고 CustomerServiceImpl을 구현한 후 인터페이스 타입으로 주입받는 것 처럼)SOLID원칙 중 OCP에 따르면 변화에 유연하게 대처할 수 있도록 인터페이스 타입으로 주입 받는 것이 맞지만 쓸데없이 클래스가 많아지고 코드만 복잡해지는게 아닌가 하는 생각이 들었다. 구글링을 통해 다른 사람들의 의견을 찾아보며 아래의 글을 읽어보게 되었다. 스프링 의존 주입(DI)과..." }, { "title": "[Java] 반복문 작성 시 안 좋은 습관", "url": "/posts/%EB%B0%98%EB%B3%B5%EB%AC%B8-%EC%9E%91%EC%84%B1-%EC%8B%9C-%EC%95%88-%EC%A2%8B%EC%9D%80-%EC%8A%B5%EA%B4%80/", "categories": "Backend, Java", "tags": "java, forloop, foreach", "date": "2021-06-24 15:00:00 +0900", "snippet": "반복문을 작성할 때 안 좋은 습관1) 불필요하게 조건문에 함수 호출문을 넣는 습관public void example(List&amp;lt;Integer&amp;gt; numbers) { for (int i = 0; i &amp;lt; numbers.size(); i++) { ... }}만약 위처럼 코드를 작성하고 numbers의 사이즈가 10만개라 가정한다면 numbers.size()메소드를 불필요하게 10만번 호출하게 될 것이다. 그래서 대량의 데이터를 순회하고자 한다면 아래와 같이 리팩토링을 할 수가..." }, { "title": "[Java] 반복문(for문 forEach문 비교)", "url": "/posts/%EB%B0%98%EB%B3%B5%EB%AC%B8(for%EB%AC%B8-forEach%EB%AC%B8-%EB%B9%84%EA%B5%90)/", "categories": "Backend, Java", "tags": "java, forloop, foreach", "date": "2021-06-24 14:00:00 +0900", "snippet": "프로그래밍을 배우는데 있어서 기본 중의 하나는 반복문이다. 하지만 반복문을 어떻게 사용하느냐가 애플리케이션 성능에 얼마나 영향을 끼치는지 생각을 해보게되었다. Java에서 Collection을 순환할 때 forEach문을 자연스레 사용하고 있었고, 일반 for문하고 가독성 외에는 성능적으로 차이가 없을거라 생각했다. 하지만 for문과 forEach문은 완전 다른 방식으로 작동하고 있으며, 성능적으로 큰 차이가 있었다.for-each(Enhanced for)JDK5.0부터 지원하며 아래 코드와 같이 형변환이나 get메소드 호출 ..." }, { "title": "[개발자 블로그] Spring Framework", "url": "/posts/Spring-Framework/", "categories": "Spring", "tags": "spring, di, aop, pojo, ioc", "date": "2021-06-23 14:00:00 +0900", "snippet": "Framework란? “소프트웨어의 구체적인 부분에 해당하는 설계와 구현을 재사용이 가능하게끔 일련의 협업화된 형태로 클래스들을 제공하는 것” - 랄프 존슨(Ralph Johnson) - 말 그대로 뼈대나 근간을 이루는 코드들을 묶어놓은 것프레임워크는 반제품으로 애플리케이션 구조 및 코드의 상당 부분을 제공하여 개발자는 핵심 비즈니스로직에만 집중할 수 있다.Framework의 장점 1)생산성 Framework가 소프트웨어의 구조 및 기반이 되는 클래스를 제공하기에 개발자는 비즈니스 로직에만 집중할 수 있기..." }, { "title": "[Jekyll] 포스팅 md 문법", "url": "/posts/%ED%8F%AC%EC%8A%A4%ED%8C%85-md-%EB%AC%B8%EB%B2%95/", "categories": "Jekyll", "tags": "blog, jekyll, github", "date": "2021-06-21 19:00:00 +0900", "snippet": "Imgae width and location width 50 and normal width 100 and left width 150 and right Image CaptionImage CaptionCode BlockThis is a common code snippet, without syntax highlight and line number.class Main { public static void main(String[] args) { System.out.println(&q..." }, { "title": "[Jekyll] Jekyll 을 이용한 깃허브 블로그 관련 유용한 참고 사이트", "url": "/posts/Jekyll-%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EA%B9%83%ED%97%88%EB%B8%8C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EA%B4%80%EB%A0%A8-%EC%9C%A0%EC%9A%A9%ED%95%9C-%EC%B0%B8%EA%B3%A0-%EC%82%AC%EC%9D%B4%ED%8A%B8/", "categories": "Jekyll", "tags": "blog, jekyll, github", "date": "2021-06-21 18:00:00 +0900", "snippet": "Jekyll 블로그 구축하기 https://j1mmyson.github.io/categories/blog/ https://seungwubaek.github.io/blog/#wholetoc__title https://ip99202.github.io/posts/%EA%B9%83%ED%97%88%EB%B8%8C-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%8C%93%EA%B8%80%EA%B8%B0%EB%8A%A5-%EC%B6%94%EA%B0%80%ED%95%98%EA%B8%B0/ https://www.jihyel..." }, { "title": "[OOP] OOP의 핵심", "url": "/posts/OOP%ED%95%B5%EC%8B%AC/", "categories": "CS, OOP", "tags": "oop", "date": "2021-06-21 18:00:00 +0900", "snippet": " OOP는 상속 때문에 쓰는게 아니다(상속 쓸 일은 거의 없다) ‘객체 간에 메시지를 어떻게 주고 받을거냐, 역할과 책임을 어떻게 나눠줄거냐’가 사실은 OOP의 핵심이다 도메인을 어떻게 관리할거냐가 사실 지금은 제일 핵심이며 도메인과 역할과 책임에 대해서는 꼭 익혀두자" }, { "title": "[Jekyll] liquid syntax error 해결하는 법", "url": "/posts/liquid-syntax-error-%ED%95%B4%EA%B2%B0/", "categories": "Jekyll", "tags": "blog, jekyll, github", "date": "2021-06-21 01:00:00 +0900", "snippet": "포스팅을 작성 후 push 를 했으나 빌드하는 과정에서 다음과 같은 liquid syntax error 가 발생하였다. 구글을 통해 쉽게 원인과 해결책을 찾아내어 해결할 수 있었다.원인Jekyll에서 사용되는 liquid는 {{와 }} 를 escape 문자로 사용하는데, md문서에 {{, }} 가 있는 경우 에러 메시지를 출력하기 때문이다.해결 방법위 이미지 같이 여는 중괄호가 시작하기 전에 raw를, 뒤에는 endraw를 추가하면 된다.출처 https://iamheesoo.github.io/blog/gitblog-sol-j..." }, { "title": "[Jekyll] Jekyll 블로그 포스팅 템플릿", "url": "/posts/%ED%8F%AC%EC%8A%A4%ED%8C%85-%ED%85%9C%ED%94%8C%EB%A6%BF/", "categories": "개발환경, Jekyll", "tags": "blog, jekyll, github", "date": "2021-06-21 01:00:00 +0900", "snippet": "" } ]
