<!DOCTYPE html><html lang="ko" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="[이펙티브자바] 아이템10-equals는 일반 규약을 지켜 재정의하라" /><meta name="author" content="jeonyoungho" /><meta property="og:locale" content="ko" /><meta name="description" content="equals 메서드를 재정의 하지 않을 때는 언제인가? equals 메서드는 재정의하기 쉬워보이지만 곳곳에 함정이 도사리고 있음, 그러기에 자칫 하면 끔찍한 결과를 초래 문제를 회피하는 방법은 아예 재정의하지 않는 것, 그 클래스의 인스턴스는 오직 자기 자신과만 같게됨 그게 언제일까?" /><meta property="og:description" content="equals 메서드를 재정의 하지 않을 때는 언제인가? equals 메서드는 재정의하기 쉬워보이지만 곳곳에 함정이 도사리고 있음, 그러기에 자칫 하면 끔찍한 결과를 초래 문제를 회피하는 방법은 아예 재정의하지 않는 것, 그 클래스의 인스턴스는 오직 자기 자신과만 같게됨 그게 언제일까?" /><link rel="canonical" href="https://jeonyoungho.github.io/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C10-equals%EB%8A%94-%EC%9D%BC%EB%B0%98-%EA%B7%9C%EC%95%BD%EC%9D%84-%EC%A7%80%EC%BC%9C-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/" /><meta property="og:url" content="https://jeonyoungho.github.io/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C10-equals%EB%8A%94-%EC%9D%BC%EB%B0%98-%EA%B7%9C%EC%95%BD%EC%9D%84-%EC%A7%80%EC%BC%9C-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/" /><meta property="og:site_name" content="Youngho’s Devlog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-06-05T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[이펙티브자바] 아이템10-equals는 일반 규약을 지켜 재정의하라" /><meta name="twitter:site" content="@jeonyoungho_o" /><meta name="twitter:creator" content="@jeonyoungho" /><meta name="google-site-verification" content="eonGeSiIVfF48EnFoJqakC7h2hUzgqxFNJaxkfPiGr0" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"jeonyoungho"},"dateModified":"2022-06-05T00:00:00+09:00","datePublished":"2022-06-05T00:00:00+09:00","description":"equals 메서드를 재정의 하지 않을 때는 언제인가? equals 메서드는 재정의하기 쉬워보이지만 곳곳에 함정이 도사리고 있음, 그러기에 자칫 하면 끔찍한 결과를 초래 문제를 회피하는 방법은 아예 재정의하지 않는 것, 그 클래스의 인스턴스는 오직 자기 자신과만 같게됨 그게 언제일까?","headline":"[이펙티브자바] 아이템10-equals는 일반 규약을 지켜 재정의하라","mainEntityOfPage":{"@type":"WebPage","@id":"https://jeonyoungho.github.io/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C10-equals%EB%8A%94-%EC%9D%BC%EB%B0%98-%EA%B7%9C%EC%95%BD%EC%9D%84-%EC%A7%80%EC%BC%9C-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/"},"url":"https://jeonyoungho.github.io/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C10-equals%EB%8A%94-%EC%9D%BC%EB%B0%98-%EA%B7%9C%EC%95%BD%EC%9D%84-%EC%A7%80%EC%BC%9C-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/"}</script><title>[이펙티브자바] 아이템10-equals는 일반 규약을 지켜 재정의하라 | Youngho's Devlog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Youngho's Devlog"><meta name="application-name" content="Youngho's Devlog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-RF6ZGDWXV1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-RF6ZGDWXV1'); }); </script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5958719204143086" crossorigin="anonymous"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/youngho_employee_pic.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Youngho's Devlog</a></div><div class="site-subtitle font-italic">curios developer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/jeonyoungho" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/jeonyoungho_o" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['yhjun1000','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>[이펙티브자바] 아이템10-equals는 일반 규약을 지켜 재정의하라</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"> <ins class="adsbygoogle" style="display:block; margin-top: 30px;" data-ad-client="ca-pub-5958719204143086" data-ad-slot="1982371670" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[이펙티브자바] 아이템10-equals는 일반 규약을 지켜 재정의하라</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> jeonyoungho </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Jun 5, 2022, 12:00 AM +0900" prep="on" > Jun 5, 2022 <i class="unloaded">2022-06-05T00:00:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="6668 words">37 min</span></div></div><div class="post-content"><h1 id="equals-메서드를-재정의-하지-않을-때는-언제인가">equals 메서드를 재정의 하지 않을 때는 언제인가?</h1><ul><li>equals 메서드는 재정의하기 쉬워보이지만 곳곳에 함정이 도사리고 있음, 그러기에 자칫 하면 끔찍한 결과를 초래<li>문제를 회피하는 방법은 아예 재정의하지 않는 것, 그 클래스의 인스턴스는 오직 자기 자신과만 같게됨<li>그게 언제일까?</ul><h2 id="1-각-인스턴스가-본질적으로-고유-할-때">1) 각 인스턴스가 본질적으로 고유 할 때</h2><ul><li>값을 표현하는게 아니라 동작하는 객체를 표현하는 클래스<li><code class="language-plaintext highlighter-rouge">Thread</code>가 좋은 예시<li>Sprint 에서 Service 객체 또한 이에 해당할 것 같다.</ul><h2 id="2-인스턴스의-논리적-동치성logical-equality을-검사할-일이-없을-때">2) 인스턴스의 논리적 동치성(logical equality)을 검사할 일이 없을 때</h2><ul><li><code class="language-plaintext highlighter-rouge">java.util.regex.Pattern</code> 은 equals를 재정의해서 두 Pattern 인스턴스가 같은 정규표현식을 나타내는지를 검사하도록, 즉 논리적 동치성을 검사하는 방법도 있지만 설계자는 애초에 필요없다고 판단해서 재정의하지 않았다.</ul><p><img width="598" alt="스크린샷 2022-06-05 오후 4 19 08" src="https://user-images.githubusercontent.com/44339530/172040107-312ee1cc-9d13-4630-ba8a-3031c2e78673.png" /></p><h2 id="3-상위-클래스에서-재정의한-equals가-하위-클래스에도-딱-들어맞을-때">3) 상위 클래스에서 재정의한 equals가 하위 클래스에도 딱 들어맞을 때</h2><ul><li>Set 구현체는 AbstractSet 이 구현한 equals를 상속받아 쓰고, List 구현체들은 AbstractList 로부터, Map은 AbstractMap으로부터 상속받아 그대로 사용해도 문제가 없을 때 굳이 재정의할 필요가 없다.</ul><h2 id="4-클래스가-private-이거나-package-private이고-equals메서드를-호출할-일이-없을-때">4) 클래스가 private 이거나 package-private이고 equals메서드를 호출할 일이 없을 때</h2><ul><li>실수라도 호출되는 것을 막고 싶다면 아래와 같이 구현해두자.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>
<span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">throw</span> <span class="k">new</span> <span class="nf">AssertionError</span><span class="o">();</span> <span class="c1">// 호출 금지!</span>
<span class="o">}</span>

</pre></table></code></div></div><h1 id="equals-메서드를-재정의해야-할-때는-언제인가">equals 메서드를 재정의해야 할 때는 언제인가?</h1><ul><li>객체 식별성(object identity; 두 객체가 물리적으로 같은가)이 아니라 논리적 동치성을 확인해야 하는데, 상위 클래스의 equals가 논리적 동치성을 비교하도록 재정의 되지 않을 때<ul><li>주로 값 클래스들이 여기 해당함<li><code class="language-plaintext highlighter-rouge">값 클래스</code> 란 Integer와 String처럼 값을 표현하는 클래스를 말한다.<li>두 값 객체를 비교하고자 할 땐 값이 같은지를 알고 싶어할 것이다.</ul><li>값 클래스라 해도, 값이 같은 인스턴스가 둘 이상 만들어지는지 않음을 보장하는 인스턴스 통제 클래스라면 equals를 재정의하지 않아도 된다.<ul><li>enum도 여기에 해당한다.<li>인스턴스가 2개 이상 만들어지지 않으니 논리적 동치성과 객체 식별성이 사실상 똑같은 의미가 된다.</ul></ul><h1 id="equals-메서드를-재정의할때-따라야-하는-규약">equals 메서드를 재정의할때 따라야 하는 규약</h1><ul><li><code class="language-plaintext highlighter-rouge">반사성</code> : null이 아닌 모든 참조 값 x에 대해, x.equals(y)는 true다.<li><code class="language-plaintext highlighter-rouge">대치성</code> : null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)가 true면 y.equals(x)도 true다.<li><code class="language-plaintext highlighter-rouge">추이성</code> : null이 아닌 모든 참조 값 x,y,z에 대해 x.equals(y)가 true이고 y.equals(z)도 true이면 x.equals(z)도 true이다.<li><code class="language-plaintext highlighter-rouge">일관성</code> : null이 아닌 모든 참조 값 x,y에 대해 x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.<li><code class="language-plaintext highlighter-rouge">null 아님</code> : null이 아닌 모든 참조 값 x에 대해 x.equals(null)은 false다.</ul><p>위 규약을 어기면 프로그램이 이상하게 동작하거나 종료될 것이다. 예컨데, Set과 Map을 사용할때 처럼… 컬렉션 클래스들을 포함해 수 많은 클래스는 전달받은 객체가 equals 규약을 지킨다 가정하고 동작하기 때문이다.</p><p>Object에서 말하는 동치 관계란 무엇일까? 쉽게 말해, 집합을 서로 같은 원소들로 이뤄진 부분집합으로 나누는 연산이다. 이 부분집합을 동치류(동치 클래스)라 한다. 모든 원소가 같은 동치류에 속한 어떤 원소와도 서로 교환할 수 있어야 한다. 동치 관계를 만족시키기 위한 다섯 요건을 자세히 다뤄보자.</p><p>위 규약 중에서 <code class="language-plaintext highlighter-rouge">대칭성</code>, <code class="language-plaintext highlighter-rouge">추이성</code>, <code class="language-plaintext highlighter-rouge">일관성</code>만 주목하자. <code class="language-plaintext highlighter-rouge">반사성</code>과 <code class="language-plaintext highlighter-rouge">null이 아님</code> 은 문제되는 경우가 별로 없다.</p><h2 id="1-반사성--null이-아닌-모든-참조-값-x에-대해-xequalsy는-true다">1) 반사성 : null이 아닌 모든 참조 값 x에 대해, x.equals(y)는 true다.</h2><ul><li>객체는 자기 자신과 같아야 한다.<li>일부러 어기는 경우가 아니라면 만족시키지 못하기가 더 어려워 보인다.<li>이 요건을 어긴 클래스의 인스턴스를 컬렉션에 넣은 다음 contains 메서드를 호출하면 방금 넣은 인스턴스가 없다고 답할 것이다.</ul><p>AbstractList의 contains 메서드는 아래와 같이 구현되어 있다.</p><p><img width="652" alt="스크린샷 2022-06-05 오후 4 49 36" src="https://user-images.githubusercontent.com/44339530/172040958-a4f65d13-d1d3-4d56-a8c3-2375b67532f9.png" /></p><ul><li>그리고 Product 클래스의 equals를 override하여 자기 자신과 같지 않도록 억지로 바꿔보았다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">price</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Product</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">price</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">price</span> <span class="o">=</span> <span class="n">price</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">o</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">getClass</span><span class="o">()</span> <span class="o">!=</span> <span class="n">o</span><span class="o">.</span><span class="na">getClass</span><span class="o">())</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Product</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">price</span> <span class="o">==</span> <span class="n">product</span><span class="o">.</span><span class="na">price</span> <span class="o">&amp;&amp;</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">product</span><span class="o">.</span><span class="na">name</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">hash</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">price</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>실제 테스트 코드를 아래와 같이 실행해보니 당연히 같은 인스턴스가 없다고 나오게 되었따.</p><p><img width="754" alt="스크린샷 2022-06-05 오후 4 51 57" src="https://user-images.githubusercontent.com/44339530/172041035-0250f4e4-45c6-407c-9331-9328739721a4.png" /></p><h2 id="2-대치성--null이-아닌-모든-참조-값-x-y에-대해-xequalsy가-true면-yequalsx도-true다">2) 대치성 : null이 아닌 모든 참조 값 x, y에 대해 x.equals(y)가 true면 y.equals(x)도 true다.</h2><ul><li>두 객체는 서로에 대한 동치 여부에 똑같이 답해야 한다.</ul><p>대소문자를 구별하지 않는 문자열을 구현한 다음 클래스를 예로 살펴보자.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// 코드 10-1 잘못된 코드 - 대칭성 위배! (54-55쪽)</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">CaseInsensitiveString</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">s</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">CaseInsensitiveString</span><span class="o">(</span><span class="nc">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">s</span> <span class="o">=</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 대칭성 위배!</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">CaseInsensitiveString</span><span class="o">)</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">(</span>
                    <span class="o">((</span><span class="nc">CaseInsensitiveString</span><span class="o">)</span> <span class="n">o</span><span class="o">).</span><span class="na">s</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">String</span><span class="o">)</span>  <span class="c1">// 한 방향으로만 작동한다!</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="na">equalsIgnoreCase</span><span class="o">((</span><span class="nc">String</span><span class="o">)</span> <span class="n">o</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
    <span class="o">}</span>

	<span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">CaseInsensitiveString</code>의 equals는 순진하게 일반 문자열과도 비교를 시도한다. 다음처럼 CaseInsensitiveString과 일반 String 객체가 하나 있다고 했을때 대칭성을 위반하게 된다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="nc">CaseInsensitiveString</span> <span class="n">cis</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CaseInsensitiveString</span><span class="o">(</span><span class="s">"Polish"</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">s</span> <span class="o">=</span> <span class="s">"polish"</span><span class="o">;</span>

<span class="n">cis</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">s</span><span class="o">);</span> <span class="c1">// true</span>
<span class="n">s</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">cis</span><span class="o">);</span> <span class="c1">// false</span>

</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">s.equals(cis)</code>를 호출시 false가 리턴되는 것은 당연히 String 객체는 <code class="language-plaintext highlighter-rouge">CaseInsensitiveString</code>의 존재를 모르기 때문이다. <code class="language-plaintext highlighter-rouge">CaseInsensitiveString</code>을 컬렉션에 넣고 contains 메서드를 호출할때도 false를 반환하게 될 것이다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nc">List</span><span class="o">&lt;</span><span class="nc">CaseInsensitiveString</span><span class="o">&gt;</span> <span class="n">list</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="n">list</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">cis</span><span class="o">);</span>

<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">list</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">s</span><span class="o">));</span>
</pre></table></code></div></div><p><b>이처럼 equals 규약을 어기면 그 객체를 사용하는 다른 객체들이 어떻게 반응할지 알 수 없다.</b></p><p>이 문제를 해결하기 위해 CaseInsensitiveString의 equals를 String과도 연동하자는 허황된 꿈은 버리자..</p><h2 id="3-추이성--null이-아닌-모든-참조-값-xyz에-대해-xequalsy가-true이고-yequalsz도-true이면-xequalsz도-true이다">3) 추이성 : null이 아닌 모든 참조 값 x,y,z에 대해 x.equals(y)가 true이고 y.equals(z)도 true이면 x.equals(z)도 true이다.</h2><ul><li>첫 번쨰 객체와 두 번쨰 객체가 같고, 두 번쨰 객체와 세 번쨰 객체가 같다면, 첫 번째 객체와 세 번째 객체도 같아야 한다.<ul><li>삼단논법..???을 생각하면 이해하기 쉽다.</ul><li>간단하면서도 어기기 쉬운 규약이다. 상위 클래스에는 없는 새로운 필드를 하위 클래스에 추가하는 상황을 생각해보자.<li>equals 비교에 영향을 주는 정보를 추가한 것이다.</ul><p>간단히 2차원에서의 점을 표현하는 클래스를 예로 들어보자.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c1">// 단순한 불변 2차원 정수 점(point) 클래스 (56쪽)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">x</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">y</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Point</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">y</span> <span class="o">=</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Point</span><span class="o">))</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="nc">Point</span> <span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Point</span><span class="o">)</span><span class="n">o</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">x</span> <span class="o">==</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">y</span> <span class="o">==</span> <span class="n">y</span><span class="o">;</span>
    <span class="o">}</span>

<span class="o">}</span>
</pre></table></code></div></div><p>이제 이 클래스를 확장해서 점에 색상을 더해보자.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c1">// Point에 값 컴포넌트(color)를 추가 (56쪽)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ColorPoint</span> <span class="kd">extends</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Color</span> <span class="n">color</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ColorPoint</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="nc">Color</span> <span class="n">color</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="n">color</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 코드 10-2 잘못된 코드 - 대칭성 위배! (57쪽)</span>
    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">ColorPoint</span><span class="o">))</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="nc">ColorPoint</span><span class="o">)</span> <span class="n">o</span><span class="o">).</span><span class="na">color</span> <span class="o">==</span> <span class="n">color</span><span class="o">;</span>
    <span class="o">}</span>

	<span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><p>equals 메서드는 어떻게 해야 할까? 그대로 둔다면 Point의 구현이 상속되어 색상 정보는 무시한 채 비교를 수행한다. equals 규약을 어긴 것은 아니지만, 중요한 정보를 놓치게 되니 받아들일 수 없는 사오항이다. 다음 코드처럼 비교 대상이 또 다른 ColorPoint이고 위치와 색상이 같은 때만 true를 반환하는 equals를 생각해보자.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// 코드 10-2 잘못된 코드 - 대칭성 위배! (57쪽)</span>
<span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">ColorPoint</span><span class="o">))</span>
		<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
	<span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="nc">ColorPoint</span><span class="o">)</span> <span class="n">o</span><span class="o">).</span><span class="na">color</span> <span class="o">==</span> <span class="n">color</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>이 메서드는 일반 Point를 ColorPoint에 비교한 결과와 그 둘을 바꿔 비교한 결과가 다를 수 잇다. Point의 equals는 색상을 무시하고, ColorPoint의 equals는 입력 매개변수의 클래스 종류가 다르다면 매번 false만 반환할 것이다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="c1">// 첫 번째 equals 메서드(코드 10-2)는 대칭성을 위배한다. (57쪽)</span>
        <span class="nc">Point</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
        <span class="nc">ColorPoint</span> <span class="n">cp</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ColorPoint</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="na">RED</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="n">p</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">cp</span><span class="o">)</span> <span class="o">+</span> <span class="s">" "</span> <span class="o">+</span> <span class="n">cp</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">p</span><span class="o">));</span> <span class="c1">// 두 연산의 결과가 다르게 된다!!!</span>
<span class="o">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">p.equals(cp)</code>는 true, <code class="language-plaintext highlighter-rouge">cp.equals(p)</code>는 false를 반환한다. 그렇다면 ColorPoint.equals가 Point와 비교할땐 색상을 무시하도록 하면 해결될까?</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">// 코드 10-3 잘못된 코드 - 추이성 위배! (57쪽)</span>
<span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">Point</span><span class="o">))</span>
		<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>

	<span class="c1">// o가 일반 Point면 색상을 무시하고 비교한다.</span>
	<span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">ColorPoint</span><span class="o">))</span>
		<span class="k">return</span> <span class="n">o</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>

	<span class="c1">// o가 ColorPoint면 색상까지 비교한다.</span>
	<span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">o</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="o">((</span><span class="nc">ColorPoint</span><span class="o">)</span> <span class="n">o</span><span class="o">).</span><span class="na">color</span> <span class="o">==</span> <span class="n">color</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>이 방식은 대칭성은 지켜주지만, 추이성을 깨버린다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// 두 번째 equals 메서드(코드 10-3)는 추이성을 위배한다. (57쪽)</span>
<span class="nc">ColorPoint</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ColorPoint</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="na">RED</span><span class="o">);</span>
<span class="nc">Point</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">);</span>
<span class="nc">ColorPoint</span> <span class="n">p3</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ColorPoint</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="nc">Color</span><span class="o">.</span><span class="na">BLUE</span><span class="o">);</span>
<span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">printf</span><span class="o">(</span><span class="s">"%s %s %s%n"</span><span class="o">,</span> <span class="n">p1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">p2</span><span class="o">),</span> <span class="n">p2</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">p3</span><span class="o">),</span> <span class="n">p1</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">p3</span><span class="o">));</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">p1.equals(p2)</code>와 <code class="language-plaintext highlighter-rouge">p2.equals(p3)</code>는 true를 반환하지만, <code class="language-plaintext highlighter-rouge">p1.equals(p3)</code>는 false 를 반환한다. <b>추이성을 명백히 위배한다.</b> p1과 p2, p2와 p3에선 색상을 무시했지만 p1과 p3비교에선 색상까지 고려했기 때문이다.</p><p>또한 이 방식은 무한 재귀에 빠질 위험도 있다. Point의 또 다른 하위 클래스로 SmellPoint를 만들고, equals는 같은 방식으로 구현했다고 해보자. 그런 다음 myColorPoint.equals(mySmellPoint)를 호출하면 StackOverflowError를 일으킬 것이다. <b>이 설명만 보면 이해가 쉽지 않을 텐데 아래 코드에서보면 target객체의 equals를 계속 서로 호출할 것이기 떄문이다.</b></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c1">// o가 일반 Point면 색상을 무시하고 비교한다.</span>
<span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">ColorPoint</span><span class="o">))</span>
	<span class="k">return</span> <span class="n">o</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
</pre></table></code></div></div><p>해법은 무엇일까? 사실 이 현상은 모든 객체 지향 언어의 동치 관계에서 나타나는 근본적인 문제이다. <b>구체 클래스를 확장해 새로운 값을 추가하면서 equals 규약을 만족시킬 방법은 존재하지 않는다.</b> 객체 지향적 추상화의 이점을 포기하지 않는 한은 말이다.</p><p>이 말은 얼핏, equals 안의 instanceof 검사를 getClass 검사로 바꾸면 규약도 지키고 값도 추가하면서 구채 클래스를 상속할 수 있다는 뜻으로 들린다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">o</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">!==</span> <span class="n">getClass</span><span class="o">())</span> <span class="o">{</span>
		<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="nc">Point</span> <span class="n">p</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Point</span><span class="o">)</span> <span class="n">p</span><span class="o">;</span>
	<span class="k">return</span> <span class="n">p</span><span class="o">.</span><span class="na">x</span> <span class="o">==</span> <span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">.</span><span class="na">y</span> <span class="o">==</span> <span class="n">y</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><p>이번 equals는 같은 구현 클래스의 객체와(ColorPoint) 비교할 때만 true를 반환한다. 괜찮아 보이지만 실제로 활용할 순 없다. <b>왜냐? LSP(리스코프 치환 원칙)를 위반하기 때문이다.</b> LSP에 따르면 Point의 하위 클래스는 정의상 여전히 Point이므로 어디서든 Point로써 활용될 수 있어야 한다를 설명하고 있다.</p><p>Point의 하위 클래스는 정의상 여전히 Point이므로 어디서든 Point로써 활요오딜 수 있어야 한다. 그런데 이 방식에서는 그렇지 못하다.</p><p>예를 들어, 주어진 점이 (반지름이 1인) 단위 원 안에 있는지를 판별하는 메서드가 필요하다고 해보자.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// CounterPoint를 Point로 사용하는 테스트 프로그램</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CounterPointTest</span> <span class="o">{</span>
<span class="c1">// 단위 원 안의 모든 점을 포함하도록 unitCircle을 초기화한다. (58쪽)</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Point</span><span class="o">&gt;</span> <span class="n">unitCircle</span> <span class="o">=</span> <span class="nc">Set</span><span class="o">.</span><span class="na">of</span><span class="o">(</span>
		<span class="k">new</span> <span class="nf">Point</span><span class="o">(</span> <span class="mi">1</span><span class="o">,</span>  <span class="mi">0</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span> <span class="mi">0</span><span class="o">,</span>  <span class="mi">1</span><span class="o">),</span>
		<span class="k">new</span> <span class="nf">Point</span><span class="o">(-</span><span class="mi">1</span><span class="o">,</span>  <span class="mi">0</span><span class="o">),</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span> <span class="mi">0</span><span class="o">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">));</span>

<span class="kd">public</span> <span class="kd">static</span> <span class="kt">boolean</span> <span class="nf">onUnitCircle</span><span class="o">(</span><span class="nc">Point</span> <span class="n">p</span><span class="o">)</span> <span class="o">{</span>
	<span class="k">return</span> <span class="n">unitCircle</span><span class="o">.</span><span class="na">contains</span><span class="o">(</span><span class="n">p</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>그리고 이제 값을 추가하지 않는 방식으로 point를 확장해보자. <code class="language-plaintext highlighter-rouge">AtomicInteger</code>를 이용하여 만들어진 인스턴스의 개수를 생성자에서 세보도록 하자.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>
<span class="c1">// Point의 평범한 하위 클래스 - 값 컴포넌트를 추가하지 않았다. (59쪽)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CounterPoint</span> <span class="kd">extends</span> <span class="nc">Point</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="nc">AtomicInteger</span> <span class="n">counter</span> <span class="o">=</span>
            <span class="k">new</span> <span class="nf">AtomicInteger</span><span class="o">();</span>

    <span class="kd">public</span> <span class="nf">CounterPoint</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
        <span class="n">counter</span><span class="o">.</span><span class="na">incrementAndGet</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span> <span class="nf">numberCreated</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">counter</span><span class="o">.</span><span class="na">get</span><span class="o">();</span> <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>그런데 CounterPoint의 인스턴스를 <code class="language-plaintext highlighter-rouge">onUnitCircle</code> 메서드에 넘기면 false를 반환할 것이다. <b>왜 그럴까? 컬렉션 구현체에서 주어진 원소를 담고 있는지를 확인할때 equals메서드를 활용하는데 구체 클래스가 다르기 때문이다!</b></p><h3 id="해결법-상속-대신-컴포지션조합을-활용하라">해결법: 상속 대신 컴포지션(조합)을 활용하라.</h3><p>Point를 상속하는 대신 Point를 ColorPoint의 private필드로 두고, ColorPoint와 같은 위치의 일반 Point를 반환하는 뷰(view) 메서드를 public으로 추가하자.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="c1">// 코드 10-5 equals 규약을 지키면서 값 추가하기 (60쪽)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ColorPoint</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Point</span> <span class="n">point</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="nc">Color</span> <span class="n">color</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">ColorPoint</span><span class="o">(</span><span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="nc">Color</span> <span class="n">color</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">point</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Point</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">color</span> <span class="o">=</span> <span class="nc">Objects</span><span class="o">.</span><span class="na">requireNonNull</span><span class="o">(</span><span class="n">color</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="cm">/**
     * 이 ColorPoint의 Point 뷰를 반환한다.
     */</span>
    <span class="kd">public</span> <span class="nc">Point</span> <span class="nf">asPoint</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">point</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">ColorPoint</span><span class="o">))</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="nc">ColorPoint</span> <span class="n">cp</span> <span class="o">=</span> <span class="o">(</span><span class="nc">ColorPoint</span><span class="o">)</span> <span class="n">o</span><span class="o">;</span>
        <span class="k">return</span> <span class="n">cp</span><span class="o">.</span><span class="na">point</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">point</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="n">cp</span><span class="o">.</span><span class="na">color</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">color</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><p>그렇게 되면 컴포지션을 통해 LSP를 위반하지 않게 된다. 더 이상 ColorPoint는 Point의 하위 클래스가 아니기에… 그러면서도 Point의 메서드들을 활용할 수 있게 된다.</p><h3 id="timestamp-주의해서-사용하자">Timestamp 주의해서 사용하자.</h3><p>자바 라이브러리에도 구체 클래스를 확장해 값을 추가한 클래스가 종종 있다.</p><p>한 가지로 <code class="language-plaintext highlighter-rouge">java.sql.Timestamp</code>는 <code class="language-plaintext highlighter-rouge">java.util.Date</code>를 확장한 후 nanoseconds 필드를 추가했다. 그 결과로 Timestamp의 equals는 대칭성을 위배하며, Date객체와 한 컬렉션에 넣거나 서로 섞어 사용하면 엉뚱하게 동작할 수 있다. 그래서 Timestamp의 API설명에는 Date와 섞어 쓸 때의 주의사항을 언급하고 있다.</p><p><img width="682" alt="스크린샷 2022-06-05 오후 6 25 18" src="https://user-images.githubusercontent.com/44339530/172044143-efefa510-fbdf-4e6e-b4dd-13ca32a8f15a.png" /></p><p>둘을 명확히 분리해 사용하는 한 문제될 것은 없지만, 섞이지 않도록 보장해줄 수단은 없다. <b>Timestamp를 이렇게 설계한 것은 실수니 절대 따라하진 말자.</b></p><blockquote><p><strong>Note</strong>: 추상 클래스의 하위 클래스에서라면 equals 규약을 지키면서도 값을 추가할 수 있다. 예컨데 아무런 값을 갖지 않는 추상 클래스인 Shape를 위에 두고, 이를 확장하여 radius필드를 가진 Circle클래스와 lenth와 width를 가진 Rectangle 클래스를 만들 수 있다. 상위 클래스를 직접 인스턴스로 만드는게 불가능하다면 지금까지 언급한 문제들은 일어나지 않게 된다.</p></blockquote><h2 id="4-일관성--null이-아닌-모든-참조-값-xy에-대해-xequalsy를-반복해서-호출하면-항상-true를-반환하거나-항상-false를-반환한다">4) 일관성 : null이 아닌 모든 참조 값 x,y에 대해 x.equals(y)를 반복해서 호출하면 항상 true를 반환하거나 항상 false를 반환한다.</h2><ul><li>두 객체가 같다면 앞으로도 영원히 같아야 함<li>불변 객체는 한 번다르면 끝까지 달라야함<li>클래스가 불변이든 가변이든 equals의 판단에 신뢰할 수 없는 자원이 끼어들게 해선 안된다.<ul><li><code class="language-plaintext highlighter-rouge">java.net.URL</code>의 equals는 주어진 URL과 매핑된 호스트의 IP주소를 이용해 비교한다.<li>호스트 이름을 IP주소로 바꾸려면 네트워크를 통해야 하는데, 결과가 항상 같다고 보장할 순 없음<li>이는 설계 실수이니 따라해선 안된다.</ul></ul><h2 id="5-null이-아님--null이-아닌-모든-참조-값-x에-대해-xequalsnull은-false다">5) null이 아님 : null이 아닌 모든 참조 값 x에 대해 x.equals(null)은 false다.</h2><ul><li>공식 이름이 없음. 모든 객체가 null과 같지 않아야 함<li>일부러 null검사를 아래와 같이 할 필요 없음</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// 명시적 null검사 - 필요 없다!</span>
<span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">flase</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>동치성을 검사하려면 equals는 건네받은 객체를 적절히 형변환 후 필수 필드의 값을 알아내야 한다. 그러려면 형변환에 앞서 <code class="language-plaintext highlighter-rouge">instanceof</code> 연산자로 파라미터가 올바른 타입인지 검사해야 한다. 이때 instsanceof 연산자에서 null일 경우 false를 반환하도록 되어 있기 때문이다.</p><h1 id="양질의-equals-메서드-구현-방법">양질의 equals 메서드 구현 방법</h1><h2 id="1--연산자를-사용해-입력이-자기-자신의-참조인지-확인">1) == 연산자를 사용해 입력이 자기 자신의 참조인지 확인</h2><ul><li>자기 자신이면 true 리턴<li>단순한 성능 최적화용으로, 비교 작업이 복잡한 상황일떄 값어치 있음</ul><h2 id="2-instanceof-연산자로-입력이-올바른-타입인지-확인">2) instanceof 연산자로 입력이 올바른 타입인지 확인</h2><ul><li>가끔은 그 클래스가 구현한 특정 인터페이스가 될 수도 있음<li>어떤 인터페이스는 자신을 구현한 클래스끼리도 비교할 수 있도록 equals 규약을 수정하기도 함<li>이런 인터페이스를 구현한 클래스라면 equals 규약을 수정하기도 함<li>이런 인터펭시ㅡ를 구현한 클래스라면 equals에서 (클래스가 아닌) 해당 인터페이스를 사용해야 함<li>Set, List, Map.Entry 등의 컬렉션 인터페이스들이 여기 해당함</ul><h2 id="3-입력을-올바른-타입으로-형변환">3) 입력을 올바른 타입으로 형변환</h2><ul><li>위에서 instaceof 연산자로 검사를 했기에 백프로 성공하게 되어있음</ul><h2 id="4-입력-객체와-자기-자신의-대응-되는-핵심-필드들이-모두-일치하는지-하나씩-검사">4) 입력 객체와 자기 자신의 대응 되는 ‘핵심’ 필드들이 모두 일치하는지 하나씩 검사</h2><ul><li>2단계에서 인터페이스를 사용했다면 입력의 필드 값을 가져올 떄도 그 인터페이스의 메서드를 사용해야 함<li>타입이 클래스라면 (접근 권한에 따라) 해당 필드에 직접 접근할수도 있음<li>float와 double 을 제외한 기본 타입 필드는 <code class="language-plaintext highlighter-rouge">==</code>연산자로 비교하고, 참조 타입은 equals 메서드로 비교<ul><li><code class="language-plaintext highlighter-rouge">flaot와 double</code>은 <code class="language-plaintext highlighter-rouge">Float.NaN, -0.0f, 특수한 부동소수 값</code>등을 다뤄야 하기 때문에 <code class="language-plaintext highlighter-rouge">Float.compare(float, float)</code>와 <code class="language-plaintext highlighter-rouge">Double.compare(double, double)</code>을 사용해야 함</ul><li><code class="language-plaintext highlighter-rouge">Float.equal</code>s와 <code class="language-plaintext highlighter-rouge">Double.equals</code> 메서드를 사용할 수도 있지만 이는 오토박싱을 수반할 수 있으니 성능상 좋지 않음(형변환으로 인한?)</ul><p><img width="811" alt="스크린샷 2022-06-05 오후 6 40 35" src="https://user-images.githubusercontent.com/44339530/172044566-34318cb0-ca81-4208-a7c6-ed96968ee5b3.png" /></p><ul><li>배열의 모든 원소가 핵심 필드라면 <code class="language-plaintext highlighter-rouge">Arrays.equals</code> 메서드들 중 하나를 사용<li>앞서의 <code class="language-plaintext highlighter-rouge">CaseInseneitiveString</code> 예처럼 비교하기가 아주 복잡한 필드를 가진 경우 그 필드의 표준형을 저장해둔 후 표준형끼리 비교하면 훨씬 경제적임<ul><li>가변 객체라면 값이 바뀔때마다 표준형도 최신 상태로 갱신 해줘야함</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="c1">// 코드 10-6 전형적인 equals 메서드의 예 (64쪽)</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">PhoneNumber</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">short</span> <span class="n">areaCode</span><span class="o">,</span> <span class="n">prefix</span><span class="o">,</span> <span class="n">lineNum</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">PhoneNumber</span><span class="o">(</span><span class="kt">int</span> <span class="n">areaCode</span><span class="o">,</span> <span class="kt">int</span> <span class="n">prefix</span><span class="o">,</span> <span class="kt">int</span> <span class="n">lineNum</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">areaCode</span> <span class="o">=</span> <span class="n">rangeCheck</span><span class="o">(</span><span class="n">areaCode</span><span class="o">,</span> <span class="mi">999</span><span class="o">,</span> <span class="s">"지역코드"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">prefix</span>   <span class="o">=</span> <span class="n">rangeCheck</span><span class="o">(</span><span class="n">prefix</span><span class="o">,</span>   <span class="mi">999</span><span class="o">,</span> <span class="s">"프리픽스"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lineNum</span>  <span class="o">=</span> <span class="n">rangeCheck</span><span class="o">(</span><span class="n">lineNum</span><span class="o">,</span> <span class="mi">9999</span><span class="o">,</span> <span class="s">"가입자 번호"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kd">static</span> <span class="kt">short</span> <span class="nf">rangeCheck</span><span class="o">(</span><span class="kt">int</span> <span class="n">val</span><span class="o">,</span> <span class="kt">int</span> <span class="n">max</span><span class="o">,</span> <span class="nc">String</span> <span class="n">arg</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">max</span><span class="o">)</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="n">arg</span> <span class="o">+</span> <span class="s">": "</span> <span class="o">+</span> <span class="n">val</span><span class="o">);</span>
        <span class="k">return</span> <span class="o">(</span><span class="kt">short</span><span class="o">)</span> <span class="n">val</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">o</span> <span class="o">==</span> <span class="k">this</span><span class="o">)</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span> <span class="c1">// 1) 입력이 자기 자신인지 검사</span>
        <span class="k">if</span> <span class="o">(!(</span><span class="n">o</span> <span class="k">instanceof</span> <span class="nc">PhoneNumber</span><span class="o">))</span> <span class="c1">// 2) 타입 검사</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
        <span class="nc">PhoneNumber</span> <span class="n">pn</span> <span class="o">=</span> <span class="o">(</span><span class="nc">PhoneNumber</span><span class="o">)</span><span class="n">o</span><span class="o">;</span> <span class="c1">// 3) 형 변환</span>
        <span class="k">return</span> <span class="n">pn</span><span class="o">.</span><span class="na">lineNum</span> <span class="o">==</span> <span class="n">lineNum</span> <span class="o">&amp;&amp;</span> <span class="n">pn</span><span class="o">.</span><span class="na">prefix</span> <span class="o">==</span> <span class="n">prefix</span> <span class="c1">// 4) 핵심 필드 비교</span>
                <span class="o">&amp;&amp;</span> <span class="n">pn</span><span class="o">.</span><span class="na">areaCode</span> <span class="o">==</span> <span class="n">areaCode</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="c1">// 나머지 코드는 생략 - hashCode 메서드는 꼭 필요하다(아이템 11)!</span>
<span class="o">}</span>
</pre></table></code></div></div><h1 id="equals-메서드를-재정의시-tip">equals 메서드를 재정의시 TIP</h1><h2 id="1-어떤-필드를-먼저-비교하느냐가-equals의-성능을-좌우하기도함">1) 어떤 필드를 먼저 비교하느냐가 equals의 성능을 좌우하기도함</h2><ul><li>다를 가능성이 더 크거나 비교하는 비용이 싼 필드를 먼저 비교하라.</ul><h2 id="2-동기화용-락lock-필드-같이-객체의-논리적-상태와-관련-없는-필드는-비교하면-안됨">2) 동기화용 락(lock) 필드 같이 객체의 논리적 상태와 관련 없는 필드는 비교하면 안됨</h2><h2 id="3-핵심-필드로부터-계산해-낼-수-있는-파생-필드-역시-굳이-비교할-필욘없지만-파생-필드를-비교하는-쪽이-더-빠를-떄도-있으니-참고하라-파생-필드가-객체-전체의-상태를-대표하는-경우">3) 핵심 필드로부터 계산해 낼 수 있는 파생 필드 역시 굳이 비교할 필욘없지만, 파생 필드를 비교하는 쪽이 더 빠를 떄도 있으니 참고하라. (파생 필드가 객체 전체의 상태를 대표하는 경우)</h2><ul><li>예컨대 자신의 영역을 캐시해두는 <code class="language-plaintext highlighter-rouge">Polygon</code> 클래스가 있다고 했을 경우, 모든 변과 정점을 일일이 비교할 필요 없이 캐시해둔 영역만 비교하면 됨</ul><h2 id="4-equals를-다-구현했다면-세-가지만-자문해보자-대칭적인가-추이성이-있는가-일관적인가-자문에서-끝내지-말고-단위-테스트를-작성해보자">4) equals를 다 구현했다면 세 가지만 자문해보자. 대칭적인가? 추이성이 있는가? 일관적인가? 자문에서 끝내지 말고 단위 테스트를 작성해보자.</h2><ul><li>반사성과 null이 아님은 문제되는 경우가 별로 없다.</ul><h2 id="5equals를-재정의할-땐-hashcode도-반드시-재정의하자아이템-11">5)equals를 재정의할 땐 hashcode도 반드시 재정의하자.(아이템 11)</h2><h2 id="6-너무-복잡하게-해결하려-들지말자">6) 너무 복잡하게 해결하려 들지말자.</h2><ul><li>필드들의 동치성만 검사해도 equals 규약을 어렵지 않게 지킬 수 있다.<li>오히려 너무 공격적으로 파고들다가 문제를 일으키기도 한다. 일반적으로 별칭(alias)은 비교하지 않는게 좋다.<li>예컨데 File 클래스라면, 심볼릭 링크를 비교해 같은 파일을 가리키는지를 확인하려 들면 안된다? (왜 그런지에 대해 좀 더 생각이 필요할 것 같다..)</ul><h2 id="7-object-외의-타입을-매개변수로-받는-equals메서드는-선언하지-말자">7) Object 외의 타입을 매개변수로 받는 equals메서드는 선언하지 말자.</h2><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">// 잘못된 예 - 입력 타입은 반드시 Object 여야 한다.</span>
<span class="nd">@Override</span> <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">MyClass</span> <span class="n">o</span><span class="o">)</span> <span class="o">{</span>
     <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>이 메서드는 Object.equals를 재정의한게 아니다.<li>재정의가 아니라 다중 정의(아이템52) 한 것이다.<li>하위 클래스에서의 @Override 애너테이션이 긍정 오류(false positive; 거짓 양성)를 내게 하고 보안 측면에서도 잘못된 정보를 준다.<li><b>@Override 애너테이션을 일관되게 사용하면 이러한 실수를 예방할 수 있다.</b></ul><h2 id="8-구글이-만든-autovalue-프레임워크를-통해-단위-테스트를-수행하자">8) 구글이 만든 AutoValue 프레임워크를 통해 단위 테스트를 수행하자.</h2><ul><li>equals(hascode도 마찬가지)를 작성하고 테스트하는 일은 지루하고 항상 뻔하다.<li>다행히 이 작업을 대신해줄 오픈소스가 있는데 구글이 만든 <code class="language-plaintext highlighter-rouge">AutoValue</code> 프레임워크이다.<li>클래스에 애너테이션 하나만 추가하면 AutoValue가 이 메서드들을 알아서 작성해주며, 개발자가 직접 작성하는 것과 근본적으로 똑같은 코드를 ㅁ나들어줄 것이다.<li>대다수의 IDE도 같은 기능을 제공하지만, 생성된 코드가 AutoValue만큼 깔끔하거나 읽기 좋진 않다. 또한 IDE는 나중에 클래스가 수정된 걸 자동으로 알아채지는 못하니 테스트 코드를 작성해둬야 한다.<ul><li>이러한 단점을 감안하더라도 개발자가 직접 작성해서 실수하는 것보단 IDE에 맡기는게 더 낫다.</ul><li><p><a href="https://github.com/google/auto/tree/master/value">AutoValue 깃허브 레포</a> 와 <a href="https://dahye-jeong.gitbook.io/java/java/advanced/2020-02-02-autovalue">실제 사용법이 정리된 포스팅</a> 도 참고해보자.</p><li>깃허브레포와 AutoValue와 관련된 많은 레퍼런스를 찾아보니 테스트 자동화 프레임워크라기보단 <code class="language-plaintext highlighter-rouge">equals</code>, <code class="language-plaintext highlighter-rouge">hashcode</code>와 같은 메서드를 자동으로 생성해주는 <code class="language-plaintext highlighter-rouge">lombok</code>과 뭔가 비슷한 라이브러리인 것 같다.<ul><li>클래스에 어노테이션 하나만 추가하면 <code class="language-plaintext highlighter-rouge">AutoValue</code>가 <code class="language-plaintext highlighter-rouge">equals</code>, <code class="language-plaintext highlighter-rouge">hashcode</code>와 같은 메서드들을 알아서 작성해주는데, 개발자가 직접 작성하는 것과 근본적으로 똑같은 코드를 만들어주는 것 같다.(<a href="https://it-mesung.tistory.com/74">출처</a>)</ul></ul><blockquote><p><strong>핵심 정리</strong>: 꼭 필요한 경우가 아니면 equals를 재정의하지 말자. 많은 경우에 Object의 equals가 개발자가 원하는 비교를 정확히 수행해준다. 재정의해야할 때는 그 클래스의 핵심 필드 모두를 빠짐 없이, 다섯 가지 규약을 확실히 지켜가며 비교해야 한다.</p></blockquote></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%EC%B1%85/'>책</a>, <a href='/categories/effectivejava/'>EffectiveJava</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >java</a> <a href="/tags/effectivejava/" class="post-tag no-text-decoration" >effectivejava</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[이펙티브자바] 아이템10-equals는 일반 규약을 지켜 재정의하라 - Youngho's Devlog&url=https://jeonyoungho.github.io/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C10-equals%EB%8A%94-%EC%9D%BC%EB%B0%98-%EA%B7%9C%EC%95%BD%EC%9D%84-%EC%A7%80%EC%BC%9C-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[이펙티브자바] 아이템10-equals는 일반 규약을 지켜 재정의하라 - Youngho's Devlog&u=https://jeonyoungho.github.io/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C10-equals%EB%8A%94-%EC%9D%BC%EB%B0%98-%EA%B7%9C%EC%95%BD%EC%9D%84-%EC%A7%80%EC%BC%9C-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[이펙티브자바] 아이템10-equals는 일반 규약을 지켜 재정의하라 - Youngho's Devlog&url=https://jeonyoungho.github.io/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C10-equals%EB%8A%94-%EC%9D%BC%EB%B0%98-%EA%B7%9C%EC%95%BD%EC%9D%84-%EC%A7%80%EC%BC%9C-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5958719204143086" data-ad-slot="1982371670" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <ins class="adsbygoogle" style="display:block" data-ad-format="autorelaxed" data-ad-client="ca-pub-5958719204143086" data-ad-slot="5918543412"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <script src="https://utteranc.es/client.js" repo="jeonyoungho/jeonyoungho.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async> </script></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Kafka-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%A0%84%EB%8B%AC-%EB%B3%B4%EC%9E%A5-%EB%B0%A9%EC%8B%9D/">Kafka 메시지 전달 보장 방식</a><li><a href="/posts/Transactional-Outbox-%ED%8C%A8%ED%84%B4/">Transactional Outbox 패턴</a><li><a href="/posts/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%A1%B0%EA%B0%81%ED%99%94/">데이터베이스 인덱스 조각화(Fragmentation)</a><li><a href="/posts/Kafka-DeadLetter-%EA%B4%80%EB%A6%AC/">Kafka DeadLetter 관리</a><li><a href="/posts/Redis-%ED%8A%B9%EC%A7%95/">Redis 특징</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/jpa/">jpa</a> <a class="post-tag" href="/tags/effectivejava/">effectivejava</a> <a class="post-tag" href="/tags/react/">react</a> <a class="post-tag" href="/tags/frontend/">frontend</a> <a class="post-tag" href="/tags/es6/">es6</a> <a class="post-tag" href="/tags/velopert/">velopert</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/poiemaweb/">poiemaweb</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C13-clone-%EC%9E%AC%EC%A0%95%EC%9D%98%EB%8A%94-%EC%A3%BC%EC%9D%98%ED%95%B4%EC%84%9C-%EC%A7%84%ED%96%89%ED%95%98%EB%9D%BC/"><div class="card-body"> <span class="timeago small" > Jun 14, 2022 <i class="unloaded">2022-06-14T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[이펙티브자바] 아이템13-clone 재정의는 주의해서 진행하라</h3><div class="text-muted small"><p> Cloneable 인터페이스를 구현하는 모든 클래스는 clone을 재정의해야 한다 이때 접근 제한자는 public으로, 반환 타입은 클래스 자신으로 변경한다. 이 메서드는 가장 먼저 super.clone을 호출한 후 필요한 필드를 전부 적절히 수정한다. 일반적으로 이 말은 그 객체의 내부 깊은 구조에 숨어 있는 모든 가변 객체를 복사하고,...</p></div></div></a></div><div class="card"> <a href="/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C14-Comparable%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%A0%EC%A7%80-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/"><div class="card-body"> <span class="timeago small" > Jun 17, 2022 <i class="unloaded">2022-06-17T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[이펙티브자바] 아이템14-Comparable을 구현할지 고려하라</h3><div class="text-muted small"><p> Comparable 인터페이스란? Comparable 인터페이스는 객체를 정렬하는데 사용되는 메서드인 compareTo를 정의하고 있다. Comparable 인터페이스를 구현한 클래스는 반드시 compareTo를 정의해야 한다. Comparable 인터페이스 특징 자바에서 같은 타입의 인스턴스를 비교해야만 하는 클래스들은 모두 Com...</p></div></div></a></div><div class="card"> <a href="/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C15-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EB%A9%A4%EB%B2%84%EC%9D%98-%EC%A0%91%EA%B7%BC-%EA%B6%8C%ED%95%9C%EC%9D%84-%EC%B5%9C%EC%86%8C%ED%99%94%ED%95%98%EB%9D%BC/"><div class="card-body"> <span class="timeago small" > Jul 11, 2022 <i class="unloaded">2022-07-11T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[이펙티브자바] 아이템15-클래스와 멤버의 접근 권한을 최소화하라</h3><div class="text-muted small"><p> 컴포넌트 설계 어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 바로 클래스의 내부 데이터와 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐이다. 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리한다. 오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/JPA-Episode2-%EC%98%81%EC%86%8D%EC%84%B1-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/" class="btn btn-outline-primary" prompt="Older"><p>[학습할래][JPA-Episode2] 영속성 컨텍스트</p></a> <a href="/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C11-equals%EB%A5%BC-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%A0%A4%EA%B1%B0%EB%93%A0-hashcode%EB%8F%84-%EC%9E%AC%EC%A0%95%EC%9D%98%ED%95%98%EB%9D%BC/" class="btn btn-outline-primary" prompt="Newer"><p>[이펙티브자바] 아이템11-equals를 재정의하려거든 hashcode도 재정의하라</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/jeonyoungho_o">jeonyoungho</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/jpa/">jpa</a> <a class="post-tag" href="/tags/effectivejava/">effectivejava</a> <a class="post-tag" href="/tags/react/">react</a> <a class="post-tag" href="/tags/frontend/">frontend</a> <a class="post-tag" href="/tags/es6/">es6</a> <a class="post-tag" href="/tags/velopert/">velopert</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/poiemaweb/">poiemaweb</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://jeonyoungho.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
