<!DOCTYPE html><html lang="ko" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="도메인 주도 개발 시작하기 내용 정리" /><meta name="author" content="jeonyoungho" /><meta property="og:locale" content="ko" /><meta name="description" content="Chapter1-도메인 모델 시작" /><meta property="og:description" content="Chapter1-도메인 모델 시작" /><link rel="canonical" href="https://jeonyoungho.github.io/posts/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC/" /><meta property="og:url" content="https://jeonyoungho.github.io/posts/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC/" /><meta property="og:site_name" content="Youngho’s Devlog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-04-23T16:10:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="도메인 주도 개발 시작하기 내용 정리" /><meta name="twitter:site" content="@jeonyoungho_o" /><meta name="twitter:creator" content="@jeonyoungho" /><meta name="google-site-verification" content="eonGeSiIVfF48EnFoJqakC7h2hUzgqxFNJaxkfPiGr0" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"jeonyoungho"},"dateModified":"2023-04-23T16:10:00+09:00","datePublished":"2023-04-23T16:10:00+09:00","description":"Chapter1-도메인 모델 시작","headline":"도메인 주도 개발 시작하기 내용 정리","mainEntityOfPage":{"@type":"WebPage","@id":"https://jeonyoungho.github.io/posts/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC/"},"url":"https://jeonyoungho.github.io/posts/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC/"}</script><title>도메인 주도 개발 시작하기 내용 정리 | Youngho's Devlog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Youngho's Devlog"><meta name="application-name" content="Youngho's Devlog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-RF6ZGDWXV1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-RF6ZGDWXV1'); }); </script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5958719204143086" crossorigin="anonymous"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/youngho_employee_pic.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Youngho's Devlog</a></div><div class="site-subtitle font-italic">curios developer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/jeonyoungho" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/jeonyoungho_o" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['yhjun1000','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>도메인 주도 개발 시작하기 내용 정리</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"> <ins class="adsbygoogle" style="display:block; margin-top: 30px;" data-ad-client="ca-pub-5958719204143086" data-ad-slot="1982371670" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>도메인 주도 개발 시작하기 내용 정리</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> jeonyoungho </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Sun, Apr 23, 2023, 4:10 PM +0900" prep="on" > Apr 23, 2023 <i class="unloaded">2023-04-23T16:10:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="73361 words">407 min</span></div></div><div class="post-content"><h1 id="chapter1-도메인-모델-시작">Chapter1-도메인 모델 시작</h1><h2 id="도메인">도메인</h2><ul><li>온라인 서점(쇼핑몰) 소프트웨어는 온라인으로 책을 판매하는데 필요한 상품조회, 구매, 결제, 배송 추적 등의 기능을 제공해야 한다.<li>이때 ‘온라인 서점’은 소프트웨어로 해결하고자 하는 문제 영역, 즉 도메인에 해당한다.<li>한 도메인은 다시 하위 도메인으로 나눌 수 있다.</ul><p><img width="419" alt="image" src="https://user-images.githubusercontent.com/44339530/233833034-e57f6613-2194-4a0c-ab20-3e98964c61f2.png" /></p><p><em>[그림1.1] 도메인은 여러 하위 도메인으로 구성된다.</em></p><ul><li>카탈로그 하위 도메인은 고객에게 구매할 수 있는 상품 목록을 제공하고, 주문 하위 도메인은 고객의 주문을 처리한다.<ul><li>한 하위 도메인은 다른 하위 도메인과 연동하여 완전한 기능을 제공한다.<li>예를 들어, 고객이 물건을 구매하면 주문, 결제, 배송, 혜택 하위 도메인의 기능이 엮이게 된다.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/233833364-c626db45-0176-40df-9e2a-500ac3f1d8aa.png" alt="image" /></p><ul><li>도메인마다 고정된 하위 도메인이 존재하는 것은 아니다.<ul><li>모든 온라인 쇼핑몰이 고객 혜택을 제공하는 것은 아니며 규모가 크지 않은 소규모 업체는 엑셀과 같은 도구를 이용해 수작업으로 정산을 처리할 수도 있다.</ul><li>하위 도메인을 어떻게 구성하지 여부는 상황에 따라 달라진다.<ul><li>예를 들어 기업 고객을 대상으로 대형 장비를 판매하는 곳은 온라인으로 카탈로그를 제공하고 주문서를 받는 정도만 필요할 것이다.</ul></ul><h2 id="도메인-모델">도메인 모델</h2><ul><li>기본적으로 도메인 모델은 특정 도메인을 개념적으로 표현한 것이다.<li>예를 들어, 주문 도메인 모델을 살펴보자.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/233833698-205f46aa-4284-4fcd-a4b1-942dcfc0225a.png" alt="image" /></p><p><em>[그림1.3] 객체 기반 주문 도메인 모델</em></p><ul><li>[그림1.3]의 모델은 도메인의 모든 내용을 담고 있진 않지만 이 모델을 보면 주문(Order)은 주문번호(OrderNumber)와 지불할 총금액(totalAmounts)이 있고, 배송정보(Shipping)를 변경할 수 있음을 알 수 있다.<ul><li>즉, 도메인 모델을 사용하면 여러 관계자들이 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유하는데 도움이 된다.</ul><li>도메인을 이해하려면 도메인이 제공하는 기능과 도메인의 주요 데이터 구성을 파악해야 하는데, 이런 면에서 기능과 데이터를 함께 보여주는 객체 모델은 도메인을 모델링하기 적합하다.<li>도메인 모델을 객체로만 모델링할 수 있는 것은 아니고 상태 다이어그램 등 다양한 표현 방법을 사용할 수 있다.<ul><li>즉, 관계가 중요한 도메인이라면 그래프를 이용해서 도메인을 모델링할 수 도 있는 것처럼 적절하게 사용하는게 좋다.</ul><li>도메인 모델은 기본적으로 도메인 자체를 이해하기 위한 개념 모델이다.<ul><li>개념 모델과 구현 모델은 서로 다르지만 구현 모델이 개념 모델을 최대한 따르도록 할 수는 있다.</ul></ul><blockquote><p><strong>하위 모데인과 모델</strong>: 모델의 각 구성 요소는 특정 도메인을 한정할 때 비로소 의미가 완전해지기 떄문에, 각 하위 도메인마다 별도로 모델을 만들어야 한다. 이는 카탈로그 하위 도메인 모델과 배송하위 도메인 모델을 따로 만들어야 한다는 것을 뜻한다.</p></blockquote><h2 id="도메인-모델-패턴">도메인 모델 패턴</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/233834051-0b00bc7b-0ce4-492a-8495-fca94cccaf55.png" alt="image" /></p><p><em>[그림1.5] 아키텍처 구성</em></p><ul><li>일반적인 애플리케이션 아키텍처는 위 이미지와 같이 네 개의 층으로 구성된다.<li>각 계층의 역할은 다음과 같다.<ul><li>표현(UI) 계층: 사용자의 요청을 처리하고 사용자에게 정보를 보여준다. 여기서 사용자는 소프트웨어를 사용하는 사람 뿐 아니라 외부 시스템도 사용자가 될 수도 있다.<li>응용(Application) 계층: 사용자가 요청한 기능을 실행한다. 업무 로직을 직접 구현하지 않으며 도메인 계층을 조합해서 기능을 실행한다.<li>도메인 계층: 시스템이 제공할 도메인의 규칙을 구현한다.<li>인프라스트럭처 계층: DB나 메시징 시스템과 같은 외뷔 시스템과의 연동을 처리한다.</ul><li>도메인 계층은 도메인의 핵심 규칙을 구현한다.<ul><li>주문 도메인의 경우 ‘출고 전에 배송지를 변경할 수 있다’는 규칙과 ‘주문 취소는 배송 전에만 할 수 있다’는 규칙을 구현한 코드가 도메인 계층에 위치하게 된다.<li><b>이런 도메인 규칙을 객체 지향 기법으로 구현하는 패턴이 도메인 모델 패턴이다.</b></ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">OrderState</span> <span class="n">state</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">ShippingInfo</span> <span class="n">shippingInfo</span><span class="o">;</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeShippingInfo</span><span class="o">(</span><span class="nc">ShippingInfo</span> <span class="n">newShippingInfo</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(!</span><span class="n">state</span><span class="o">.</span><span class="na">isShippingChangeable</span><span class="o">())</span> <span class="o">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"can't change shipping in "</span> <span class="o">+</span> <span class="n">state</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="k">this</span><span class="o">.</span><span class="na">shippingInfo</span> <span class="o">=</span> <span class="n">newShippingInfo</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeShipped</span><span class="o">()</span> <span class="o">{</span>
		<span class="c1">// 로직 검사</span>
		<span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="nc">OrderState</span><span class="o">.</span><span class="na">SHIPPED</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">OrderState</span> <span class="o">{</span>
	<span class="no">PAYMENT_WAITING</span> <span class="o">{</span>
		<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isShippingChangeable</span><span class="o">()</span> <span class="o">{</span>
			<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">},</span>
	<span class="no">PREPARING</span> <span class="o">{</span>
		<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isShippingChangeable</span><span class="o">()</span> <span class="o">{</span>
			<span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">},</span>
	<span class="no">SHIPPED</span><span class="o">,</span> <span class="no">DELIVERING</span><span class="o">,</span> <span class="no">DELIVERY_COMPLETED</span><span class="o">;</span>

	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isShippingChangeable</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>위 코드는 주문 도메인의 일부 기능을 도메인 모델 패턴으로 구현한 것이다.<ul><li>주문 상태를 표현하는 OrderState는 배송지를 변경할 수 있는지 여부를 검사할 수 있는 isShippingChangeable() 메서드를 제공하고 있다.<li>코드를 보면 주문 대기 중(PAYMENT_WAITING) 상태와 상품 준비 중(PREPARING) 상태만 배송지를 변경할 수 있딴 것을 알 수 있다. 즉, OrderState는 주문 대기 중 이거나 상품 준비 중에는 배송지를 변경할 수 있따는 도메인 규칙을 구현하고 있다.</ul><li>위 코드에선 배송지 변경 가능 여부를 판단할 규칙이 OrderState 쪽에 구현되어 있지만 Order 클래스에서 이를 구현할 수 도 있다.<ul><li>하지만어디에 있뜬 중요한 점은 주문과 관련된 중요 업무 규칙을 주문 도메인 모델인 Order나 OrderState에서 구현하다는 점이다.</ul><li>핵심 규칙을 구현한 코드는 도메인 모델에만 위치하기 때문에 규칙이 바뀌거나 규칙을 확장해야 할 때 다른 코드에 영향을 덜 주고 변경 내역을 모델에 반영할 수 있게 된다.</ul><blockquote><p><strong>Note</strong>: ‘도메인 모델’이란 용어는 도메인 자체를 표현하는 개념적인 모델을 의미하지만, 도메인 계층을 구현할 때 사용하는 객체 모델을 언급할 때에도 ‘도메인 모델’이란 용어를 사용한다.</p></blockquote><blockquote><p><strong>개념 모델과 구현 모델</strong>: 처음부터 완벽한 개념 모델을 만들기보단 전반적인 개요를 알 수 있는 수준으로 개념 모델을 작성해야 한다. 프로젝트 초기에는 개요 수준의 개념 모델로 도메인에 대한 전체 윤곽을 이해하는데 집중하고, 구현하는 과정에서 개념 모델을 구현 모델로 점진적으로 발전시켜 나가야 한다.</p></blockquote><h2 id="도메인-모델-도출">도메인 모델 도출</h2><ul><li>기획서, 유스 케이스, 사용자 스토리와 같은 요구사항과 관련자와의 대화를 통해 도메인을 이해하고 이를 바탕으로 도메인 모델 초안을 만들어야 비로소 코드를 작성할 수 있다.<li>도메인을 모델링할 떄 기본이 되는 작업은 모델을 구성하는 핵심 구성요소, 규칙, 기능을 찾는 것이다.<li>주문 도메인과 관련된 몇가지 요구사항을 보자<ul><li>최소 한 종류 이상의 상품을 주문해야 한다.<li>한 상품을 한 개 이상 주문할 수 있다.<li>총 주문 금액은 각 상품의 구매 가격 합을 모두 더한 금액이다.<li>각 상품의 구매 가격 합은 상품 가격에 구매 개수를 곱한 값이다.<li>주문할 때 배송지 정보를 반드시 지정해야 한다.<li>배송지 정보는 받는 사람 이름, 전화번호, 주소로 구성된다.<li>출고를 하면 배송지 정보를 변경할 수 없다.<li>출고 전에 주문을 취소할 수 있다.<li>고객이 결제를 완료하기 전에는 상품을 준비하지 않는다.</ul><li>위 요구사항을 통해 아직 상세 구현까지 할 수 있는 수준은 아니지만 Order에 관련 기능을 메서드로 추가할 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeShipped</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeShippingInfo</span><span class="o">(</span><span class="nc">ShippingInfo</span> <span class="n">newShipping</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">cancel</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">completePayment</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>다음 요구사항은 주문 항목이 어떤 데이터로 구성되는지 알려준다.<ul><li>한 상품을 한 개 이상 주문할 수 있다.<li>각 상품의 구매 가격 합은 상품 가격에 구매 개수를 곱한 값이다.</ul><li>두 요구사항에 따르면 주문 항목을 표현하는 OrderLine은 적어도 주문할 상품, 상품의 가격, 구매 개수를 포함하고 있어야 한다. 이를 OrderLine으로 구현하면 아래와 같다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderLine</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">Product</span> <span class="n">product</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">price</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">quantity</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">amount</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">OrderLine</span><span class="o">(</span><span class="nc">Product</span> <span class="n">product</span><span class="o">,</span> <span class="kt">int</span> <span class="n">price</span><span class="o">,</span> <span class="kt">int</span> <span class="n">quantity</span><span class="o">)</span> <span class="o">{</span>
		<span class="o">...</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kt">int</span> <span class="nf">calculateAmounts</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">price</span> <span class="o">*</span> <span class="n">quantity</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">getAmounts</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
	<span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>다음 요구사항은 Order와 OrderLine과의 관계를 알려준다.<ul><li>최소 한 종류 이상의 상품을 주문해야 한다.<li>총 주문 금액은 각 상품의 구매 가격 합을 모두 더한 금액이다.</ul><li>한 종류 이상의 상품을 주문할 수 있으므로 Order는 최소 한 개이상의 OrderLine을 포함해야 한다.<li>또한, OrderLine으로부터 총 주문 금액을 구할 수 있다. 이를 코드에 반영하면 다음과 같다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderLine</span><span class="o">&gt;</span> <span class="n">orderLines</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">totalAmounts</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">Order</span><span class="o">(</span><span class="n">list</span><span class="o">&lt;</span><span class="nc">OrderLine</span><span class="o">&gt;</span> <span class="n">orderLines</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">setOrderLines</span><span class="o">(</span><span class="n">orderLines</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kt">void</span> <span class="nf">setOrderLines</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderLine</span><span class="o">&gt;</span> <span class="n">orderLines</span><span class="o">)</span> <span class="o">{</span> 
			<span class="n">verityAtLeastOneOrMoreOrderLines</span><span class="o">(</span><span class="n">orderLines</span><span class="o">);</span>
			<span class="k">this</span><span class="o">.</span><span class="na">orderLines</span> <span class="o">=</span> <span class="n">orderLines</span><span class="o">;</span>
			<span class="n">calculateTotalAmounts</span><span class="o">();</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kt">void</span> <span class="nf">verifyAtLeastOneOrMoeOrderLines</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderLine</span><span class="o">&gt;</span> <span class="n">orderLines</span><span class="o">)</span> <span class="o">{</span> 
		<span class="k">if</span> <span class="o">(</span><span class="n">orderLines</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">orderLines</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"no OrderLine"</span><span class="o">);</span>
		<span class="o">}</span>
	 <span class="o">}</span>

	<span class="kd">private</span> <span class="kt">void</span> <span class="nf">calculateTotalAmounts</span><span class="o">()</span> <span class="o">{</span> 
		<span class="k">this</span><span class="o">.</span><span class="na">totalAmounts</span> <span class="o">==</span> <span class="k">new</span> <span class="nc">Money</span><span class="o">(</span><span class="n">orderLines</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
			<span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">getAmounts</span><span class="o">().</span><span class="na">getValue</span><span class="o">()).</span><span class="na">sum</span><span class="o">());</span>
	<span class="o">}</span>

	<span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>요구사항에 따르면 최소 한 종류 이상의 상품을 주문해야 하므로 setOrderLines() 메서드는 verityAtLeastOneOrMoteOrderLines() 메서드를 이용하여 OrderLine이 한 개이상 존재하는지 검사한다.<ul><li>또한, calcuateTotalAmounts() 메서드를 이용해 총 주문 금액을 계산한다.</ul><li>배송지 정보는 이름, 전화번호, 주소 데이터를 가지므로 ShippingInfo 클래스를 다음과 같이 정의하였다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShipingInfo</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">receiverName</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">receiverPhoneNumber</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">shipingAddress1</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">shipingAddress2</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">shipingZipcode</span><span class="o">;</span>

	<span class="o">...</span> <span class="n">생성자</span><span class="o">,</span> <span class="n">getter</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>앞서 요구사항 중에 ‘주문할 때 배송지 정보를 반드시 지정해야 한다’는 내용이 있는데 이는 Order 생성시 생성자에 OrderLine의 목록 뿐만 아니라 ShippingInfo도 함께 전달해야 함을 의미한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderLine</span><span class="o">&gt;</span> <span class="n">orderLines</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">ShippingInfo</span> <span class="n">shippingInfo</span><span class="o">;</span>
    <span class="o">...</span>

    <span class="kd">public</span> <span class="nf">Order</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderLine</span><span class="o">&gt;</span> <span class="n">orderLines</span><span class="o">,</span> <span class="nc">ShippingInfo</span> <span class="n">shippingInfo</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">setOrderLines</span><span class="o">(</span><span class="n">orderLines</span><span class="o">);</span>
        <span class="n">setShippingInfo</span><span class="o">(</span><span class="n">shippingInfo</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">setShippingInfo</span><span class="o">(</span><span class="nc">ShippingInfo</span> <span class="n">shippingInfo</span><span class="o">)</span> <span class="o">{</span>
    	<span class="k">if</span><span class="o">(</span><span class="n">shippingInfo</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
    	    <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"no ShippingInfo"</span><span class="o">);</span>
    	<span class="o">}</span>
    	<span class="k">this</span><span class="o">.</span><span class="na">shippingInfo</span> <span class="o">=</span> <span class="n">shippingInfo</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>생성자에서 호출하는 setShippingInfo() 메서드는 ShippingInfo가 null이면 Exception을 발생하는데, 이렇게 함으로써 배송지 정보 필수라는 도메인 규칙을 구현한다.<li>도메인을 구현하다 보면 특정 조건이나 상태에 따라 제약이나 규칙이 달리 적용되는 경우가 많다.<ul><li>출고를 하면 배송지 정보를 변경할 수 없다.<li>출고 전에 주문을 취소할 수 있다.<li>고객이 결제를 완료하기 전에는 상품을 준비하지 않는다.</ul><li>이는 요구사항이 추가로 존재할 수 있는 상태를 분석한 뒤, 다음과 같이 열거 타입을 이용해서 상태 정보를 표현할 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">enum</span> <span class="nc">OrderState</span> <span class="o">{</span>
	<span class="no">PAYMENT_WAITING</span><span class="o">,</span> 
	<span class="no">PREPARING</span><span class="o">,</span> 
	<span class="no">SHIPPED</span><span class="o">,</span> 
	<span class="no">DELIVERING</span><span class="o">,</span> 
	<span class="no">DELIVERY_COMPLETED</span><span class="o">,</span> 
	<span class="no">CANCELED</span> 
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span><span class="o">{</span>
	<span class="kd">private</span> <span class="nc">OrderState</span> <span class="n">state</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeShippingInfo</span><span class="o">(</span><span class="nc">ShippingInfo</span> <span class="n">newShippingInfo</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">verifyNotYetShipped</span><span class="o">();</span>
		<span class="n">setShippingInfo</span><span class="o">(</span><span class="n">newShippingInfo</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">cancel</span><span class="o">(){</span>
		<span class="n">verifyNotYetShipped</span><span class="o">();</span>
		<span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="nc">OrderState</span><span class="o">.</span><span class="na">CANCELED</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">private</span> <span class="kt">void</span> <span class="nf">verifyNotYetShipped</span><span class="o">(){</span>
		<span class="k">if</span><span class="o">(</span><span class="n">state</span> <span class="o">!=</span> <span class="nc">OrderState</span><span class="o">.</span><span class="na">PAYMENT_WAITING</span> <span class="o">&amp;&amp;</span> <span class="n">state</span> <span class="o">!=</span> <span class="nc">OrderState</span><span class="o">.</span><span class="na">PREPARING</span><span class="o">)</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"already shippped"</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><blockquote><p><strong>문서화</strong>: 문서화를 하는 주된 이유는 지식을 공유하기 위함이다. 코드를 이용해 전체 소프트웨어를 분석하려면 많은 시간이 소요되지만 전반적인 기능 목록이나 모듈 구조, 빌드 과정은 코드를 보고 직접 이해하는 것보다 상위 수준에서 정리한 문서를 참조하는 것이 소프트웨어 전반을 빨르게 이해하는데 도움이 된다. 그리고 코드가 도메인을 잘 표현해야 비로소 코드의 가독성이 높아지며 문서로서 코드가 의미를 갖는다.</p></blockquote><h2 id="엔티티와-벨류">엔티티와 벨류</h2><h2 id="엔티티">엔티티</h2><ul><li>엔티티는 식별자를 갖는다.<ul><li>ex) 주문 도메인 -&gt; 식별자: ‘주문 번호’<li>Order는 엔티티로서 orderNumber를 식별자로 갖는다.</ul><li>엔티티의 식별자는 바뀌지 않고 고유하기 떄문에 두 엔티티 객체의 식별자가 가틍면 두 엔티티를 같다고 판단할 수 있따.<li>엔티티를 구현한 클래스는 다음과 같이 식별자를 이용해서 equals() 메서드와 hashcode() 메서드를 구현할 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="n">orderNumber</span><span class="o">;</span>
	
	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">obj</span><span class="o">){</span>
		<span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">obj</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">obj</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">obj</span><span class="o">.</span><span class="na">getClass</span><span class="o">()</span> <span class="o">!=</span> <span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
		<span class="nc">Order</span> <span class="n">other</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Order</span><span class="o">)</span><span class="n">obj</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">orderNumber</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">orderNumber</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">other</span><span class="o">.</span><span class="na">orderNumber</span><span class="o">);</span>
	<span class="o">}</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">hashCode</span><span class="o">(){</span>
		<span class="kd">final</span> <span class="kt">int</span> <span class="n">prime</span> <span class="o">=</span> <span class="mi">31</span><span class="o">;</span>
		<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">prime</span> <span class="o">*</span> <span class="n">result</span> <span class="o">+</span> <span class="o">((</span><span class="n">orderNumber</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">orderNumber</span><span class="o">.</span><span class="na">hashCode</span><span class="o">());</span>
		<span class="k">return</span> <span class="n">result</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="엔티티의-식별자-생성-방식">엔티티의 식별자 생성 방식</h2><ul><li>1)특정 규칙에 따라 생성한다 - 주문번호,운송장번호 등 특정 규칙에 따라 생성<li>2)UUID 사용<ul><li><code class="language-plaintext highlighter-rouge">UUID uuid = UUID.randomUUID();</code><li><code class="language-plaintext highlighter-rouge">// 615fsdf34-c342-5scd-d33d-123145sadfa 와 같은 문자열</code></ul><li>3)값을 직접 입력 - 회원 아이디, 이메일<li>4)일렬번호 사용 (시퀀스나 DB의 자동 증가 칼럼(auto_increment) 사용)</ul><h2 id="벨류-타입">벨류 타입</h2><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShippingInfo</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">receiverName</span><span class="o">;</span>  <span class="c1">// 받는 사람</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">receiverPhoneNumber</span><span class="o">;</span> <span class="c1">// 받는 사람</span>

	<span class="kd">private</span> <span class="nc">String</span> <span class="n">shippingAddress1</span><span class="o">;</span> <span class="c1">// 주소</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">shippingAddress2</span><span class="o">;</span> <span class="c1">// 주소</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">shippingAddressZipcode</span><span class="o">;</span> <span class="c1">// 주소</span>

	<span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>ShippingInfo 클래스의 receiverName 필드와 receiverPhoneNumber 필드는 서로 다른 두 데이터를 담고 있지만 두 필드는 개념적으로 받는 사람을 의미한다.<ul><li>즉, 두 필드는 실제로 한 개의 개념을 표현하고 있다.</ul><li>비슷하게 shippingAddress1, shippingAddress2, shippingAddressZipcode 는 주소라는 하나의 개념을 표현한다.<li>벨류 타입은 개념적으로 완전한 하나를 표현할 떄 사용한다.<li>예를 들어, 받는 사람을 위한 벨류 타입인 Receiver와 주소 관련 데이터를 표현하는 Address 를 다음과 같은 벨류 타입으로 작성할 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Receiver</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">phoneNumber</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="nf">Receiver</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">phoneNumber</span><span class="o">){</span>
		<span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
		<span class="k">this</span><span class="o">.</span><span class="na">phoneNumber</span> <span class="o">=</span> <span class="n">phoneNumber</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">getName</span><span class="o">(){</span>
		<span class="k">return</span> <span class="n">name</span><span class="o">;</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">getPhoneNumber</span><span class="o">(){</span>
		<span class="k">return</span> <span class="n">phoneNumber</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Address</span><span class="o">{</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">address1</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">address2</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">zipcode</span><span class="o">;</span>
	
	<span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>벨류 타입을 이용한 ShippingInfo 클래스는 다음과 같이 변경될 것이다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShippingInfo</span><span class="o">{</span>
	<span class="kd">private</span> <span class="nc">Receiver</span> <span class="n">receiver</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">Address</span> <span class="n">address</span><span class="o">;</span>
	
	<span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>벨류 타입이 꼭 두 개 이상의 데이터를 가져야 하는 것은 아니다.<li>의미를 명확히 표현하기 위해 사용하는 경우도 있다.<li>이를 위한 좋은 예가 OrderLine이다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderLine</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">Product</span> <span class="n">product</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">price</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">quantity</span><span class="o">;</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">amounts</span><span class="o">;</span>
<span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>price와 amounts는 int 타입의 숫자를 사용하고 있지만, 의미하는 값은 ‘돈’ 이다.<li>따라서 ‘돈’을 의미하는 Money 타입을 만들어 사용하면 코드를 이해하는데 도움 된다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Money</span><span class="o">{</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">Money</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">){</span>
		<span class="k">this</span><span class="o">.</span><span class="na">money</span> <span class="o">=</span> <span class="n">money</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderLine</span><span class="o">{</span>
	<span class="kd">private</span> <span class="nc">Product</span> <span class="n">product</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">Money</span> <span class="n">price</span><span class="o">;</span> <span class="c1">// Money 타입 덕에 price가 금액을 의미한다는 것을 쉽게 유추할 수 있음</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">quantity</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">Money</span> <span class="n">amounts</span><span class="o">;</span> <span class="c1">// Money 타입 덕에 price가 금액을 의미한다는 것을 쉽게 유추할 수 있음</span>
<span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>벨류 타입을 사용할 때의 또 다른 장점은 벨류 타입을 위한 기능을 추가할 수 있다는 것이다.<ul><li>예를 들어, Money 타입은 다음과 같이 돈 계산을 위한 기능을 추가할 수 있다.<li>또한 이를 통해 벨류 타입은 코드의 의미를 더 잘 이해할 수 있도록 한다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Money</span><span class="o">{</span>
	<span class="kd">private</span> <span class="kt">int</span> <span class="n">value</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">Money</span><span class="o">(</span><span class="kt">int</span> <span class="n">value</span><span class="o">){</span>
		<span class="k">this</span><span class="o">.</span><span class="na">money</span> <span class="o">=</span> <span class="n">money</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">public</span> <span class="kt">int</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
	<span class="o">}</span>
	
	<span class="c1">//새로운 기능 추가 가능</span>
	<span class="kd">public</span> <span class="nc">Money</span> <span class="nf">add</span><span class="o">(</span><span class="nc">Money</span> <span class="n">money</span><span class="o">){</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">Money</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">+</span> <span class="n">money</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="nc">Money</span> <span class="nf">multiply</span><span class="o">(</span><span class="kt">int</span> <span class="n">multiplier</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="nf">Money</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">*</span> <span class="n">multiplier</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="참조-투명성과-관련된-문제">참조 투명성과 관련된 문제</h3><ul><li>벨류 객체의 데이터 변경시 기존 데이터를 변경하기보단 변경한 데이터를 갖는 새로운 객체를 생성하는 방식이 좋다.<ul><li>예를 들어, 앞서 Money 클래스의 add 메서드를 보면 Money를 새로 생성하고 있다.</ul><li>Money처럼 데이터 변경 기능을 제공하지 않는 타입을 불변(immutable)이라 표현한다.<li><b>벨류 타입을 불변으로 구현하는 이유는 여러가지가 있는데 가장 중요한 이유는 보다 안전한 코드를 작성할 수 있다는 것이다.</b><li>만약 Money 가 setValue와 같은 메서드를 제공하여 값을 변경할 수 있다면 아래 이미지처럼 OrderLine의 price값이 잘못 반영되는 상황이 발생하게 된다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">Money</span> <span class="n">price</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Money</span><span class="o">(</span><span class="mi">1000</span><span class="o">);</span>
<span class="nc">OrderLine</span> <span class="n">line</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OrderLine</span><span class="o">(</span><span class="n">product</span><span class="o">,</span> <span class="n">price</span><span class="o">,</span> <span class="mi">2</span><span class="o">)</span> <span class="c1">// -&gt; [price=1000, quantity=2, amounts=2000]</span>
<span class="n">price</span><span class="o">.</span><span class="na">setValue</span><span class="o">(</span><span class="mi">2000</span><span class="o">);</span> <span class="c1">// -&gt; [price=2000, quantity=2, amounts=2000]</span>
</pre></table></code></div></div><ul><li>이런 문제를 방지하려면 OrderLine 생성자는 다음과 같이 새로운 Money 객체를 생성하도록 코드를 작성해야 한다.<ul><li>하지만, Money가 불변이라면 이런 코드를 작성할 필요가 없다.<li>그렇지만 개인적인 생각은 추후 어떠한 변경사항이 생길지 모르기 떄문에 안전하게 아래와 같이 처리하는게 좋은것 같다,.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderLine</span> <span class="o">{</span>
	<span class="o">...</span>
	<span class="kd">private</span> <span class="nc">Money</span> <span class="n">price</span><span class="o">;</span>

	<span class="kd">public</span> <span class="nf">OrderLine</span><span class="o">(</span><span class="nc">Product</span> <span class="n">product</span><span class="o">,</span> <span class="nc">Money</span> <span class="n">price</span><span class="o">,</span> <span class="kt">int</span> <span class="n">quantity</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">this</span><span class="o">.</span><span class="na">product</span> <span class="o">=</span> <span class="n">product</span><span class="o">;</span>
		<span class="c1">// Money 가 불변 객체가 아니라면,</span>
		<span class="c1">// price 파라미터가 변경될 떄 발생하는 문제를 방지하기 위해</span>
		<span class="c1">// 데이터를 복사한 새로운 객체를 생성해야 한다.</span>
		<span class="k">this</span><span class="o">.</span><span class="na">price</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Money</span><span class="o">(</span><span class="n">price</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>두 벨류 객체가 같은지 비교할 땐 모든 속성이 같은지 비교해야 한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Receiver</span><span class="o">{</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
	<span class="kd">private</span> <span class="nc">String</span> <span class="n">phoneNumber</span><span class="o">;</span>
	
	<span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">equals</span><span class="o">(</span><span class="nc">Object</span> <span class="n">other</span><span class="o">){</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">other</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(</span><span class="k">this</span> <span class="o">==</span> <span class="n">other</span><span class="o">)</span> <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
		<span class="k">if</span> <span class="o">(!</span> <span class="o">(</span><span class="n">other</span> <span class="k">instanceof</span> <span class="nc">Receiver</span><span class="o">))</span> <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
		<span class="nc">Receiver</span> <span class="n">that</span> <span class="o">=</span> <span class="o">(</span><span class="nc">Receiver</span><span class="o">)</span> <span class="n">other</span><span class="o">;</span>
		
		<span class="k">return</span> <span class="k">this</span><span class="o">.</span><span class="na">name</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">that</span><span class="o">.</span><span class="na">name</span><span class="o">)</span> <span class="o">&amp;&amp;</span> <span class="k">this</span><span class="o">.</span><span class="na">phoneNumber</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">that</span><span class="o">.</span><span class="na">phoneNumber</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="엔티티-식별자와-벨류-타입">엔티티 식별자와 벨류 타입</h2><ul><li>식별자가 어떤 도메인의 식별자인지를 분명히 나타내기 위해서 밸류 타입을 사용할 수 있다.<ul><li>밸류 타입을 통해 식별자의 의미를 분명히 드러낼 수 있다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span><span class="o">{</span>
	<span class="c1">//private String id;</span>
	<span class="kd">private</span> <span class="nc">OrderNo</span> <span class="n">id</span><span class="o">;</span>
	<span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="도메인-모델에-set-메서드-넣지-않기">도메인 모델에 set 메서드 넣지 않기</h2><ul><li>도메인 모델에 get/set 메서드를 무조건 추가하는것은 좋지 않은 버릇이다.<li>set메서드는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다.<ul><li>앞서 changeShippingInfo()가 배송지 정보를 새로 변경하다는 의미를 가졌다면 setShippingInfo() 메서드는 단순히 배송지 값을 설정한다는 것을 뜻한다.<li>completePayment()는 결제 완료와 관련된 처리 코드를 함께 구현하기 때문에 결제 완료와 관련된 도메인 지식을 코드로 구현하는 것이 자연스럽다.<li>하지만 setOrderState는 단순히 상태값만 변경할지 아니면 상태 값에 따라 다른 처리를 위한 코드를 함꼐 구현할지 애매하다.</ul><li>set 메서드의 또 다른 문제점은 도메인 객체를 생성시 완전한 상태가 아닐 수도 있다는 것이다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// set 메서드로 데이터를 전달하도록 구현하면</span>
<span class="c1">// 처음 Order를 생성하는 시점에 order는 완전하지 않다.</span>
<span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="k">new</span>  <span class="nc">Order</span><span class="o">();</span>

<span class="c1">// set 메서드로 필요한 모든 값을 전달해야 한다. </span>
<span class="n">order</span><span class="o">.</span><span class="na">setOrderLine</span><span class="o">(</span><span class="n">lines</span><span class="o">);</span>
<span class="n">order</span><span class="o">.</span><span class="na">setShippingInfo</span><span class="o">(</span><span class="n">shipingInfo</span><span class="o">);</span>

<span class="c1">// 주문자(Orderer)를 설정하지 않은 상태에서 주문 완료 처리 -&gt; 문제 발생!!!</span>
<span class="n">order</span><span class="o">.</span><span class="na">setState</span><span class="o">(</span><span class="nc">OrderState</span><span class="o">.</span><span class="na">PREPARING</span><span class="o">);</span>
</pre></table></code></div></div><ul><li>도메인 객체가 불완전한 상태로 사용되는 것을 막으려면 생성 시점에 필요한 것을 전달해 주어야 한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Order</span><span class="o">(</span><span class="n">orderer</span><span class="o">,</span> <span class="n">lines</span><span class="o">,</span> <span class="n">shippingInfo</span><span class="o">,</span> <span class="nc">OrderState</span><span class="o">.</span><span class="na">PREPARING</span><span class="o">);</span>
</pre></table></code></div></div><ul><li>생성자로 필요한 것을 모두 받으므로 다음처럼 생성자를 호출하는 시점에 필요한 데이터가 올바른지 검사할 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nf">Order</span><span class="o">(</span><span class="nc">Orderer</span> <span class="n">orderer</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderLine</span><span class="o">&gt;</span> <span class="n">orderLines</span><span class="o">,</span> <span class="nc">ShippingInfo</span> <span class="n">shippingInfo</span><span class="o">,</span> <span class="nc">OrderState</span> <span class="n">orderState</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">setOrderer</span><span class="o">(</span><span class="n">orderer</span><span class="o">);</span>
		<span class="n">setOrderLines</span><span class="o">(</span><span class="n">orderLines</span><span class="o">);</span>
		<span class="o">...</span> <span class="c1">// 다른 값 설정</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kt">void</span> <span class="nf">setOrderer</span><span class="o">(</span><span class="nc">Orderer</span> <span class="n">orderer</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">orderer</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"no orderer"</span><span class="o">);</span>
		<span class="o">}</span>
		<span class="k">this</span><span class="o">.</span><span class="na">orderer</span> <span class="o">=</span> <span class="k">this</span><span class="o">.</span><span class="na">orderer</span><span class="o">;</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kt">void</span> <span class="nf">setOrderLines</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderLine</span><span class="o">&gt;</span> <span class="n">orderLines</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">vverifyAtLeastOneOrMoeOrderLines</span><span class="o">(</span><span class="n">orderLines</span><span class="o">);</span>
		<span class="k">this</span><span class="o">.</span><span class="na">orderLines</span> <span class="o">=</span> <span class="n">orderLines</span><span class="o">;</span>
		<span class="n">calculateTotalAmounts</span><span class="o">();</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kt">void</span> <span class="nf">verifyAtLeastOneOrMoeOrderLines</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderLine</span><span class="o">&gt;</span> <span class="n">orderLines</span><span class="o">)</span> <span class="o">{</span> 
		<span class="k">if</span> <span class="o">(</span><span class="n">orderLines</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">orderLines</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"no OrderLine"</span><span class="o">);</span>
		<span class="o">}</span>
	 <span class="o">}</span>

	<span class="kd">private</span> <span class="kt">void</span> <span class="nf">calculateTotalAmounts</span><span class="o">()</span> <span class="o">{</span> 
		<span class="k">this</span><span class="o">.</span><span class="na">totalAmounts</span> <span class="o">==</span> <span class="k">new</span> <span class="nc">Money</span><span class="o">(</span><span class="n">orderLines</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
			<span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">x</span> <span class="o">-&gt;</span> <span class="n">x</span><span class="o">.</span><span class="na">getAmounts</span><span class="o">().</span><span class="na">getValue</span><span class="o">()).</span><span class="na">sum</span><span class="o">());</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>이 코드의 set 메서드는 접근 범위가 private 이다.<ul><li>즉, 클래스 내부에서ㅔ 데이터를 변경할 목적으로 사용되며 외부에선 데이터를 호출할 수 없다.</ul><li>불변 밸류 타입을 사용하면 자연스럽게 밸류 타입엔 set 메서드를 구현하지 않도록 하여 불변 타입의 장점을 살리도록 한다.</ul><blockquote><p><strong>DTO의 get/set 메서드</strong>: DTO가 도메인 로직을 담고 있지는 않기에 get/set 메서드를 제공해도 도메인 객체의 데이터 일관성에 영향을 줄 가능성이 높지 않다.</p></blockquote><h2 id="도메인-용어">도메인 용어</h2><ul><li>코드를 작성할 때 도메인에서 사용하는 용어는 매우 중요하다. 도메인에서 사용하는 용어를 코드에 반영하지 않으면 그 코드는 개발자에게 코드의 의미를 해석해야 하는 부담을 준다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">OrderState</span> <span class="o">{</span>
	<span class="no">STEP1</span><span class="o">,</span> <span class="no">STEP2</span><span class="o">,</span> <span class="no">STEP3</span><span class="o">,</span> <span class="no">STEP4</span><span class="o">,</span> <span class="no">STEP5</span><span class="o">,</span> <span class="no">STEP6</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeShippingInfo</span><span class="o">(</span><span class="nc">ShippingInfo</span> <span class="n">shippingInfo</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">verifySetp1OrStep2</span><span class="o">();</span>
		<span class="o">...</span>
	<span class="o">}</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">verityStep1OrStep2</span><span class="o">()</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>기획자나 온라인 쇼핑 도메인 전문가가 개발자와의 업무 회의에서 ‘출고 전’이라는 단어를 사용하면 개발자는 머릿속으로 ‘출고 전은 STEP1과 STEP2’라고 도메인 지식을 코드로 해석해야 한다.<li>도메인 용어는 좋은 코드를 만드는 데 매우 중요하지만 국내 개발자에게 불리한 면이 있다. 바로 영어 때문이다.<ul><li>분야의 특성상 알파벡과 숫자를 사용해서 클래스, 필드, 메서드 등의 이름을 작성하게 되는데 이는 도메인 용어를 영어로 해석하는 노력이 필요함을 뜻한다.</ul><li><b>알맞은 영어 단어를 찾는 것은 쉽지 않은 일이지만 시간을 들여 찾는 노력을 해야 한다. 적절한 단어를 사용하려는 노력하지 않는다면 코드는 도메인과 점점 멀어지게 된다.</b></ul><h1 id="chapter2-아키텍처-개요">Chapter2-아키텍처 개요</h1><h2 id="네-개의-영역">네 개의 영역</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/234268594-9c085f5e-5bb9-4a05-8a34-b9948eb0ecb6.png" alt="image" /></p><h3 id="표현-영역">표현 영역</h3><ul><li>표현 영역(UI영역)은 사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할을 한다.<ul><li>표현 영역의 사용자는 웹 브라우저를 사용하는 사람일 수 도 있고, REST API 를 호출하는 외부 시스템일 수도 있다.</ul><li>표현 영역을 통해 사용자의 요청을 전달받는 응용 영역은 시스템이 사용자에게 제공해야 할 기능을 제공한다.<ul><li>예를 들어, ‘주문 등록’, ‘주문 취소’, ‘상품 상세조회’ 와 같은 기능을 구현한다.</ul></ul><h3 id="응용-영역">응용 영역</h3><ul><li>응용 영역은 기능을 구현하기 위해 도메인 영역의 도메인 도메인 모델을 사용한다.<li><b>응용 서비스는 로직을 직접 수행하기보단 도메인 모델에 로직 수행을 위임한다. 마치 아래 예제 코드처럼 Order 도메인 모델에 취소 처리를 위임하는 것처럼.</b></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CancelOrderService</span> <span class="o">{</span>
    <span class="o">...</span>

    <span class="nd">@Transactional</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cancel</span><span class="o">(</span><span class="nc">String</span> <span class="n">orderId</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">findOrderById</span><span class="o">(</span><span class="n">orderId</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">order</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">OrderNotFoundException</span><span class="o">(</span><span class="n">orderId</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="n">order</span><span class="o">.</span><span class="na">cancel</span><span class="o">();</span>
    <span class="o">}</span>

	<span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/234268635-6cf25196-3a46-48f5-828f-f741086b1b8e.png" alt="image" /></p><h3 id="도메인-영역">도메인 영역</h3><ul><li>도메인 영역은 도메인 모델을 구현한다.<ul><li>도메인 모델은 도메인의 핵심 로직을 구현한다. (ex. 주문 도메인의 배송지 변경, 결제 완료, 주문 총액 계산과 같은)</ul></ul><h3 id="인프라스트럭처-영역">인프라스트럭처 영역</h3><ul><li>구현 기술에 대한 것을 다룬다.<li>예를 들어, RDBMS, MessageQueue, 몽고 DB, HBase 와의 연동을 처리한다.<li>추가적으로 SMTP를 이용한 메일 발송 기능을 구현하거나 HTTP 클라이언트를 이용해서 REST API 를 호출하는 것도 처리한다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/234268698-ff2e4ceb-8b22-4fe7-800e-f0c4487a6aff.png" alt="image" /></p><blockquote><p>도메인, 응용, 표현 영역은 실제 구현 기술을 사용한 코드를 직접 만들지 않는다. 대신 인프라스트럭처 영역에서 제공하는 기능을 ㅅ용해서 필요한 기능을 개발한다. 예를 들어, 응용 영역에서 DB에 보관된 데이터가 필요하면 인프라스트럭처 영역의 DB 모듈을 사용해서 데이터를 읽어온다. 비슷하게 외부에 메일을 발송하려면 인프라스트럭처가 제공하는 SMTP 연동 모듈을 이용해 메일을 발송한다.</p></blockquote><h2 id="계층-구조-아키텍처">계층 구조 아키텍처</h2><ul><li>네 영역을 구성할 때 많이 사용하는 아키텍처가 [그림2.4]와 같은 계층 구조이다.<ul><li>도메인의 복잡도에 따라 응용과 도메인을 분리하기도 하고 합치기도 한다.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/234274426-7259e107-79eb-40ba-a940-41d3edcf2b3e.png" alt="image" /></p><ul><li>계층 구조는 단방향(하위 계층)으로만 의존하게 한다.<li>계층 구조를 엄격하게 적용하면 상위 계층은 바로 아래 계층에만 의존을 가져야 하지만, 구현의 편리함을 위해 계층 구조를 유옇나게 적용한다.<ul><li>예를 들어, 응용 계층에서 외부 시스템과의 연동을 위해 더 아래 계층인 인프라 계층에 의존하기도 한다.</ul><li>계층 구조에 따르면 도메인과 응용 계층은 룰 엔진과 DB 연동을 위해 아래 이밎와 같이 인프라 모듈에 의존하게 된다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/234274386-d00a1aa5-e365-47c0-bf4d-198bb69db6b4.png" alt="image" /></p><ul><li>여기서 짚고 넘어가야 할 것은 표현, 응용, 도메인 계층이 상세한 구현 기술을 다루는 인프라 계층에 종속된다는 점이다.<li>이때 문제가 생길 수 있는 부분이 있다.<li>도메인의 가격 계산 규칙을 정할 때 할인 금액 계산 로직이 복잡해지면 객체 지향으로 로직을 구현하는 것 보단 룰 엔진을 사용하는 것이 더 알맞을 때가 있다.<li><code class="language-plaintext highlighter-rouge">Drools</code>라는 룰 엔진을 사용해서 로직을 수행할 수 있는 인프라 스트럭처 코드이다. (Drools는 무시해도 된다.)<li>핵심은 evalute() 메서드에 값을 주면 별도 파일로 작성한 규칙을 이용해서 연산을 수행하는 코드라는 것 정도로만 이해하면 된다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="c1">// 인프라스트럭처 영역</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">DroolsRuleEngine</span> <span class="o">{</span>
 <span class="o">...</span>
 <span class="kd">public</span> <span class="kt">void</span> <span class="nf">evalute</span><span class="o">(</span><span class="nc">String</span> <span class="n">sessionName</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">facts</span><span class="o">)</span> <span class="o">{</span>
  <span class="o">...</span>
 <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p>응용 영역은 가격 계산을 위해 인프라스트럭처 영역의 DroolsRuleEngine을 사용한다.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// 응용 영역</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CalculateDiscountService</span> <span class="o">{</span>
 
 <span class="kd">private</span> <span class="nc">DroolsRuleEngine</span> <span class="n">ruleEngine</span><span class="o">;</span>

 <span class="kd">public</span> <span class="nf">CalculateDiscountService</span><span class="o">()</span> <span class="o">{</span>
	<span class="n">ruleEngine</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DroolsRuleEngine</span><span class="o">();</span>
 <span class="o">}</span>

 <span class="kd">public</span> <span class="nc">Money</span> <span class="nf">calculateDiscount</span><span class="o">(</span><span class="nc">OrderLine</span> <span class="n">orderLines</span><span class="o">,</span> <span class="nc">String</span> <span class="n">customerId</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Customer</span> <span class="n">customer</span> <span class="o">=</span> <span class="n">findCusotmer</span><span class="o">(</span><span class="n">customerId</span><span class="o">);</span>

  <span class="nc">MutableMoney</span> <span class="n">money</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">MutableMoney</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
  <span class="nc">List</span><span class="o">&lt;?&gt;</span> <span class="n">facts</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">customer</span><span class="o">,</span> <span class="n">money</span><span class="o">);</span>
  <span class="n">facts</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">orderLines</span><span class="o">);</span>
  <span class="n">ruleEngine</span><span class="o">.</span><span class="na">evalute</span><span class="o">(</span><span class="s">"discountCalculation"</span><span class="o">,</span> <span class="n">facts</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">money</span><span class="o">.</span><span class="na">toImmutableMoney</span><span class="o">();</span>
 <span class="o">}</span>
 <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>위 응용 영역에 위치한 서비스 코드는 두 가지 문제가 존재한다.<ul><li>1)CalculateDiscountService 만 테스트하기 어렵다. RuleEnigne이 완벽하게 동작해야만 하며 이에 대한 설정 파일도 필요하게 된다.<li>2)구현 방식을 변경하기 어렵다는 점이다. <code class="language-plaintext highlighter-rouge">discountCalculation</code> 문자열은 <code class="language-plaintext highlighter-rouge">Drools</code>의 세션 이름이다. Drools의 세션 이름을 변경시 CalculateDiscountService의 코드도 같이 변경되어야한다.</ul><li><b>이처럼 인프라스트럭처 계층에 의존하면 테스트의 어려움과 기능 확장의 어려움 이라는 두 가지 문제가 생긴다. 이를 해결하기 위해 SOLID 원칙 중 하나인 DIP 를 적용하면 된다.</b></ul><h2 id="dip">DIP</h2><ul><li>가격 할인 계산을 하려면 아래 이미지의 왼쪽과 같이 고객 정보를 구해야 하고, 구현할 고객 정보와 주문 정보를 이용해서 룰을 실행해야 한다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235098336-7c953ac9-34ee-4c44-973d-fa68bafde52d.png" alt="image" /></p><ul><li>위 이미지에서 <code class="language-plaintext highlighter-rouge">CalculateDicountService</code> 는 고수준 모듈이다.<li><b>고수준 모듈이란 의미 있는 단일 기능을 제공하는 모듈이다.</b><li><code class="language-plaintext highlighter-rouge">CalculateDicountService</code>는 ‘가격 할인 계산’ 이라는 기능을 구현한다.<li><b>고수준 모듈의 기능을 구현하려면 여러 하위 기능이 필요하다.</b><li>가격 할인 계산 기능을 구현하려면 고객 정보를 구해야 하고 룰을 실힝해야 하는데 이 두 기능이 하위 기능이다.<li><b>저수준 모듈은 하위 기능을 실제로 구현한 것이다.</b><li><p>[그림 2.7] 에서 JPA를 이용해서 고객 정보를 읽어오는 모듈과 Drools로 룰을 실행하는 모듈이 저수준 모듈이다.</p><li>고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 한다. 그런데, 고수준 모듈이 저수준 모듈을 사용하면 앞서 계층 구조 아키텍처에서 언급했던 두 가지 문제(구현 변경과 테스트가 어려움)가 발생한다.<li><b>DIP 는 이 문제를 해결하기 위해 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다.</b><ul><li><b>이렇게 하기 위해서 추상화한 인터페이스가 필요하게 된다.</b></ul><li>CalculateDiscountService 입장에서 봤을 땐 룰 적용을 Drools 로 구현했는지, 자바로 직접 구현했는지 중요치 않다.<ul><li>단지, ‘고객 정보와 구매 정보에 룰을 적용해서 할인 금액을 구한다’ 는 것이 중요할 뿐이다.</ul><li>이를 추상화한 인터페이스는 다음과 같다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">RuleDiscounter</span> <span class="o">{</span>
  <span class="n">publis</span> <span class="nc">Money</span> <span class="nf">applyRules</span><span class="o">(</span><span class="nc">Customer</span> <span class="n">customer</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderLine</span><span class="o">&gt;</span> <span class="n">orderLines</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><p>이제 CalCulateDiscountService 가 RuleDiscounter 를 이용하도록 바꿔보자.</p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CalculateDiscountService</span> <span class="o">{</span>
 <span class="kd">private</span> <span class="nc">RuleDiscounter</span> <span class="n">ruleDiscounter</span><span class="o">;</span>
 <span class="kd">private</span> <span class="nc">CustomerRepository</span> <span class="n">customerRepository</span><span class="o">;</span>

 <span class="kd">public</span> <span class="nf">CalculateDiscountService</span><span class="o">(</span><span class="nc">RuleDiscounter</span> <span class="n">ruleDiscounter</span><span class="o">,</span> <span class="nc">CustomerRepository</span> <span class="n">customerRepository</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">this</span><span class="o">.</span><span class="na">ruleDiscounter</span> <span class="o">=</span> <span class="n">ruleDiscounter</span><span class="o">;</span>
  <span class="k">this</span><span class="o">.</span><span class="na">customerRepository</span> <span class="o">=</span> <span class="n">customerRepository</span>
 <span class="o">}</span>

 <span class="kd">public</span> <span class="nc">Money</span> <span class="nf">calculateDiscount</span><span class="o">(</span><span class="nc">OrderLine</span> <span class="n">orderLines</span><span class="o">,</span> <span class="nc">String</span> <span class="n">customerId</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Customer</span> <span class="n">customer</span> <span class="o">=</span> <span class="n">customerRepository</span><span class="o">.</span><span class="na">findCusotmer</span><span class="o">(</span><span class="n">customerId</span><span class="o">);</span>
  <span class="k">return</span> <span class="n">ruleDiscounter</span><span class="o">.</span><span class="na">applyRules</span><span class="o">(</span><span class="n">customer</span><span class="o">,</span> <span class="n">orderLines</span><span class="o">);</span>
 <span class="o">}</span>

 <span class="kd">private</span> <span class="nc">Customer</span> <span class="nf">findCustomer</span><span class="o">(</span><span class="nc">String</span> <span class="n">customerId</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Customer</span> <span class="n">customer</span> <span class="o">=</span> <span class="n">customerRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">customerId</span><span class="o">);</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">customer</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoCustomerException</span><span class="o">();</span>
  <span class="k">return</span> <span class="n">customer</span><span class="o">;</span>
 <span class="o">}</span>
 <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>CalculateDiscountService 는 Drools 에 의존하는 코드를 포함하고 있지 않다.<ul><li>단지 RuleDiscounter가 룰을 적용한다는 것만 알 뿐이다.</ul><li>룰 적용을 구현한 클래스는 RuleDiscounter 인터페이스를 상속받아 구현하다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DroolsRuleDiscounter</span> <span class="kd">implements</span> <span class="nc">RuleDiscounter</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="nc">Money</span> <span class="nf">applyRule</span><span class="o">(</span><span class="nc">Customer</span> <span class="n">customer</span><span class="o">,</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderLine</span><span class="o">&gt;</span> <span class="n">orderLines</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 실제 구현 코드 생략</span>
    <span class="k">return</span> <span class="n">money</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>아래 이미지는 RuleDiscounter가 출현하면서 바뀐 구조를 보여주고 있다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235101642-f9ab4ffe-4411-4023-902b-ded94fdd6206.png" alt="image" /></p><ul><li>위 이미지 [그림 2.8]의 구조를 보면 CalculateDiscountService는 더 이상 구현 기술인 Drools에 의존하지 않는다.<li>‘룰을 이용한 할인 금액 계산’을 추상화한 RuleDiscounter 인터페이스에 의존할 뿐이다.<li>‘룰을 이용한 할인 금액 계산’은 고수준 모듈의 개념이므로 RuleDiscounter 인터페이스는 고수준 모듈에 속한다.<li>DroolsRuleDiscounter는 고수준의 하위 기능인 RuleDiscounter를 구현한 것이므로 저수준 모듈에 속한다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235102240-ebd13e68-3163-4c29-a71f-7189309af376.png" alt="image" /></p><ul><li>DIP를 적용하면 위 이미지와 같이 저수준 모듈이 고수준 모듈에 의존하게 된다.<ul><li>고수준 모듈이 저수준 모듈을 사용하려면 고수준 모듈이 저수준 모듈에 의존해야 하는데, 반대로 저수준 모듈이 고수준 모듈에 의존한다고 해서 이를 DIP(Dependency Inversion Principle, 의존 역전 원칙) 라고 부른다.</ul><li>이처럼 DIP를 적용하면 앞서 다른 영역이 인프라스트럭처 영역에 의존할 때 발생했떤 두 가지 문제인 구현 교체가 어렵다는 문제와 테스트가 어려운 문제를 해소할 수 있다.</ul><h3 id="1-구현체-교체의-어려움-해결">1) 구현체 교체의 어려움 해결</h3><ul><li>고수준 모듈은 더 이상 저수준 모듈에 의존하지 않고 구현을 추상화한 인터페이스에 의존한다.<li>실제 사용할 저수준 구현 객체는 아래 코드처럼 의존 주입을 이용해 전달받을 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// 사용할 저수준 객체 생성</span>
<span class="nc">RuleDiscounter</span> <span class="n">ruleDiscounter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">DroolsRuleDiscounter</span><span class="o">();</span>

<span class="c1">// 생성자 방식으로 주입</span>
<span class="nc">CalculateDiscountService</span> <span class="n">calculateDiscountService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CalculateDiscountService</span><span class="o">(</span><span class="n">ruleDiscounter</span><span class="o">);</span>
</pre></table></code></div></div><ul><li>만약 구현 기술을 변경하더라도 CalculateDicountService를 수정할 필요가 없다.<li>아래 코드처럼 사용할 저수준 구현 객체를 생성하는 부분의 코드만 변경하면 되기 때문이다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// 사용할 저수준 구현 객체 변경</span>
<span class="nc">RuleDiscounter</span> <span class="n">ruleDiscounter</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SimpleRuleDiscounter</span><span class="o">();</span>

<span class="c1">// 사용할 저수준 모듈을 변경해도 고수준 모듈을 수정할 필요가 없다.</span>
<span class="nc">CalculateDiscountService</span> <span class="n">calculateDiscountService</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CalculateDiscountService</span><span class="o">(</span><span class="n">ruleDiscounter</span><span class="o">);</span>
</pre></table></code></div></div><ul><li>의존 주입을 지원하는 스프링과 같은 프레임워크를 사용하면 설정 코드를 수정해서 쉽게 구현체를 변경할 수 있다.</ul><h3 id="1-테스트-어려움-해결">1) 테스트 어려움 해결</h3><ul><li>CalculateDiscountService가 제대로 동작하는지 테스트하려면 CustomerRepository와 RuleDiscounter를 구현한 객체가 필요하다.<li>하지만 둘 다 인터페이스로 추상화 했기 때문에 대용 객체를 사용해서 테스트를 진행할 수 있다.<li>다음은 대용 객체를 사용해서 Customer가 존재하지 않는 경우 익셉션이 발생하는지 검증하는 테스트 코드인데, 실제 구현 클래스 없이 테스트 가능함을 보여준다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CalculateDiscountServiceTest</span> <span class="o">{</span>

  <span class="nd">@Test</span><span class="o">(</span><span class="n">expected</span> <span class="o">=</span> <span class="nc">NoCustomerException</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">noCustomer_thenExceptionShouldBeThrown</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 테스트 목적의 대용 객체</span>
    <span class="nc">CustomerRepository</span> <span class="n">stubRepo</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="nc">CustomerRepository</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
    <span class="n">when</span><span class="o">(</span><span class="n">stubRepo</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="s">"noCustId"</span><span class="o">)).</span><span class="na">thenReturn</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>

    <span class="nc">RuleDiscounter</span> <span class="n">stubRule</span> <span class="o">=</span> <span class="o">(</span><span class="n">cust</span><span class="o">,</span> <span class="n">lines</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="kc">null</span><span class="o">;</span>

    <span class="c1">// 대용 객체를 주입받아 테스트 진행</span>
    <span class="nc">CalculateDiscountService</span> <span class="n">calcDisSvc</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">CalculateDiscountService</span><span class="o">(</span><span class="n">stubRepo</span><span class="o">,</span> <span class="n">stubRule</span><span class="o">);</span>
    <span class="n">calcDisSvc</span><span class="o">.</span><span class="na">calculateDiscount</span><span class="o">(</span><span class="n">someLines</span><span class="o">,</span> <span class="s">"noCustId"</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>이렇게 실제 구현 없이 테스트 할 수 있는 이유는 DIP를 적용해서 고수준 모듈이이 저수준 모듈에 의존하지 않도록 했기 때문이다.<ul><li>고수준 모듈인 CalculateDiscountService는 저수준 모듈에 직접 의존하지 않기 때문에 실제 저수준 구현 클래스 없이도 테스트 대용 객체를 이용해서 거의 모든 기능을 테스트할 수 있는 것이다.</ul></ul><h2 id="dip-주의사항">DIP 주의사항</h2><ul><li><b>DIP의 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함이다.</b><li>하지만 아래 이미지와 같이 저수준 모듈에서 인터페이스를 추출하는 경우가 있다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235111140-fd0ce401-ae16-49b2-924e-fbb77a393c1b.png" alt="image" /></p><ul><li>위 이미지는 잘못된 구조이다.<li>이 구조에서 도메인 영역은 이프라 스트러거 영역에 의존하고 있다.<ul><li>즉, 여전히 고수준 모듈이 저수준 모듈에 의존하고 있는 것이다.</ul><li>RuleEngine 인터페이스는 고수준 모듈인 도메인 관점이 아니라 룰 엔진이라는 저수준 모듈 관점에서 도출한 것이다.<li><b>DIP를 적용할 때 하위 기능을 추상화한 인터페이스는 고수준 모듈 관점(도메인 영역)에서 도출한다.</b><ul><li>CalculateDiscountService 입장에서 봤을 때 할인 금액을 구하기 위해 룰 엔진을 사용하는지, 직접 연산하는지 여부는 중요치 않다.<li>단지 규칙에 따라 할인 금액을 계산한다는 것이 중요할 뿐이다.<li>즉, ‘할인 금액 계산’을 추상화한 인터페이스는 저수준 모듈이 아닌 고수준 모듈에 위치한다.(아래 이미지 참고)</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235112160-2a49ff3a-a307-4af8-ae11-bf811e22fb2e.png" alt="image" /></p><h2 id="dip와-아키텍처">DIP와 아키텍처</h2><ul><li><b>인프라스트럭처 영역은 구현 기술을 다루는 저수준 모듈이고 응용 영여과 도메인 영역은 고수준 모듈이다.</b><li>인프라스트럭처 계층의 가장 하단에 위치하는 계층형 구조와 달리 아키텍처에 DIP를 적용하면 [그림 2.12]와 같이 인프라스트럭처 영역이 응용 영역과 도메인 영역에 의존(상속)하는 구조가 된다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235112627-ff9a15d9-a9a4-4250-bf37-9a4c796cdff1.png" alt="image" /></p><ul><li>인프라스트럭처에 위치한 클래스가 도메인이나 응용 영역에 정의한 인터페이스를 상속받아 구현하는 구조가 되므로 도메인과 응용 영역에 대한 영향을 주지 않거나 최소화하면서 구현 기술을 변경하는 것이 가능하다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235113218-9f1eb69f-5cb0-4e85-99b9-279c57838556.png" alt="image" /></p><ul><li>위 이미지에서 인프라스트럭처 영역의 EmailNotifier 클래스는 응용 영역의 Notifier 인터페이스를 상속 받고 있다.<ul><li>주문 시 통지 방식에 SMS를 추가해야 한다는 요구사항이 들어왔을땐 응용 영역의 OrderService를 변경할 필요가 없다.<li>[그림 2.14]와 같이 두 통지 방식을 함께 제공하는 Notifier 구현 클래스를 인프라 스트럭처 영역에 추가하면 된다.<li>비슷하게 MyBatis 대신 JPA를 구현 기술로 사용하고 싶다면 JPA를 이용한 OrderRepository 구현 클래스를 인프라스트럭처 영역에 추가하면 된다.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235114051-49e32776-a87d-4374-8b6c-a251e309c411.png" alt="image" /></p><h2 id="도메인-영역의-주요-구성요소">도메인 영역의 주요 구성요소</h2><ul><li>엔티티:<ul><li>고유의 식별자를 갖는 객체로 자신의 라이프 사이클을 가진다.<li>주문(Order), 회원(Member), 상품(Product)과 같이 도메인의 고유한 개념을 표현한다.<li>도메인 모델의 데이터를 포함하며 해당 데이터와 관련된 기능을 함께 제공한다.</ul><li>밸류:<ul><li>고유의 식별자를 갖지 않는 개체로 주로 개념적으로 하나인 도메인 객체의 속성을 표현할 때 사용된다.<li>주소(Address), 금액(Money)와 같은 타입이 밸류 타입이다.<li>엔티티의 속성으로 사용될 뿐 아니라 다른 밸류 타입의 속성으로도 사용될 수 있다.</ul><li>애그리거트(Aggregate):<ul><li>관련된 엔티티와 밸류 객체를 개념적으로 하나로 묶은 것이다.<li>예를 들어, 주문과 관련된 Order 엔티티, OrderLine 밸류, Orderer 밸류 객체를 ‘주문’ 애그리거트로 묶을 수 있다.</ul><li>리포지토리(Repository):<ul><li>도메인 모델의 영속성을 처리한다.</ul><li>도메인 서비스(Domain Service):<ul><li>특정 엥ㄴ티티에 속하지 않은 도메인 로직을 제공한다.<li>‘할인 금액 계산’은 상품, 쿠폰, 회원 등급, 구매 금액 등 다양한 조건을 이용해서 구현하게 되는데, 이렇게 도메인 로직이 여러 엔티티와 밸류를 필요로 할 경우 도메인 서비스에서 로직을 구현한다.</ul></ul><h2 id="엔티티와-밸류">엔티티와 밸류</h2><ul><li><b>실제 도메인 모델의 엔티티와 DB 관계형 모델의 엔티티는 같은 것이라 볼 수 없다.</b><li>위 두 모델의 가장 큰 차이점은 도메인 모델의 엔티티는 데이터와 도메인 기능을 함께 제공한다는 점이다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
  <span class="c1">// 주문 도메인 모델의 데이터</span>
  <span class="kd">private</span> <span class="nc">OrderNo</span> <span class="n">number</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">Orderer</span> <span class="n">orderer</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">ShippingInfo</span> <span class="n">shippingInfo</span><span class="o">;</span>

  <span class="c1">// 도메인 모델 엔티티는 모데인 기능도 함께 제공</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeShippingInfo</span><span class="o">(</span><span class="nc">ShippingInfo</span> <span class="n">newShippingInfo</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>또 다른 차이점은 모데인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있다는 것ㅇ이다.<li>위 코드에서 주문자를 푠현하는 Orderer 는 밸류 타입으로 다음과 같이 주문자이름과 이메일 데이터를 포함할 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Orderer</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>이를 DB 테이블로 표현하려면 아래 이미지와 같이 두 가지 방식을 적용할 수 있다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235301044-255b68cf-5f74-4b2f-b2dd-03aae990ee20.png" alt="스크린샷 2023-04-29 오후 8 52 19" /></p><ul><li>왼쪽 테이블의 경우 주문자(Orderer)라는 개념이 드러나지 않고 주문자의 개별 데이터만 드러난다.<li>오른쪽 테이블의 경우 주문자 데이터를 별도 테이블에 저장했찌만 이는 테이블의 엔티티에 가깝지 밸류 타입의 의미가 드러나진 않는다.<li><b>반면 도메인 모델의 Orderer 는 주문자라는 개념을 잘 반영하므로 도메인을 보다 잘 이해할 수 있도록 돕는다.</b><li>그리고 앞서 설명했던 것처럼 밸류는 불변으로 구현하는 것을 권장한다.<ul><li>이는 엔티티의 밸류 타입 데이터를 변경시 객체 자체를 완전히 새로 교체한다는 것을 의미한다.</ul></ul><h1 id="chapter3-애그리거트">Chapter3-애그리거트</h1><h2 id="애그리거트">애그리거트</h2><h3 id="애그리거트의-필요성">애그리거트의 필요성</h3><ul><li>도메인이 커질수록 개발할 도메인 모델도 커지면서 많은 엔티티와 밸류가 출현한다.<li>엔티티와 밸류 개수가 많아지면 많아질수록 모델은 점점 더 복잡해진다.<li>도메인 모델이 복잡해지면 개발자가 전체 구조가 아닌 한 개 엔티티와 밸류에만 집중하게 되는 경우가 발생한다.<li>이떄 상위 수준에서 모델을 관리하기보다 개별 요소에만 초점을 맞추다 보면 큰 수준에서 모델을 이해하지 못해 큰 틀에서 모델을 관리할 수 없는 상항에 빠질 수 있다.<li><b>도메인 모델도 개별 객체뿐만 아니라 상위 수준에서 모델을 볼 수 있어야 전체 모델의 관계와 개별 모델을 이해하는데 도움이 된다.</b><li><b>도메인 모델에서 전체 구조를 이해하는데 도움이 되는 것이 바로 애그리거트(Aggregate) 이다.</b></ul><h3 id="애그리거트의-정의">애그리거트의 정의</h3><ul><li><b>애그리거트는 관련 객체를 하나로 묶은 군집이다.</b><li>대표적인 예가 주문이다.<ul><li>주문이라는 도메인 개념은 ‘주문’, ‘배송지 정보’, ‘주문자’, ‘주문목록’, ‘총결제 금액’ 의 하위 모델로 구성되는데 이때 이 하위 개념을 표현한 모델을 하나로 묶어서 ‘주문’이라는 상위 개념으로 표현할 수 있다.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235301514-75b94e77-986d-416c-af65-3dcc04b33473.png" alt="스크린샷 2023-04-29 오후 9 03 36" /></p><ul><li>애그리거트를 사용하면 개별 객체가 아닌 관련 객체를 묶어서 객체 군집 단위로 모델을 바라볼 수 있게 된다.<li><p><b>개별 객체 간의 관계가 아닌 애그리거트 간의 관계로 도메인 모델을 이해하고 구현할 수 있게 되며, 이를 통해 큰 틀에서 도메인 모델을 관리할 수 있게 된다.</b></p><li>애그리거트는 군집에 속한 객체들을 관리하는 루트 엔티티를 갖는다.<li><b>루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다.</b><li><b>애그리거트를 사용하는 코드는 애그리거트 루트가 제공하는 기능을 실행하고 애그리거트 루트를 통해서 간접적으로 애그리거트 내의 다른 엔티티나 밸류 객체에 접근하게 된다.</b><li><b>이는 애그리거트의 내부 구현을 숨겨서 애그리거트 단위로 구현을 캡슐화할 수 있도록 돕는다.</b></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235301502-5ac7c3ba-1fa4-4fcd-a89f-d9a34748746c.png" alt="스크린샷 2023-04-29 오후 9 03 14" /></p><ul><li>위 이미지는 주문 애그리거트를 보여주고 있다.<li>애그리거트 루트인 Order는 주문 도메인 로직에 맞게 애그리거트의 상태를 관리한다.<li>예를 들어, Order의 배송지 정보 변경 기능은 배송지를 변경할 수 있는지 확인한 뒤에 배송지 정보를 변경한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
 <span class="o">...</span>
 <span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeShippingInfo</span><span class="o">(</span><span class="nc">ShippingInfo</span> <span class="n">shippinginfo</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">checkShippingInfoChangeable</span><span class="o">();</span> <span class="c1">// 배송지 변경 가능 여부 확인</span>
  <span class="k">this</span><span class="o">.</span><span class="na">shippingInfo</span> <span class="o">=</span> <span class="n">newInfo</span><span class="o">;</span>
 <span class="o">}</span>

 <span class="kd">private</span> <span class="nc">Boolean</span> <span class="nf">checkShippingInfoChangeable</span><span class="o">()</span> <span class="o">{</span>
  <span class="o">...</span> <span class="n">배송지</span> <span class="n">정보를</span> <span class="n">변경할</span> <span class="n">수</span> <span class="n">있는지</span> <span class="n">여부를</span> <span class="n">확인하는</span> <span class="n">도메인</span> <span class="n">규칙</span> <span class="n">구현</span>
 <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>checkShippingInfoChangeable() 메서드는 도메인 규칙에 따라 배송지를 변경할 수 있는지 확인할 것이다.<ul><li>예를 들어, 이미 배송이 시작된 경우 익셉션을 발생하는 식으로 도메인 규칙을 구현할 것이다.</ul><li>주문 애그리거트는 Order 를 통하지 않고 ShippingInfo를 변경할 수 있는 방법을 제공하지 않는다.<ul><li><b>즉, 배송지를 변경하려면 루트 엔티티인 Order 를 사용해야 하므로 배송지 정보를 변경시엔 Order 가 구현한 로직을 항상 따르게 된다.</b></ul><li>애그리거트를 구현할 떈 고려할 것이 많다.<ul><li><b>애그리거트를 어떻게 구성했느냐에 따라 구현이 복잡해지기도 하고 트랜잭션 범위가 달라지기도 한다.</b><li>또한 선택한 구현 기술에 따라 애그리거트 구현에 제약이 생기기도 한다.<li>애그리거트의 구현에 대한 내용은 3장에서 자세히 다룬다.</ul></ul><h2 id="리포지터리">리포지터리</h2><ul><li>도메인 객체를 지속적으로 사용하기 위해서는 RDBMS, NoSQL, 로컬 파일과 같은 물리적인 저장소에 도메인 객체를 보관해야한다.<li>이를 위한 도메인 리포지터리이다.<li><b>리포지터리는 애그리게이트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.</b></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">OrderRepository</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nc">Order</span> <span class="nf">findByNumber</span><span class="o">(</span><span class="nc">OrderNumber</span> <span class="n">number</span><span class="o">);</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">(</span><span class="nc">Order</span> <span class="n">order</span><span class="o">);</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="nc">Order</span> <span class="n">order</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>도메인 모델을 사용해야 하는 코드(주로 응용 서비스 영역의 코드일 것이다) 는 리포지토리를 통해 도메인 객체를 구한 뒤 도메인 객체의 기능을 실행하게 된다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CancelOrderService</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">OrderRepository</span> <span class="n">orderRepository</span><span class="o">;</span> <span class="c1">// DI</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cancel</span><span class="o">(</span><span class="nc">OrderNumber</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderRepository</span><span class="o">.</span><span class="na">findByNumber</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">order</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoOrderException</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>
    <span class="n">order</span><span class="o">.</span><span class="na">cancel</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li><b>도메인 모델 관점에서 OrderRepository 는 도메인 객체를 영속화하는데 필요한 기능을 추상화한 것으로 고수준 모델에 속한다.</b><li>기반 기술을 이용해 OrderRepository를 구현한 클래스는 저수준 모듈로 인프라스트럭처 영역에 속한다.<li>즉, 모듈 구조는 아래 이미지와 같을 것이다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235342801-cfb5a878-7ebb-4611-9103-cf227b32a993.png" alt="스크린샷 2023-04-30 오후 5 10 18" /></p><h2 id="요청-처리-흐름">요청 처리 흐름</h2><ul><li>표현 영역은 사용자가 전송한 데이터 형식을 올바른지 검사하고 문제가 없다면 데이터를 이용해서 으용 서비스에 기능 실행을 위임한다.<li>이떄 표현 영역은 사용자가 전송한 데이터를 응용 서비스가 요구하는 형식으로 변환해서 전달한다.<ul><li>RQ 모델을 그대로 응용 서비스에 전달하는게 아닌 validation 체크 후 도메인 모델로 컨버팅해서 전달하는 방식이 될 것이다.</ul><li>웹 브라우저를 이용해서 기능 실행을 요청할 경우, 아래 이미지처럼 표현 영역에 해당하는 컨트롤러는 과정1.1처럼 HTTP 요청 파라미터를 응용 서비스가 필요로 하는 데이터로 변환 후 응용 서비스를 실행할 떄 파라미터로 전달한다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235343018-3c1e3a4b-92a7-426b-9af3-6e008a0be7d9.png" alt="스크린샷 2023-04-30 오후 5 16 21" /></p><ul><li>응용 서비스는 도메인 모델을 이용해 기능을 구현한다.<li>기능 구현에 필요한 도메인 객체를 리포지토리에서 가져와 실행하거나 신규 도메인 객체를 생성해서 리포지터리에 쩌장한다.<ul><li>두 개 이상의 도메인 객체를 사용해서 구현하기도 한다.</ul><li>응용 서비스의 역할 중 하나는 아래 코드와 같이 트랜잭션을 관리하는 것이다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CancelOrderService</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">OrderRepository</span> <span class="n">orderRepository</span><span class="o">;</span> <span class="c1">// DI</span>

  <span class="nd">@Transactional</span> <span class="c1">// 응용 서비스는 트랜잭션을 관리한다.</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cancel</span><span class="o">(</span><span class="nc">OrderNumber</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderRepository</span><span class="o">.</span><span class="na">findByNumber</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">order</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoOrderException</span><span class="o">(</span><span class="n">number</span><span class="o">);</span>
    <span class="n">order</span><span class="o">.</span><span class="na">cancel</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="인프라스트럭처-개요">인프라스트럭처 개요</h2><ul><li>인프라스트럭처는 표현 영역, 응용 영역, 도메인 영역을 지원한다.<li>도메인 객체의 영속성 처리, 트랜잭션, SMTP 클라이언트, REST 클라이언트 등 다른 영역에서 필요로 하는 프레임워크, 구현 기술, 보조 기능을 지원한다.<li><p>DIP에서 언급했듯이 도메인 영역과 응용 영역이 인프라스트럭처의 기능을 직접 사용하는 것보다, 이 두 영역에 정의한 인터페이스를 인프라스트럭처 영역에서 구현하는 것이 시스템을 더 유연하고 테스트하기 쉽게 만들어준다.</p><li><b>하지만, 무조건 인프라스트럭처에 대한 의존을 없애는 것이 좋은 것은 아니다.</b><li>예를 들어, 스프링을 사용할 경우 응용 서비스는 트랜잭션 처리를 위해 스프링에 제공하는 <code class="language-plaintext highlighter-rouge">@Transactional</code> 을 사용하는 것이 편리하다.<li>영속성 처리를 위해 JPA를 사용할 경우 @Entity 나 @Table과 같은 JPA 전용 애노테이션을 도메인 모델 클래스에 사용하는 것이 XML 매핑 설정을 이용하는 것보다 편리하다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1">// 구현의 편리함을 위해ㅣ 인프라스트럭처에 대한 의존을 일부 도메인에 넣은 코드</span>
<span class="c1">// JPA의 @Table 애노테이션을 이용해서 엔티티를 저장할 테이블 이름을 지정했다.</span>
<span class="c1">// XML 설정 보다 편리하게 테이블 이름을 지정 가능하다.</span>
<span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"TBL_ORDER"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>

<span class="o">}</span>
</pre></table></code></div></div><ul><li>구현의 편리함은 DIP가 주는 다른 장점(변경의 유연함, 테스트가 쉬움) 만큼 중요하기 떄문에 DIP의 장점을 해치지 않는 범위에서 응용 영역과 도메인 영역에서 구현 기술에 대한 의존을 가져가는 것이 현명하다.<li>응용 영역과 도메인 영역이 인프라스트럭처에 대한 의존을 완전히 갖지 않도록 시도하는 것은 자칫 구현을 더 복잡하고 어렵게 만들 수 있다.<li>예를 들어, 스프링의 <code class="language-plaintext highlighter-rouge">@Transaction</code> 어노테이션을 사용하면 한 줄로 트랜잭션을 처리할 수 있는데, 코드에서 스프링에 대한 의존을 없애려면 복잡한 스프링 설정을 사용해야 한다.<ul><li>의존은 없애지만 특별히 테스트를 더 쉽게 할 수있다거나 유연함을 증가 시켜주지 못한다. 단지 설정만 복잡해지고 개발 시간만 늘어날 뿐이다…</ul></ul><h2 id="모듈-구성">모듈 구성</h2><ul><li>아키텍처의 각 영역은 패키지에 위치한다.<li>패키지 구성 규칙에 한 개의 정답만 존재하는 것은 아니지만 아래와 같이 영역별로 모듈이 위치할 때 패키지를 구성할 수 있을 것이다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235343343-73cb8948-cb51-4872-9cbb-c59064ceab88.png" alt="스크린샷 2023-04-30 오후 5 25 11" /></p><ul><li>도메인이 크면 아래 이미지의 [그림 2.22]와 같이 하위 도메인으로 나누고 각 하위 도메인마다 별도 패키지를 구성한다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235343459-22b6e204-8f43-4c03-8097-c4099f46bb54.png" alt="스크린샷 2023-04-30 오후 5 28 31" /></p><ul><li>domain 모듈은 도메인에 속한 애그리거트를 기준으로 다시 패키지를 구성한다.<ul><li>예를 들어, 카탈로그 하위 도메인을 위한 도메인은 상품 애그리거트와 카테고리 애그리거트로 구성된다고 할 경우, [그림 2.23] 과 같이 domain을 두 개의 하위 패키지로 구성해볼 수 있다.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235343466-9a91919c-3571-443e-a486-98a9010e39cc.png" alt="스크린샷 2023-04-30 오후 5 28 42" /></p><ul><li>각 애그리거트와 모델과 리포지토리는 같은 패키지에 위치시킨다.<ul><li>예를 들어, 주문고 ㅏ관련된 Order, OrderLine, OrderRepository 등은 com.myshop.order.domain 패키지에 위치시킨다.</ul><li>도메인이 복잡하면 도메인 모델과 도메인 서비스를 다음과 같이 별도 패키지에 위치시킬 수도 있다.</ul><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>com.myshop.order.domain.order: 애그리거트 위치
com.myshop.order.domain.servicee: 도메인 서비스 위치
</pre></table></code></div></div><p>응용 서비스도 다음과 같이 도메인 별로 패키지를 구분할 수 있다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>com.myshop.catalog.application.product
com.myshop.catalog.application.category
</pre></table></code></div></div><blockquote><p><strong>Note</strong>: 모듈 구조를 얼마나 세분화 할지에 대해서는 정해진 규칙은 없다. 한 패키지에 너무 많은 타입이 몰려서 코드를 찾을 때 불편한 정도만 아니면 된다. 저자는 한 패키지에 가능하면 10개 미만으로 타입 개수를 유지하려고 노력한다고 한다. 이 개수가 넘어가면 모듈을 분리하는 시도를 해보자.</p></blockquote><h2 id="애그리거트-1">애그리거트</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235348315-90e8953d-875b-45e3-a362-b9b350b6456c.png" alt="image" /></p><ul><li>백 개이상의 테이블을 한장의 ERD에 모두 표시하면 개별 테이블 간의 관계를 파악하느라 큰 틀에서 데이터 구조를 이해하는데 어려움을 겪게 되는 것처럼, <b>도메인 객체 모델이 복잡해지면 개별 구성요소 위주로 모델을 이해하게 되고 전반적인 구조나 큰 수준에서 도메인 간의 관계를 파악하기 어려워진다.</b><li>주요 도메인 개념 간의 관계를 파악하기 어렵다는 것은 곧 코드를 변경하고 확장하는 것이 어려줘진다는 것을 의미한다.<ul><li>상위 수준에서 모델이 어떻게 엮여 있는지 알아야 전체 모델을 망가뜨리지 않으면서 추가 요구사항을 모델에 반영할 수 있는데 세부적인 모델만 이해한 상태론 코드를 수정하기가 두렵기 때문에 코드 변경을 최대한 회피하는 쪽으로 요구사항을 협의하게 된다.<li>꼼수를 부려 당장 돌아가는 코드를 추가할 순 있지만 이는 장기적인 관점에서 코드를 더 수정하기 어렵게 만들기도 한다.</ul><li><b>복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만들려면 상위 수준에서 모델을 조망할 수 있는 방법이 필요한데, 그 방법이 애그리거트이다.</b><li>앞선 쳅터에서 언급한 것처럼 애그리거트는 관련된 객체를 하나의 군으로 묶어준다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235348466-f9a3b6b4-6436-4596-a4c7-6edfb0a4a685.png" alt="image" /></p><ul><li><p>위 이미지는 앞선 모델들을 애그리거트로 묶어서 다시 표현한 것인데, 동일한 모델이지만 애그리거트를 사용함으로써 모델 간의 관계를 개별 모델 수준뿐 아닌 상위 수준에서도 이해할 수 있게 된다.</p><li>애그리거트는 또한 일관성을 관리하는 기준이 된다.<ul><li>이로 인해 애그리거트는 복잡한 도메인을 단순한 구조로 만들어준다.<li>이는 복잡도가 낮아지는 만큼 도메인 기능을 확장하고 변경하는데 필요한 노력(개발 시간)도 줄어든다.</ul><li>애그리거트는 관련된 모델을 하나로 모은 것이기 때문에 한 애그리거트에 속한 객체는 유사하거나 동일한 라이프사이클을 갖는다.<ul><li>주문 애그리거트를 만드려면 Order, OrderLine, Orderer 와 같은 관련 객체를 함께 생성해야 한다.</ul><li>도메인 규칙에 따라 최초 주문 시점에 일부 객체를 만들 필요가 없는 경우도 있지만 애그리거트에 속한 구성요소는 대부분 함꼐 생성하고 함께 제거한다.</ul><h3 id="애그리거트가-가지는-책임">애그리거트가 가지는 책임</h3><ul><li>위 이미지에서 본 것처럼 애그리거트는 경계를 갖는다.<li><b>한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다. 즉 독립된 객체 군이며, 각 애그리거트는 자기 자신을 관리할 뿐 다른 애그리거트를 관리하지 않는다.</b><li>예를 들어, 주문 애그리거트는 배송지를 변경하거나 주문 상품 개수를 변경하는 등 자기 자신을 관리하지만, 회원의 비밀번호를 변경하거나 상품의 가격을 변경하진 않는다.</ul><h3 id="애그리거트의-경계를-어떻게-나누느냐">애그리거트의 경계를 어떻게 나누느냐</h3><ul><li><b>경계를 설정할 때 기본이 되는 것은 도메인 규칙과 요구사항이다.</b><ul><li>도메인 규칙에 따라 함께 생성되는 구성요소는 한 애그리거트에 속할 가능성이 높다.<li>예를 들어, 주문할 상품 개수, 배송지 정보, 주문자 정보는 주문 시점에 함께 생성되므로 이들은 한 애그리거트에 속한다.<li>또한, OrderLine의 주문 상품 개수를 변경시 도메인 규칙에 따라 Order의 총 주문 금액도 새로 계산해야 한다.<li>사용자 요구사항에 따라 주문 상품 개수와 배송지를 함께 변경하기도 한다.<li>이렇게 하면 함께 변경되는 비녿가 높은 객체는 한 애그리거트에 속할 가능성이 높다.</ul><li>흔히 ‘A가 B를 갖는다’ 로 설계할 수 있는 요구사항이 있다면 A와 B를 한 애그리거트로 묶어서 생각하기 쉽다.<ul><li>주문의 경우 Order가 ShippingInfo와 Orderer를 가지므로 이는 어느 정도 타당해 보인다.<li><b>하지만 ‘A가 B를 갖는다’로 해석할 수 있는 요구사항이 있따하더라도 이것이 반드시 A와 B가 한 애그리거트에 속한다는 것을 의미하는 것은 아니다.</b><li>좋은 예가 상품과 리뷰다. 상품 상세 페이지에 들어가면 상품 상세 정보와 함꼐 리뷰 내용을 보여줘야 한다는 요구사항이 있다면 Product 엔티티와 Review엔티티가 한 애그리거트에 속한다 생각할 수 있지만 이 둘은 함께 생성되지 않고 함께 변경되지 않는다.<li>게다가 Product 를 변경하는 주체가 상품 담당자라면 Review를 생성하고 변경하는 주체는 고객이다.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235348868-abb4bb4f-3996-4fce-852e-1bc07bc397ba.png" alt="image" /></p><ul><li>Review의 변경이 Product에 영향을 주지 않고 반대로 Product의 변경이 Review에 영향을 주지 않기 떄문에 이 둘은 한 애그리거트에 속한다기보다는 [그림 3.3]에 표시한 것처럼 서로 다른 애그리거트에 속한다.<li>처음 도메인 모델을 만들기 시작하면 큰 애그리거트로 보이는 것들이 많지만 도메인에 대한 경험이 생기고 도메인 규칙을 제대로 이해할수록 실제 애그리거트의 크기는 줄어들게 된다.<ul><li>저자의 경험을 비추어보면 다수의 애그리거트가 한 개의 엔티티 객체만 갖는 경우가 많으며 두 개 이상의 엔티티로 구성되는 애그리거트는 드물게 존재한다고 한다.</ul></ul><h2 id="애그리거트-루트">애그리거트 루트</h2><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235348959-43060841-b3b3-430b-9dfe-04befca906d5.png" alt="image" /></p><ul><li><b>애그리거트는 여러 객체로 구성되기 때문에 반드시 모든 객체들의 상태가 정상이어야 한다.</b><ul><li>예를 들어, 개별 구매 상품의 개수인 quantity와 금액 price를 가지는 OrderLine과 Order 객체의 총 주문 금액 totalAmounts 는 정합성이 맞아들어야 한다.</ul><li><b>애그리거트에 속한 모든 객체가 일관된 상태를 유지하려면 애그리거트 전체를 관리할 주체가 필요한데 이 책임을 지는 것이 바로 애그리거트의 루트 엔티티다.</b><ul><li>위 이미지에선 Order 가 애그리거트 루트 역할을 한다 볼 수 있다.</ul></ul><h2 id="도메인-규칙과-일관성">도메인 규칙과 일관성</h2><ul><li><b>애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는 것이다.</b><ul><li>이를 위해 애그리거트 루트는 애그리거트가 제공해야 할 도메인 기능을 구현한다.<li>예를 들어, 주문 애그리거트는 배송지 변경, 상품 변경과 같은 기능을 제공하는데 Order가 이 기능을 구현한 메서드를 제공한다.</ul><li>애그리거트 루트가 제공하는 메서드는 도메인 규칙에 따라 애그리거트에 속한 객체의 일관성이 깨지지 않도록 구현해야 한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span><span class="o">{</span>
	
  <span class="c1">// 애그리거트 루트는 도메인 규칙을 구현한 기능을 제공한다.</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeShippingInfo</span><span class="o">(</span><span class="nc">ShippingInfo</span> <span class="n">newShippingInfo</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">verifyNotYetShipped</span><span class="o">();</span> <span class="c1">// 출고 전에만 배송지 변경을 할 수 있다는 규칙을 구현</span>
		<span class="n">setShippingInfo</span><span class="o">(</span><span class="n">newShippingInfo</span><span class="o">);</span>
	<span class="o">}</span>
	
	<span class="kd">private</span> <span class="kt">void</span> <span class="nf">verifyNotYetShipped</span><span class="o">(){</span>
		<span class="k">if</span><span class="o">(</span><span class="n">state</span> <span class="o">!=</span> <span class="nc">OrderState</span><span class="o">.</span><span class="na">PAYMENT_WAITING</span> <span class="o">&amp;&amp;</span> <span class="n">state</span> <span class="o">!=</span> <span class="nc">OrderState</span><span class="o">.</span><span class="na">PREPARING</span><span class="o">)</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"already shippped"</span><span class="o">);</span>
	<span class="o">}</span>
	<span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>애그리거트 루트가 아닌 다른 객체가 애그리거트에 속한 객체를 직접 변경하면 안된다.<ul><li>getter를 무분별하게 만들었을 때 발생하는 문제점 중 하나이다.</ul><li>이는 애그리거트 루트가 강제하는 규칙을 적용할 수 없어 모델의 일관성을 깨는 원인이 된다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nc">ShippingInfo</span> <span class="n">si</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="na">getShippingInfo</span><span class="o">();</span>
<span class="n">si</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">newAddress</span><span class="o">);</span>
</pre></table></code></div></div><ul><li>위 코드는 주문 상태와 관계 없이 배송지 주소를 변경하게 되는데 논리적인 데이터 일관성이 꺠지게 된다.<li>일관성을 지키기 위해 상태 확인 로직을 응용 서비스에서 구현할 수 도 있지만, 이렇게 되면 동일한 검사 로직을 여러 응용 서비스에서 중복 구현할 가능성이 높아져 상황을 더 악화시킬 수 있다.<ul><li>유지보수성이 떨어지게되고 막 예시를 들어 주소 변경 도메인 규칙이 추가되거나 변경될 경우 일일이 다 찾아서 처리를 해줘야 될 것이다..</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nc">ShippingInfo</span> <span class="n">si</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="na">getShippingInfo</span><span class="o">();</span>

<span class="c1">// 주요 도메인 로직이 중복되는 문제</span>
<span class="k">if</span><span class="o">(</span><span class="n">state</span> <span class="o">!=</span> <span class="nc">OrderState</span><span class="o">.</span><span class="na">PAYMENT_WAITING</span> <span class="o">&amp;&amp;</span> <span class="n">state</span> <span class="o">!=</span> <span class="nc">OrderState</span><span class="o">.</span><span class="na">PREPARING</span><span class="o">)</span>
			<span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalStateException</span><span class="o">(</span><span class="s">"already shippped"</span><span class="o">);</span>

<span class="n">si</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">newAddress</span><span class="o">);</span>
</pre></table></code></div></div><h3 id="불필요한-중복을-피하고-애그리거트-루트를-통해서만-도메인-로직을-구현하게-만들기-위한-두-가지-습관">불필요한 중복을 피하고 애그리거트 루트를 통해서만 도메인 로직을 구현하게 만들기 위한 두 가지 습관</h3><p><b>1. 단순히 필드를 변경하는 set메서드를 공개 (public) 범위로 만들지 않는다.</b></p><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">// 도메인 모델에서 공개 set 메서드는 가급적 피해야 한다.</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
  <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>공개 set 메서드는 중요 도메인의 의미나 의도를 표현하지 못하고 도메인 로직이 도메인 객체가 아닌 응용 표현 영역으로 분산되게 만드는 원인이 된다.<ul><li>도메인 로직이 한 곳에 응집되어 있지 않게 되므로 코드를 유지보수할 때에도 분석하고 수정하는데 더 많은 시간을 들이게 된다.</ul><li>도메인 모델의 엔티티나 밸류에 공개 set 메서드만 넣지 않아도 이로간성이 깨질 가능성이 줄어든다.<ul><li>공개 set 메서드를 사용하지 않게 되면 의미가 드러나는 메서드를 사용해서 구현할 가능성이 높아진다.<li>예를 들어, set 형식의 이름을 갖는 공개 메서드를 사용하지 않으면 자연스럽게 cancel이나 changePassword 처럼 의미가 더 잘 드러나는 이름을 사용하는 빈도가 높아진다.</ul></ul><p><b>2. 벨류 타입은 불변으로 구현한다.</b></p><ul><li>밸류 객체의 값을 변경할 수 없으면 애그리거트 루트에서 밸류 객체를 구해도 값을 변경할 수 없기에 애그리거트 외부에서 밸류 객체의 상태를 변경할 수 없게 된다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">ShippingInfo</span> <span class="n">si</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="na">getShippingInfo</span><span class="o">();</span>

<span class="n">si</span><span class="o">.</span><span class="na">setAddress</span><span class="o">(</span><span class="n">newAddress</span><span class="o">);</span> <span class="c1">// ShippingInfo 벨류 객체가 불변이면 컴파일 에러 발생!</span>
</pre></table></code></div></div><ul><li>애그리거트 외부에서 내부 상태를 함부로 바꾸지 못하므로 애그리거트의 이로간성이 꺠질 가능성이 줄어든다.<li>즉, 다음과 같이 애그리거트 루트가 제공하는 메서드에 새로운 벨류 객체를 적달해서 값을 변경하는 방법 밖에 없다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span><span class="o">{</span>
	
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeShippingInfo</span><span class="o">(</span><span class="nc">ShippingInfo</span> <span class="n">newShippingInfo</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">verifyNotYetShipped</span><span class="o">();</span>
		<span class="n">setShippingInfo</span><span class="o">(</span><span class="n">newShippingInfo</span><span class="o">);</span>
	<span class="o">}</span>
	
  <span class="c1">// set 메서드의 접근 허용 범위는 private이다.</span>
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">setShippingInfo</span><span class="o">(</span><span class="nc">ShippingInfo</span> <span class="n">shippingInfo</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 벨류가 불변이면, 새로운 객체를 할당해서 값을 변경해야 한다.</span>
    <span class="c1">// 불변이므로 this.shippingInfo.setAddress(newShippingInfo.getAddress())와 같은 코드를 사용할 수 없다.</span>
    <span class="k">this</span><span class="o">.</span><span class="na">shippingInfo</span> <span class="o">=</span> <span class="n">shippingInfo</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="애그리거트-루트의-기능-구현">애그리거트 루트의 기능 구현</h2><ul><li>애그리거트 루트는 애그리거트 내부의 다른 객체를 조합해서 기능을 완성한다.<ul><li>예를 들어, Order는 총 주문 금액을 구하기 위해 OrderLine 목록을 사용한다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">Money</span> <span class="n">money</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderLine</span><span class="o">&gt;</span> <span class="n">orderLines</span><span class="o">;</span>

  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">calculateTotalAmounts</span><span class="o">()</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">orderLine</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                       <span class="o">.</span><span class="na">mapToInt</span><span class="o">(</span><span class="n">o1</span> <span class="o">-&gt;</span> <span class="n">o1</span><span class="o">.</span><span class="na">getPrice</span><span class="o">()</span> <span class="o">*</span> <span class="n">o1</span><span class="o">.</span><span class="na">quantity</span><span class="o">())</span>
                       <span class="o">.</span><span class="na">sum</span><span class="o">();</span>

    <span class="k">this</span><span class="o">.</span><span class="na">totalAmounts</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Money</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>또한 기능 실행을 위임하기도 한다.<ul><li>Order의 changeOrderLines() 메서드는 내부의 orderLines 필드에 상태변경을 위임하는 방식으로 구현한다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">OrderLines</span> <span class="n">orderLines</span><span class="o">;</span>

  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">changeOrderLines</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderLine</span><span class="o">&gt;</span> <span class="n">newOrderLines</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">orderLines</span><span class="o">.</span><span class="na">changeOrderLines</span><span class="o">(</span><span class="n">newOrderLines</span><span class="o">);</span>
    <span class="k">this</span><span class="o">.</span><span class="na">totalAmounts</span> <span class="o">=</span> <span class="n">orderLines</span><span class="o">.</span><span class="na">getTotalAmounts</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderLines</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderLine</span><span class="o">&gt;</span> <span class="n">lines</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nc">Money</span> <span class="nf">getTotalAmounts</span><span class="o">()</span> <span class="o">{</span>
    <span class="o">...</span>
  <span class="o">};</span>

  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">changeOrderLines</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderLine</span><span class="o">&gt;</span> <span class="n">newLines</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">lines</span> <span class="o">=</span> <span class="n">newLines</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>만약 Order가 getOrderLines()와 같이 OrderLine를 구할 수 있는 메서드를 제공하면 애그리거트 외부에서 OrderLines의 기능을 실행할 수 있게 된다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nc">OrderLines</span> <span class="n">lines</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="na">getOrderLines</span><span class="o">();</span>

<span class="c1">// 외부에서 애그리거트 내부 상태 변경!</span>
<span class="c1">// order의 totalAmounts가 값이 OrderLines가 일치하지 않게 됨</span>
<span class="n">lines</span><span class="o">.</span><span class="na">changeOrderLines</span><span class="o">(</span><span class="n">newOrderLines</span><span class="o">);</span>
</pre></table></code></div></div><ul><li>이 코드는 주문의 OrderLine 목록이 바뀌는데 총합은 계산하지 않는 버그를 만든다.<ul><li>이런 버그를 생기지 않도록 하려면 애초에 애그리거트 외부에서 OrderLine 목록을 변경할 수 없도록 OrderLines를 불변으로 구현하면 된다.</ul><li>팀 표준이나 구현 기술의 제약으로 OrderLines를 불변으로 구현할 수 없다면 OrderLines의 변경 기능을 패키지나 protected 범위로 한정해서 외부에서 실행할 수 없도록 제한하는 방법이 있다.<ul><li>보통 한 애그리거트에 속하는 모델은 한 패키지에 속하기 때문에 패키지나 protected 범위를 사용하면 애그리거트 외부에서 상태 변경 기능을 실행하는 것을 방지 할 수 있다.</ul></ul><h2 id="트랜잭션-범위">트랜잭션 범위</h2><ul><li>트랜잭션의 범위는 작으면 작을 수록 좋다.<ul><li>DB 테이블을 기준으로 한 트랜잭션이 한개의 테이블을 수정하는 것과 세 개의 테이블을 수정하는 것은 성능에서 차이가 발생한다.<li>한 개의 테이블을 수정할 땐 트랜잭션 충돌을 막기 위해 잠그는 대상이 한 개 테이블의 한 행으로 한정되지만, 세 개의 테이블을 수정하면 잠금 대상이 더 많아진다.<li>잠금 대상이 많아진다는 것은 그만큼 동시에 처리할 수 있는 트랜잭션 개수가 줄어든다는 것을 뜻하고 전체적인 성능(처리량)을 떨어뜨린다.</ul><li>동일하게 한 트랜잭션에선 한 개의 애그리거트만 수정해야 한다.<ul><li>한 트랜잭션에서 두 개 이상의 애그리거트를 수정하면 트랜잭션 충돌이 발생할 가능성이 더 높아지기 때문에 한 번에 수정하는 애그리거트 개수가 많아질수록 전체 처리량이 떨어지게 된다.</ul><li><b>한 트랜잭션에서 한 애그리거트만 수정한다는 것은 애그리거트에서 다른 애그리거트를 변경하지 않는다는 것을 뜻한다.</b><ul><li>한 애그리거트에서 다른 애그리거트를 수정하면 결과적으로 두 개의 애그리거트를 한 트랜잭션에서 수정하게 되므로 한 애그리거트 내부에서 다른 애그리거트의 상태를 변경하는 기능을 실행하면 안된다.<li>예를 들어, 배송지 정보를 변경하면서 동시에 배송지 정보를 회원의 주소로 설정하는 기능이 있따고 해보자.<li>이 경우 주문 애그리거트는 다음과 같이 회원 애그리거트의 정보를 변경해선 안된다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">Orderer</span> <span class="n">orderer</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">shipTo</span><span class="o">(</span><span class="nc">ShippingInfo</span> <span class="n">shippingInfo</span><span class="o">,</span> <span class="kt">boolean</span> <span class="n">useNewShippingAddrAsMemberAddr</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">verifyNotYetShipped</span><span class="o">();</span>
    <span class="n">setShippingInfo</span><span class="o">(</span><span class="n">newShippingInfo</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">useNewShippingAddrAsMemberAddr</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 다른 애그리거트의 상태를 변경하면 안됨!</span>
      <span class="n">order</span><span class="o">.</span><span class="na">getOrderer</span><span class="o">().</span><span class="na">getCustomer</span><span class="o">().</span><span class="na">changeAddress</span><span class="o">(</span><span class="n">newShippingInfo</span><span class="o">.</span><span class="na">getAddress</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>이는 애그리거트가 자신의 책임 범위를 넘어 다른 애그리거트의 상태까지 관리하는 꼴이 된다.<li><b>애그리거트는 서로 최대한 독립적이어야 하는데 한 애그리거트가 다른 애그리거트의 기능에 의존하기 시작하면 애그리거트 간의 결합도가 높아지게 된다.</b><ul><li>결합도가 높아지면 높아질수록 향후 수정 비용이 증가하므로 애거리트에서 다른 애그리거트의 상태를 변경하지 말아야 한다.</ul><li>만약 한 트랜잭션에서 두 개 이상의 애그리거트를 수정해야한다면 아래와 같이 응용 서비스에서 두 애그리거트를 수정하도록 하자.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChangeOrderService</span> <span class="o">{</span>
 <span class="nd">@Transactional</span>
 <span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeShippingInfo</span><span class="o">(</span><span class="nc">OrderId</span> <span class="n">id</span><span class="o">,</span>
  <span class="nc">ShippingInfo</span> <span class="n">newShippingInfo</span><span class="o">,</span>
  <span class="kt">boolean</span> <span class="n">useNewShippingAddrAsMemberAddr</span><span class="o">)</span> <span class="o">{</span>

  <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderRepository</span><span class="o">.</span><span class="na">findbyId</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">order</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">OrderNotFoundException</span><span class="o">();</span>
  <span class="n">order</span><span class="o">.</span><span class="na">shipTo</span><span class="o">(</span><span class="n">newShippingInfo</span><span class="o">);</span>

  <span class="k">if</span> <span class="o">(</span><span class="n">useNewshippingAddrAsMemberAddr</span><span class="o">)</span> <span class="o">{</span>
   <span class="n">order</span><span class="o">.</span><span class="na">getOrderer</span><span class="o">()</span>
    <span class="o">.</span><span class="na">getCustomer</span><span class="o">().</span><span class="na">changeAddress</span><span class="o">(</span><span class="n">newShippingInfo</span><span class="o">.</span><span class="na">getAddress</span><span class="o">());</span>
  <span class="o">}</span>
 <span class="o">}</span>
 <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li><p>도메인 이벤트를 사용하면 한 트랜잭션에서 한 개의 애그리거트를 수정하면서도 동기나 비동기로 다른 애그리거트의 상태를 변경할 수 있다. 관련된 내용은 10장에서 살펴보자.</p><li><p>기본적으로 한 트랜잭션에서 하나의 애그리거트를 수정하는 것을 권장하지만, 다음의 경우에는 두 개 이상의 애그리거트를 변경하는 것을 고려해볼 수 있다.</p><ul><li>1)팀 표준 : 조직의 표준에 따라 사용자 유스케이스와 관련된 응용 서비스의 기능을 한 트랜잭션으로 실행해야 하는 경우<li>2)기술 제약 : 한 트랜잭션에서 두 개 이상의 애그리거트를 수정하는 대신 도메인 이벤트와 비동기를 사용하는 방식을 사용하는데, 기술적으로 이벤트 방식을 도입할 수 없는 경우 한 트랜잭션에서 다수의 애그리거트를 수정해서 일관성을 처리해야 한다.<li>3)UI 구현의 편리 : 운영자의 편리함을 위해 주문 목록 화면에서 여러 주문의 상태를 한 번에 변경하고 싶을 경우</ul></ul><h2 id="리포지터리와-애그리거트">리포지터리와 애그리거트</h2><ul><li>리포지터리는 애그리거트 단위로 존재한다,<ul><li>Order와 OrderLine을 물리적으로 각각 별도의 DB테이블에 저장한다고 해서 Order 와 OrderLine을 위한 리포지터리를 각각 만들지 않는다. Order가 애그리거트 루트이고 OrderLine인 애그리거트에 속하는 구성요소이므로 Order 를 위한 리포지토리만 존재한다.</ul><li><b>ORM 기술 중의 하나인 JPA/Hibernate 를 사용하면 DB관계형 모델에 객체 도메인 모델을 맞춰야 하는 경우도 있다.</b><ul><li>특히 레거시 DB를 사용해야 하거나 팀 내 DB 설계 표준을 따라야 한다면 DB 테이블 구조에 맞게 모델을 변경해야 한다.<li>이 경우 밸류 타입인 도메인 모델을(JPA에서 밸류 타입을 매핑할 떄 사용하는) @Component 가 아닌 (엔티티를 매핑할 때 사용하는) @Entity를 이용해야 할 수도 있다.</ul><li><b>애그리거트는 개념적으로 하나이므로 리포지터리는 애그리거트 전체를 저장소에 영속화해야 한다.</b><ul><li><b>예를 들어, Order 애그리거트와 관련된 테이블이 세 개라면 리포지터리를 통해서 Order 애그리거트를 저장할 떄 애그리거트 루트와 매핑되는 테이블뿐만 아니라 애그리거트에 속한 모든 구성요소를 위한 테이블에 데이터를 저장해야 한다.</b></ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">// 리포지토리에 애그리거트를 저장하면 애그리거트 전체를 영속화해야 한다.</span>
<span class="n">orderRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
</pre></table></code></div></div><ul><li><b>위와 동일하게 애그리거트를 구하는 리포지터리 메서드는 완전한 애그리거트를 제공해야 한다.</b><ul><li>즉 다음 코드를 실행시 order 애그리거트는 OrderLine, Orderer 등 모든 구성요소를 포함하고 있어야 한다.<li>그렇지 않을 경우 NPE 가 발생하게 된다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// 리포지토리는 완전한 order를 제공해야 한다.</span>
<span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">orderId</span><span class="o">);</span>

<span class="c1">// order가 온전한 애그리거트가 아니면</span>
<span class="c1">// 기능 실행 도중 NPE 가 발생한다.</span>
<span class="n">order</span><span class="o">.</span><span class="na">cancel</span><span class="o">();</span>
</pre></table></code></div></div><ul><li>애그리거트를 영속화할 저장소로 무엇을 사용하든지 간에(RDBMS, Mongo DB, HBase) 애그리거트의 상태가 변경되면 모든 변경을 원자적으로 저장소에 반영해야 한다. 데이터 일관성을 보장하는 것이 중요하다.<ul><li>RDBMS와 JPA를 이용한 리포지토리와 애그리거트의 구현에 대한 내용은 4장에서 살펴볼 예정이다.</ul></ul><h2 id="id를-이용한-애그리거트-참조">ID를 이용한 애그리거트 참조</h2><ul><li>애그리거트는 다른 애그리거트를 참조한다.<ul><li>애그리거트의 관리 주체가 애그리거트 루트이므로 애그리거트에서 다른 애그리거트를 참조한다는 것은 애그리거트의 루트를 참조한다는 것과 같다.</ul></ul><h3 id="다른-애그리거트-필드-참조">다른 애그리거트 필드 참조</h3><ul><li>예를 들어, 주문 애그리거트에 속해 있는 Orderer 는 [그림 3.6]처럼 주문한 회원을 참조하기 위해 회원 애그리거트 루트인 Member를 필드로 참조할 수 있다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235356927-51dc05f4-6b67-4bfd-ab2a-41625495c9bf.png" alt="image" /></p><ul><li>필드를 이용해서 다른 애그리거트를 직접 참조하는 것은 개발자에게 구현의 편리함을 제공한다.<ul><li>예를 들어, 주문 정보 조회 화면에서 회원 아이디를 이용해서 링크를 제공해야 한다고 해보자.<li>이 경우, 다음과 같이 Order로부터 시작해서 회원 아이디를 구할 수 있다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">order</span><span class="o">.</span><span class="na">getOrderer</span><span class="o">().</span><span class="na">getMember</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>
</pre></table></code></div></div><ul><li>JPA를 사용하면 <code class="language-plaintext highlighter-rouge">@ManyToOne</code>, <code class="language-plaintext highlighter-rouge">@OneToOne</code> 과 같은 어노테이션을 이용해서 연관된 객체를 로딩하는 기능을 제공하고 있으므로 필드를 이용해서 다른 애그리거트를 쉽게 참조할 수 있다.</ul><h3 id="다른-애그리거트-필드-참조의-문제점">다른 애그리거트 필드 참조의 문제점</h3><p><b>1) 편한 탐색 오용</b></p><ul><li>가장 큰 문제점이다.<li>한 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있으면 다른 애그리거트의 상태를 쉽게 변경할 수 있게 된다.<li>트랜잭션 범위에서 언급한 것처럼 한 애그리거트가 관리하는 범위는 자기 자신으로 한정해야 한다.<li>그런데, 애그리거트 내부에서 다른 애그리거트 객체에 접근할 수 있으면 다음 코드처럼 구현의 편리함 때문에 다른 애그리거트를 수정하고자 하는 유혹에 빠지기 쉽다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Orderer</span> <span class="n">orderer</span><span class="o">;</span>
    
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeShippingInfo</span><span class="o">(</span><span class="nc">ShippingInfo</span> <span class="n">newShippingInfo</span><span class="o">,</span> 
        <span class="kt">boolean</span> <span class="n">useNewShippingAddrAsMemberAddr</span><span class="o">)</span> <span class="o">{</span>
        <span class="o">...</span>
        <span class="k">if</span><span class="o">(</span><span class="n">useNewShippingAddrAsMemberAddr</span><span class="o">)</span> <span class="o">{</span>
        
            <span class="c1">// 한 애그리거트 내부에서 다른 애그리거트에 접근할 수 있으면</span>
            <span class="c1">// 다른 애그리거트의 상태를 변경하는 유혹에 빠지기 쉽다.</span>
            <span class="n">orderer</span><span class="o">.</span><span class="na">getCustomer</span><span class="o">().</span><span class="na">changeAddress</span><span class="o">(</span><span class="n">newShippingInfo</span><span class="o">.</span><span class="na">getAddress</span><span class="o">());</span>
        <span class="o">}</span>
        <span class="o">...</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>트랜잭션 범위에서 말한 것철검, 한 애그리거트에서 다른 애그리거트의 상태를 변경하는 것은 애그리거트 간의 의존 결합도를 높여서 결과적으로 애그리거트의 변경을 어렵게 만든다.</ul><p><b>2) 성능에 대한 고민</b></p><ul><li>JPA를 사용할 경우 참조한 객체를 지연(Lazy)로딩과 즉시(Eager) 로딩의 두 가지 방식으로 로딩할 수 있다.<li>두 로딩 방식 중 무엇을 사용할지 여부는 애그리거트의 어떤 기능을 사용하느냐에 따라 달라진다.<li>단순히 연관된 객체의 데이터를 함께 보여주어야 하면 즉시 로딩이 조회성능에 유리하지만, 애그리거트의 상태를 변경하는 기능을 실행하는 경우엔 불필요한 객체를 함꼐 로딩할 필요가 없으므로 지연 로딩이 유리하다.<li>이런 다양한 경우의 수를 고려해서 연관 매핑과 JPQL/Criteria 쿼리의 로딩 전략을 결정해야 한다.</ul><p><b>3) 확장 어려움</b></p><ul><li>시스템 초기엔 단일 서버에 단일 DBMS로 서비스를 제공하는 것이 가능하다.<li>문제는 사용자가 몰리기 시작하면서 발생한다.<li>사용자가 늘고 트래픽이 증가하면 자연스럽게 부하를 분산하기 위해 하위 도메인 별로 시스템을 분리하기 시작한다.<ul><li>이 과정에서 하위 도메인마다 서로 다른 DBMS를 사용할 가능성이 높아진다.<li><b>심지어 하위 도메인마다 다른 종류의 데이터 저장소를 사용하기도 한다. 한 하위 도메인은 마리아DB를 사용하고 다른 하위 도메인은 몽고DB를 사용하는 식으로 말이다.</b><li><b>이는 더 이상 다른 애그리거트 루트를 참조하기 위해 JPA와 같은 단일 기술을 사용할 수 없음을 의미한다.</b></ul></ul><p><b>이러한 세 가지 문제를 완화할 때 사용할 수 있는 것이 ID를 이용해서 다른 애그리거트를 참조하는 것이다.</b></p><h3 id="id를-이용해서-다른-애그리거트를-참조할-경우의-장점">ID를 이용해서 다른 애그리거트를 참조할 경우의 장점</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235357818-263a1560-9b24-49ff-97ed-56ebe28a06a4.png" alt="image" /></p><ul><li><code class="language-plaintext highlighter-rouge">ID를 이용한 참조</code>는 DB 테이블에서의 외래키를 사용해서 참조하는 것과 비슷하게 다른 애그리거트를 참조할 때 ID 참조를 사용한다는 점이다.<li><p><b>단, 애그리거트 내의 엔티티를 참조할 땐 객체 레퍼런스로 참조한다.</b></p><li>ID 참조를 사용하면 모든 객체가 참조로 연결되지 않고 <b>한 애그리거트에 속한 객체들만 참조로 연결된다.</b><li><b>이는 애그리거트의 경계를 명확히 하고 애그리거트 간 물리적인 연결을 제거하기 떄문에 모델의 복잡도를 낮춰준다.</b><li><p><b>또한 애그거트간의 의존을 제거하므로 응집도를 높여주는 효과도 있다.</b></p><li><b>구현 복잡도도 낮아진다.</b><li><b>다른 애그리거트를 직접 참조하지 않으므로 애그리거트 간 참조를 지연 로딩으로 할지 즉시 로딩으로 할지 고민하지 않아도 된다.</b><li><b>참조하는 애그리거트가 필요하면 응용 서비스에서 ID를 이용해서 로딩하면 된다.</b></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChangeOrderService</span> <span class="o">{</span>
  <span class="nd">@Transactional</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeShippingInfo</span><span class="o">(</span><span class="nc">OrderId</span> <span class="n">id</span><span class="o">,</span>
    <span class="nc">ShippingInfo</span> <span class="n">newShippingInfo</span><span class="o">,</span>
    <span class="kt">boolean</span> <span class="n">useNewShippingAddrAsMemberAddr</span><span class="o">)</span> <span class="o">{</span>

    <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderRepository</span><span class="o">.</span><span class="na">findbyId</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">order</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">OrderNotFoundException</span><span class="o">();</span>
    <span class="n">order</span><span class="o">.</span><span class="na">changeShippingInfo</span><span class="o">(</span><span class="n">newShippingInfo</span><span class="o">);</span>

    <span class="k">if</span> <span class="o">(</span><span class="n">useNewshippingAddrAsMemberAddr</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// ID를 이용해서 참조하는 애그리거트를 구한다.</span>
      <span class="nc">Customer</span> <span class="n">customer</span> <span class="o">=</span> <span class="n">customerRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">order</span><span class="o">.</span><span class="na">getOrderer</span><span class="o">().</span><span class="na">getCustomerId</span><span class="o">());</span>
      <span class="n">customer</span><span class="o">.</span><span class="na">changeAddress</span><span class="o">(</span><span class="n">newShippingInfo</span><span class="o">.</span><span class="na">getAddress</span><span class="o">();)</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>응용 서비스에서 필요한 애그리거트를 로딩하므로 애그리거트 수준에서 지연 로딩을 하는 것과 동일한 결과를 만든다.<li>ID를 이용한 참조 방식을 사용하면 복잡도를 낮추는 것과 함께 한 애그리거트에서 다른 애그리거트를 수정하는 문제를 원천적으로 방지할 수 있다.<ul><li>외부 애그리거트를 직접 참조하지 않기에 애초에 한 애그리거트에서 다른 애그리거트의 상태를 변경할 수 없는 것이다.</ul><li>애그리거트별로 다른 구현 기술을 사용하는 것도 가능해진다.<ul><li>중요한 데이터인 주문 애그리거트는 RDBMS에 저장하고 조회 성능이 중요한 상품 애그리거트는 NoSQL에 저장할 수 있다.<li>또한, 각 도메인을 별도 프로세스로 서비스하도록 구현할 수도 있다.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235358248-02cc0f26-4ab7-415d-b5cd-da932d147d36.png" alt="image" /></p><p><em>[그림3.8] 아이디로 애그리거트를 참조하면 리포지터리마다 다른 저장소를 사용하도록 구현할 떄 확장이 용이하다.</em></p><h2 id="id를-이용한-참조와-조회-성능">ID를 이용한 참조와 조회 성능</h2><ul><li>다른 애그리거트를 ID로 참조하면 참조하는 여러 애그리거트를 읽어야 할 때 조회 속도가 문제 될 수 있다.<ul><li>예를 들어, 주문 목록을 보여주려면 상품 애그리거트와 회원 애그리거트를 함께 읽어야 하는데, 이를 처리할 때 다음과 같이 각 주문마다 상품과 회원 애그리거트를 읽어온다고 해보자.<li>한 DBMS에 데이터가 있다면 조인을 이용해서 한 번에 가져올 수 있음에도 주문마다 상품 저옵를 읽어오는 쿼리를 실행하게 된다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nc">Customer</span> <span class="n">customer</span> <span class="o">=</span> <span class="n">customerRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">ordererId</span><span class="o">);</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">orders</span> <span class="o">=</span> <span class="n">orderRepository</span><span class="o">.</span><span class="na">findByOrderer</span><span class="o">(</span><span class="n">ordererId</span><span class="o">);</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderView</span><span class="o">&gt;</span> <span class="n">dtos</span> <span class="o">=</span> <span class="n">orders</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                             <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">order</span> <span class="o">-&gt;</span> <span class="o">{</span>
                                <span class="nc">ProductId</span> <span class="n">prodId</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="na">getOrderLines</span><span class="o">().</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">getProductId</span><span class="o">();</span>
                                <span class="c1">//  각 주문마다 첫 번째 주문 상품 정보 로딩 위한 쿼리 실행</span>
                                <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="n">productRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">prodId</span><span class="o">);</span>
                                <span class="k">return</span> <span class="k">new</span> <span class="nf">OrderView</span><span class="o">(</span><span class="n">order</span><span class="o">,</span> <span class="n">customer</span><span class="o">,</span> <span class="n">product</span><span class="o">);</span>
                             <span class="o">}).</span><span class="na">collect</span><span class="o">(</span><span class="n">toList</span><span class="o">());</span>
</pre></table></code></div></div><ul><li>위 코드를 보면 Order 조회 쿼리 한 번 그리고 주문에 엮여있는 상품 조회 쿼리 N번이 발생하게 된다.<ul><li>이는 지연 로딩과 관련된 대표적인 문제 N+1 문제와 비슷한 문제가 발생한다.<li>N+1 조회 문제는 더 많은 쿼리를 실행해서 전체 조회 속도가 느려지는 원인이다.</ul><li>이 문제가 발생하지 않도록 하려면 조인을 사용하도록 해야하는데 조인을 사용하는 가장 쉬운 방법은 ID 참조 방식을 객체 참조 방식으로 바꾸고 즉시 로딩을 사용하도록 매핑 설정을 바꾸는 것이다.<ul><li>하지만, 이 방식은 애그리거트 간 참조를 ID 참조 방식에서 객체 참조 방식으로 다시 되돌리는 것이다.</ul><li>ID 참조 방식을 사용하면서 N+1 조회와 같은 문제가 발생하지 않도록 하려면 <code class="language-plaintext highlighter-rouge">전용 조회 쿼리</code> 를 사용하면 된다.<ul><li>예를 들어, 데이터 조회를 위한 별도 DAO를 만들고 조회 메서드에서 세타 조인을 이용해서 한 번의 쿼리로 필요한 데이터를 로딩하면 된다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="nd">@Repository</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JpaOrderViewDao</span> <span class="kd">implements</span> <span class="nc">OrderViewDao</span> <span class="o">{</span>
    <span class="nd">@PersistenceContext</span>
    <span class="kd">private</span> <span class="nc">EntityManager</span> <span class="n">em</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderView</span><span class="o">&gt;</span> <span class="nf">selectByOrder</span><span class="o">(</span><span class="nc">String</span> <span class="n">ordererId</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">String</span> <span class="n">selectQuery</span> <span class="o">=</span>
            <span class="s">"select new com.myshop.order.application.dto.OrderView(o, m, p) "</span> <span class="o">+</span>
            <span class="s">"from Order o join o.orderLines ol, Member m, Product p "</span> <span class="o">+</span>
            <span class="s">"where o.orderer.memberId.id = :ordererId "</span> <span class="o">+</span>
            <span class="s">"and o.orderer.memberId = m.id "</span> <span class="o">+</span>
            <span class="s">"and ol.productId = p.id "</span> <span class="o">+</span>
            <span class="s">"order by o.number.number desc"</span><span class="o">;</span>

        <span class="nc">TypedQuery</span><span class="o">&lt;</span><span class="nc">OrderView</span><span class="o">&gt;</span> <span class="n">query</span> <span class="o">=</span>
            <span class="n">em</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span><span class="n">selectQuery</span><span class="o">,</span> <span class="nc">OrderView</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">query</span><span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"ordererId"</span><span class="o">,</span> <span class="n">ordererId</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">query</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>이 JPQL은 Order 애그리거트와 Member 애그리거트, 그리고 Product 애그리거트를 세타 조인으로 조회해서 한 번의 쿼리로 로딩한다.<ul><li>즉시 로딩이나 지연로딩과 같은 로딩 전략을 고민할 필요 없이 조회 화면에서 필요한 애그리거트 데이터를 한 번의 쿼리로 로딩할 수 있다.<li>쿼리가 복잡하거나 SQL에 특화된 기능을 사용해야 한다면 조회를 위한 부분만 MyBatis 와 같은 기술을 이용해서 실행할 수도 있다.</ul></ul><blockquote><p><strong>Note</strong>: JPA를 사용하면 각 객체 간 모든 연관을 지연/즉시로딩으로 어떻게든 처리하고 싶은 욕구가 생길텐데 이는 실용적이지 않다. ID를 이용해서 애그리거트를 참조해도 한 번의 쿼리로 필요한 데이터를 로딩하는 것이 가능하다.</p></blockquote><ul><li>애그리거트마다 서로 다른 저장소를 사용하는 경우엔 한 번의 쿼리로 관련 애그리거트를 조회할 수 없다.<li>이런 경우 조회 성능을 높이기 위해 <code class="language-plaintext highlighter-rouge">캐시</code>를 적용하거나 <code class="language-plaintext highlighter-rouge">조회 전용 저장소</code>를 따로 구성한다.<ul><li>이 방법은 코드가 복잡해지는 단점이 있지만, 시스템의 처리량을 높일 수 있는 장점이 있다.</ul><li>특히 한 대의 DB 장비로 대응할 수 없는 수준의 트래픽이 발생하는 경우 <code class="language-plaintext highlighter-rouge">캐시</code>나 <code class="language-plaintext highlighter-rouge">조회 전용 저장소</code>는 필수로 선택해야 한다.</ul><h2 id="애그리거트-간-집합-연관">애그리거트 간 집합 연관</h2><h3 id="1n">1:N</h3><ul><li>한 카테고리에 여러 상품이 속할 수 있으니 1:N 관계이다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Category</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">products</span><span class="o">;</span>  <span class="c1">//  다른 애그리거트에 대한 1:N 연관</span>
    <span class="c1">//...</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="nf">getProducts</span><span class="o">(</span><span class="kt">int</span> <span class="n">page</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">sortedProducts</span> <span class="o">=</span> <span class="n">sortById</span><span class="o">(</span><span class="n">products</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">sortedProducts</span><span class="o">.</span><span class="na">subList</span><span class="o">((</span><span class="n">page</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">size</span><span class="o">,</span> <span class="n">page</span> <span class="o">*</span> <span class="n">size</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>하지만 위처럼 도메인 객체 내에 연관을 맺게 되면 해당 객체가 불릴때마다 Category에 속한 모든 Product를 조회하게 되면서 성능에 심각한 문제를 야기시킨다.<ul><li>Product 의 갯수가 수백에서 수만 개정도로 많다면…</ul><li><b>따라서 개념적으로는 애그리거트 간에 1:N 연관이 있다고 하더라도 성능상 문제로 인해 애그리거트 간의 1:N 연관을 실제 구현에 반영하는 경우는 드물다.</b><li><b>이에 대한 해결책으로 상품 입장에서 자신이 속한 카테고리를 N:1 로 연관지어 구하면 된다.</b></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
    <span class="c1">// ...</span>
    <span class="kd">private</span> <span class="nc">CateogryId</span> <span class="n">category</span><span class="o">;</span>
    <span class="c1">//...</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ProductListService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Page</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="nf">getProductOfCategory</span><span class="o">(</span><span class="nc">Long</span> <span class="n">categoryId</span><span class="o">,</span> <span class="kt">int</span> <span class="n">page</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Category</span> <span class="n">category</span> <span class="o">=</span> <span class="n">categoryRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">categoryId</span><span class="o">);</span>
        <span class="n">checkCategory</span><span class="o">(</span><span class="n">category</span><span class="o">);</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">products</span> <span class="o">=</span> <span class="n">productRepository</span><span class="o">.</span><span class="na">findByCategoryId</span><span class="o">(</span><span class="n">category</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="n">page</span><span class="o">,</span> <span class="n">size</span><span class="o">);</span>
        <span class="kt">int</span> <span class="n">totalCount</span> <span class="o">=</span> <span class="n">productRepository</span><span class="o">.</span><span class="na">countByCategoryId</span><span class="o">(</span><span class="n">category</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Page</span><span class="o">(</span><span class="n">page</span><span class="o">,</span> <span class="n">size</span><span class="o">,</span> <span class="n">totalCount</span><span class="o">,</span> <span class="n">products</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>카테고리에 속한 상품 목록을 제공하는 응용 서비스는 다음과 같이 ProductRepository를 이용해 CategoryId가 지정한 카테고리 식별자인 Product 목록을 구한다.</ul><h3 id="mn">M:N</h3><ul><li>상품이 여러 카테고리에 속할 수 있다고 가정하면 카테고리와 상품은 M:N 연관을 맺는다.<li>M:N 연관은 <code class="language-plaintext highlighter-rouge">개념적으로</code> 양쪽 애그리거트에 컬랙션으로 연관을 만든다.<ul><li>하지만 앞선 1:N 처럼 요구사항을 고려해서 M:N 연관을 구현에 포함시킬지 여부를 결정해야 한다.</ul><li>일반적으로 상품 페이지를 보여줄 때 각 상품 별 모든 카테고리 정보를 다 보여주진 않는다.<ul><li>상품 상세 화면에서 주로 카테고리 정보를 보여주게 된다.<li><b>이 요구사항을 고려하면 카테고리 -&gt; 상품의 연관은 필요하지 않다. 상품 -&gt; 카테고리 연관만 구현하면 된다./b&gt;</b><li><b>즉, 개념적으로 상품과 카테고리의 양방향 M:N 연관이 존재하지만 실제 구현에서는 상품 -&gt; 카테고리의 단방향 M:N 연관만 적용하면 된다.</b></ul><li>RDBMS를 이용해 M:N 연관을 구현하려면 조인 테이블을 사용한다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235456151-acebce5c-14d1-40a3-8707-49a68604b77c.png" alt="image" /></p><ul><li>JPA 를 이용하면 다음과 같은 매핑 설정을 사용해서 ID 참조를 이용한 M:N 단방향 연관을 구현할 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
    <span class="nd">@EmbeddedId</span>
    <span class="kd">private</span> <span class="nc">ProductId</span> <span class="n">id</span><span class="o">;</span>
    
    <span class="nd">@ElementCollection</span>
    <span class="nd">@CollectionTable</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product_category"</span><span class="o">,</span> 
            <span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="err">"</span><span class="n">product_id</span><span class="o">))</span>
    <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">CategoryId</span><span class="o">&gt;</span> <span class="n">categoryIds</span><span class="o">;</span>
    
    <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>이 매핑은 카테고리 ID 목록을 보관하기 위해 밸류 타입에 대한 컬렉션 매핑을 이용했다.<ul><li>이 매핑을 사용하면 아래 코드와 같이 <code class="language-plaintext highlighter-rouge">JPQL</code>의 <code class="language-plaintext highlighter-rouge">member of</code> 연산자를 이용해서 특정 Category에 속한 Product 목록을 구하는 기능을 구현할 수 있다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="nd">@Repository</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JpaProductRepository</span> <span class="kd">implements</span> <span class="nc">ProductRepository</span> <span class="o">{</span>
    <span class="nd">@PersistenceContext</span>
    <span class="kd">private</span> <span class="nc">EntityManager</span> <span class="n">entityManager</span><span class="o">;</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="nf">findByCategoryId</span><span class="o">(</span><span class="nc">CategoryId</span> <span class="n">categoryid</span><span class="o">,</span> <span class="kt">int</span> <span class="n">page</span><span class="o">,</span> <span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">TypedQuery</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="n">query</span> <span class="o">=</span> <span class="n">entityManager</span><span class="o">.</span><span class="na">createQuery</span><span class="o">(</span>
            <span class="s">"select p from Product p "</span> <span class="o">+</span> 
            <span class="s">"where :catId member of p.categoryIds order by p.id.id desc"</span><span class="o">,</span> <span class="nc">Product</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
        <span class="n">query</span><span class="o">.</span><span class="na">setParameter</span><span class="o">(</span><span class="s">"catId"</span><span class="o">,</span> <span class="n">categoryId</span><span class="o">);</span>
        <span class="n">query</span><span class="o">.</span><span class="na">setFirstResult</span><span class="o">((</span><span class="n">page</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span> <span class="o">*</span> <span class="n">size</span><span class="o">);</span>
        <span class="n">query</span><span class="o">.</span><span class="na">setMaxResults</span><span class="o">(</span><span class="n">size</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">query</span><span class="o">.</span><span class="na">getResultList</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="애그리거트를-팩토리로-사용하기">애그리거트를 팩토리로 사용하기</h2><ul><li>예를 들어, 특정 상점에서 더 이상 상품을 등록을 할 수 없도록 차단된 상태라고 할 때 상품 등록 기능을 아래와 같이 응용 서비스 로직에 구현할 수 있을 것이다. (예제 코드에 오타가 있는 듯하여 임의로 수정했다.)</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RegisterProductService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ProductId</span> <span class="nf">registerNewProduct</span><span class="o">(</span><span class="nc">NewProductRequest</span> <span class="n">req</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Store</span> <span class="n">store</span> <span class="o">=</span> <span class="n">accountRepository</span><span class="o">.</span><span class="na">findStoreById</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getStoreId</span><span class="o">());</span>
        <span class="n">checkNull</span><span class="o">(</span><span class="n">store</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">store</span><span class="o">.</span><span class="na">isBlocked</span><span class="o">())</span> <span class="o">{</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nf">StoreBlockedException</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="nc">ProductId</span> <span class="n">id</span> <span class="o">=</span> <span class="n">productRepository</span><span class="o">.</span><span class="na">nextId</span><span class="o">();</span>
        <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="n">accout</span><span class="o">.</span><span class="na">createProduct</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">store</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="o">...);</span>
        <span class="n">productRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">product</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span> 
</pre></table></code></div></div><ul><li>코드가 나빠조이진 않지만 중요한 도메인 로직 처리가 응용 서비스에 노출되었다.<ul><li>Store가 Product 를 생성할 수 있는지 여부를 판단하고 Product를 생성하는 것은 논리적으로 하나의 도메인 기능인데 이 도메인 기능을 응용 서비스에서 구현하고 있는 것이다.</ul><li><b>이 도메인 기능을 넣기 위한 별도의 도메인서비스나 팩토리 클래스를 만들수도 있지만 이 기능을 구현하기에 더 좋은 장소는 Store 애그리거트이다.</b><ul><li>Product를 생성하는 기능을 Store 애그리거트에 다음과 같이 옮겨보자.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Store</span> <span class="kd">extends</span> <span class="nc">Member</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">Product</span> <span class="nf">createProduct</span><span class="o">(</span><span class="nc">ProductId</span> <span class="n">newProductId</span><span class="o">,</span> <span class="cm">/*...*/</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isBlocked</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">StoreBlockedException</span><span class="o">();</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">Product</span><span class="o">(</span><span class="n">newProductId</span><span class="o">,</span> <span class="n">getId</span><span class="o">(),</span> <span class="cm">/*...*/</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RegisterProductService</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="nc">ProductId</span> <span class="nf">registerNewProduct</span><span class="o">(</span><span class="nc">NewProductRequest</span> <span class="n">req</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Store</span> <span class="n">account</span> <span class="o">=</span> <span class="n">accountRepository</span><span class="o">.</span><span class="na">findStoreById</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getStoreId</span><span class="o">());</span>
        <span class="n">checkNull</span><span class="o">(</span><span class="n">account</span><span class="o">);</span>
        <span class="nc">ProductId</span> <span class="n">id</span> <span class="o">=</span> <span class="n">productRepository</span><span class="o">.</span><span class="na">nextId</span><span class="o">();</span>
        <span class="nc">Product</span> <span class="n">product</span> <span class="o">=</span> <span class="n">accout</span><span class="o">.</span><span class="na">createProduct</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="cm">/*...*/</span><span class="o">);</span>
        <span class="n">productRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">product</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>Store 애그리거트의 createProduct() 는 Product 애그리거트를 생성하는 패고틸 역할을 한다.<li>앞선 코드와 차이점이라면 응용 서비스에서 더 이상 Store의 상태를 확인하지 않는 다는 것이다.<li>이렇게 함으로써 도메인 응집도도 높아지게 된다.</ul><h2 id="밸류-컬렉션을-entity로-매핑하기">밸류 컬렉션을 @Entity로 매핑하기</h2><h2 id="reference">Reference</h2><ul><li>예제 코드 및 이미지<ul><li><a href="https://minkukjo.github.io/tag/development-ddd/">https://minkukjo.github.io/tag/development-ddd/</a><li><a href="https://velog.io/@freesky/DDD-Start-%EC%95%A0%EA%B7%B8%EB%A6%AC%EA%B1%B0%ED%8A%B8">https://velog.io/@freesky/DDD-Start-%EC%95%A0%EA%B7%B8%EB%A6%AC%EA%B1%B0%ED%8A%B8</a></ul></ul><h1 id="chapter4-리포지터리와-모델구현jpa-중심">Chapter4-리포지터리와 모델구현(JPA 중심)</h1><h2 id="jpa를-이용한-리포지토리-기능-구현">JPA를 이용한 리포지토리 기능 구현</h2><h3 id="모듈-구현">모듈 구현</h3><ul><li>2장에서 언급한 것처럼 리포지토리 인터페이스는 애그리거트와 같이 도메인 영역에 속하고, 리포지터리를 구현한 클래스는 인프라스트럭처 영역에 속한다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235642282-e0cc42bc-a3b5-46e6-974f-32b9ba1f53ca.png" alt="image" /></p><blockquote><p>팀 표준에 따라 리포지터리 구현 클래스를 domain.impl과 같은 패키지에 위치시키는 경우도 있다. 이는 리포지터리 인터페이스와 구현체를 분리하기 위한 타협안 같은 것이지 좋은 설계 원칙을 따르는 것은 아니다. 가능하면 리포지터리 구현 클래스를 인프라스트럭처 영역에 위치시켜서 인프라스트럭처에 대한 의존을 낮춰야 한다.</p></blockquote><h3 id="리포지터리-기본-기능-구현">리포지터리 기본 기능 구현</h3><blockquote><p><strong>삭제 기능</strong>: 삭제 요구사항이 있더라도 여러 이유로 데이터를 실제로 삭제하는 경우는 많지 않다. 관리자 기능에서 삭제한 데이터까지 조회해야 하는 경우도 있고 데이터 원복을 위해 일정 기간 동안 보관해야 할 때도 있기 때문이다. 이런 이유로 사용자가 삭제 기능을 실행시 데이터를 바로 삭제하기 보단 삭제 플래그를 사용해서 화면에 보여줄지 여부를 결정하는 방식으로 구현한다.</p></blockquote><h2 id="매핑-구현">매핑 구현</h2><h3 id="엔티티와-밸류-기본-매핑-구현">엔티티와 밸류 기본 매핑 구현</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Orderer</span> <span class="o">{</span>
	<span class="c1">// MemberId에 정의된 칼럼 이름을 변경하기 위해</span>
  <span class="c1">// @AttributeOverride 애노테이션 사용</span>
  <span class="nd">@Embedded</span>
  <span class="nd">@AttributeOverrides</span><span class="o">(</span><span class="nd">@AttributeOverride</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"id"</span><span class="o">,</span> <span class="n">column</span> <span class="o">=</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"orderer_id"</span><span class="o">)))</span>
  <span class="kd">private</span> <span class="nc">MemberId</span> <span class="n">memberId</span><span class="o">;</span>
  
  <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"orderer_name"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">@AttributeOverrides</code> 어노테이션을 이용해서 매핑할 칼럼 이름을 변경한다.</ul><h3 id="기본-생성자">기본 생성자</h3><ul><li>JPA의 <code class="language-plaintext highlighter-rouge">@Entity</code> 와 <code class="language-plaintext highlighter-rouge">@Embeddable</code> 로 클래스를 매핑하려면 기본 생성자를 제공해야 한다.<li>하이버네이트와 같은 JPA 프로바이더는 DB에서 데이터를 읽어와 매핑된 객체를 생성시 기본 생성자를 사용해서 객체를 생성한다.<ul><li>이런 기술적 제약으로 Receiver와 같은 불변 타입은 기본 생성자가 필요 없음에도 불구하고 다음과 같이 기본 생성자를 추가해야 한다.<li>이때 다른 코드에서 기본 생성자를 사용하지 못하도록 protected 로 선언하는 것이 좋다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Receiver</span> <span class="o">{</span>
  <span class="kd">protected</span> <span class="nf">Receiver</span><span class="o">()</span> <span class="o">{}</span> 
<span class="o">}</span>
</pre></table></code></div></div><blockquote><p><strong>Note</strong>: 하이버네이트는 클래스를 상속한 프록시 객체를 이용해서 지연 로딩을 구현한다. 이 경우 프록시 클래스에서 상위 클래스의 기본 생성자를 호출할 수 있어야 하므로 지연 로딩 대상이 되는 @Entity 와 @Embeddable의 기본 생성자는 private 이 아닌 protected로 지정해야 한다.</p></blockquote><h3 id="필드-접근-방식-사용">필드 접근 방식 사용</h3><ul><li>JPA는 필드와 메서드(get/set)의 두 가지 방식으로 매핑을 처리할 수 있다.<li>엔티티를 객체가 제공할 기능 중심으로 구현하도록 유도하려면 JPA 매핑 처리를 프로퍼티 방식이 아닌 필드 방식으로 선택해서 불필요한 get/set/ 메서드를 구현하지 말아야 한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="c1">// @Access(AccessType.PROPERTY)</span>
<span class="nd">@Access</span><span class="o">(</span><span class="nc">AccessType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
  <span class="nd">@EmbeddableId</span>
  <span class="kd">private</span> <span class="nc">OrderNo</span> <span class="n">number</span><span class="o">;</span>
  
  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><blockquote><p><strong>Note</strong>: JPA 구현체인 하이버네이트는 @Access를 이용해 명시적으로 접근 방식을 지정하지 않으면 @Id나 @EmbeddId가 어디에 위치했느냐에 따라 접근 방식을 결정한다. 즉, 필드에 위치하면 필드 접근 방식을, get 메서드에 위치하면 메서드 접근 방식을 선택한다.</p></blockquote><h3 id="attributeconverter를-이용한-밸류-매핑-처리">AttributeConverter를 이용한 밸류 매핑 처리</h3><ul><li>JPA 2.0 버전에선 두 개 이상의 프로퍼티를 가진 밸류 타입을 한개 DB칼럼에 매핑하기 위해 칼럼과 매핑하기 위한 프로퍼티를 따로 추가하고 get/set 메서드에서 실제 밸류 타입과 변환 처리를 해야 했다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
  <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"WIDTH"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">width</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nc">Length</span> <span class="nf">getWidth</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">Length</span><span class="o">(</span><span class="n">width</span><span class="o">);</span> <span class="c1">// DB 칼럼 값을 실제 프로퍼티 타입으로 변환</span>
  <span class="o">}</span>

  <span class="kt">void</span> <span class="nf">setWidth</span><span class="o">(</span><span class="nc">Length</span> <span class="n">width</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">width</span> <span class="o">=</span> <span class="n">width</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span> <span class="c1">// 실제 프로퍼티 타입을 DB 칼럼 값으로 변환</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>JPA 2.1에선 <code class="language-plaintext highlighter-rouge">AttributeConverter</code>를 사용해서 밸류 타입과 칼럼 데이터 간의 변화 처리를 위한 기능을 사용할 수 있다.<li><code class="language-plaintext highlighter-rouge">autoApply</code>가 true일 경우, 모델에 출현하는 모든 Money 타입의 프로퍼티에 대해 MoneyConverter를 자동으로 적용한다.<ul><li>false 인 경우 프로퍼티 값을 변환할 때 사용할 컨버터를 직접 지정할 수 있다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">AttributeConverter</span><span class="o">&lt;</span><span class="no">X</span><span class="o">,</span> <span class="no">Y</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="no">Y</span> <span class="nf">convertToDatabaseColumn</span><span class="o">(</span><span class="no">X</span> <span class="n">var1</span><span class="o">);</span>

    <span class="no">X</span> <span class="nf">convertToEntityAttribute</span><span class="o">(</span><span class="no">Y</span> <span class="n">var1</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// autoApply가 true일 경우, 모델에 출현하는 모든 Money 타입의 프로퍼티에 대해 MoneyConverter를 자동으로 적용한다.</span>
<span class="c1">// false인 경우, 프로퍼티 값을 변환할 때 사용할 컨버터를 직접 지정할 수 있다.</span>
<span class="nd">@Converter</span><span class="o">(</span><span class="n">autoApply</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">MoneyConverter</span> <span class="kd">implements</span> <span class="nc">AttributeConverter</span><span class="o">&lt;</span><span class="nc">Money</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="nc">Integer</span> <span class="nf">convertToDatabaseColumn</span><span class="o">(</span><span class="nc">Money</span> <span class="n">money</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">money</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">money</span><span class="o">.</span><span class="na">getValue</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span>
  
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="nc">Money</span> <span class="nf">convertToEntityAttribute</span><span class="o">(</span><span class="nc">Integer</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">else</span> <span class="k">return</span> <span class="k">new</span> <span class="nf">Money</span><span class="o">(</span><span class="n">value</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"total_amounts"</span><span class="o">)</span>
  <span class="nd">@Convert</span><span class="o">(</span><span class="n">converter</span> <span class="o">=</span> <span class="nc">MoneyConverter</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Money</span> <span class="n">toalAmounts</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="밸류-컬렉션-별도-테이블-매핑">밸류 컬렉션: 별도 테이블 매핑</h3><ul><li>밸류 타입 컬렉션은 별도 테이블에 보관한다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235647485-edc2a27c-ba9e-4c90-977a-72b1f9da75da.png" alt="image" /></p><ul><li>밸류 컬렉션을 저장하는 ORDER_LINE 테이블은 외부키를 이용해서 엔티티에 해당하는 PURCHASE_ORDER 테이블을 참조한다.<li>이 외부키는 컬렉션이 속할 엔티티를 의미한다.<li>List 타입의 컬렉션은 인덱스 값이 필요하므로 ORDER_LINE 테이블엔 인덱스 값을 저장하기 위한 칼럼(line_idx)도 존재한다.<li>밸류 컬렉션을 별도 테이블로 매핑할 땐 <code class="language-plaintext highlighter-rouge">@ElementCollection</code>과 <code class="language-plaintext highlighter-rouge">@CollectionTable</code> 을 함께 사용한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"purchase_order"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="nd">@ElementCollection</span>
  <span class="nd">@CollectionTable</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"order_line"</span><span class="o">,</span> <span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"order_number"</span><span class="o">))</span>
  <span class="nd">@OrderColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"line_idx"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderLine</span><span class="o">&gt;</span> <span class="n">orderLines</span><span class="o">;</span>
  <span class="o">...</span>
<span class="o">}</span>

<span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderLine</span> <span class="o">{</span>
  <span class="nd">@Embedded</span>
  <span class="kd">private</span> <span class="nc">ProductId</span> <span class="n">productId</span><span class="o">;</span>
  
  <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"price"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">Money</span> <span class="n">price</span><span class="o">;</span>
  
  <span class="o">...</span>  
<span class="o">}</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">@OrderColumn</code> 어노테이션으로 지정한 칼럼에 리스트의 인덱스 값을 지정한다.<li><code class="language-plaintext highlighter-rouge">@CollectionTable</code> 은 밸류를 저장할 테이블을 지정할 때 사용한다.</ul><h3 id="밸류-컬렉션-한-개-칼럼-매핑">밸류 컬렉션: 한 개 칼럼 매핑</h3><ul><li>밸류 컬렉션을 별도 테이블이 아닌 한 개 칼럼에 저장해야 할 때가 있다.<li><code class="language-plaintext highlighter-rouge">AttributeConverter</code> 를 사용하면 쉽게 해결할 수 있는데 밸류 컬렉션을 표현하는 새로운 밸류 타입을 추가해야 한다.(일급 컬렉션)</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmailSet</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Email</span><span class="o">&gt;</span> <span class="n">emails</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashSet</span><span class="o">&lt;&gt;();</span>
  
  <span class="kd">private</span> <span class="nf">EmailSet</span><span class="o">(){}</span>
  <span class="kd">private</span> <span class="nf">EmailSet</span><span class="o">(</span><span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Email</span><span class="o">&gt;</span> <span class="n">emails</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">emails</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">emails</span><span class="o">);</span>
  <span class="o">}</span>
  
  <span class="kd">public</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Email</span><span class="o">&gt;</span> <span class="nf">getEmails</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Collections</span><span class="o">.</span><span class="na">unmodifiableSet</span><span class="o">(</span><span class="n">emails</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="nd">@Converter</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmailSetConverter</span> <span class="kd">implements</span> <span class="nc">AttributeConverter</span><span class="o">&lt;</span><span class="nc">EmailSet</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">convertToDatabaseColumn</span><span class="o">(</span><span class="nc">EmailSet</span> <span class="n">attribute</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">attribute</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="k">return</span> <span class="n">attribute</span><span class="o">.</span><span class="na">getEmails</span><span class="o">().</span><span class="na">stream</span><span class="o">()</span>
      <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="nl">Email:</span><span class="o">:</span><span class="n">toString</span><span class="o">)</span>
      <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="nc">Collectors</span><span class="o">.</span><span class="na">joining</span><span class="o">(</span><span class="s">","</span><span class="o">));</span>
  <span class="o">}</span>
  
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="nc">EmailSet</span> <span class="nf">convertToEntityAttribute</span><span class="o">(</span><span class="nc">String</span> <span class="n">dbData</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">dbData</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="nc">String</span> <span class="n">emails</span> <span class="o">=</span> <span class="n">dbData</span><span class="o">.</span><span class="na">split</span><span class="o">(</span><span class="s">","</span><span class="o">);</span>
    <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">Email</span><span class="o">&gt;</span> <span class="n">emailSet</span> <span class="o">=</span> <span class="nc">Arrays</span><span class="o">.</span><span class="na">stream</span><span class="o">(</span><span class="n">emails</span><span class="o">)</span>
      <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">value</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">Email</span><span class="o">(</span><span class="n">value</span><span class="o">))</span>
      <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">toSet</span><span class="o">());</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">EmailSet</span><span class="o">(</span><span class="n">emailSet</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"emails"</span><span class="o">)</span>
<span class="nd">@Convert</span><span class="o">(</span><span class="n">converter</span> <span class="o">=</span> <span class="nc">EmailSetConverter</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">EmailSet</span> <span class="n">emailSet</span><span class="o">;</span>
</pre></table></code></div></div><h3 id="밸류를-이용한-아이디-매핑">밸류를 이용한 아이디 매핑</h3><ul><li>밸류 타입을 식별자로 매핑하면 <code class="language-plaintext highlighter-rouge">@Id</code> 대신 <code class="language-plaintext highlighter-rouge">@EmbeddedId</code> 어노테이션이 필요하다.<li>JPA에서 식별자 타입은 Serializable 타입이어야 하므로 Serializable 인터페이스를 상속받아야 한다.<li>밸류 타입의 식별자를 구현할 때 얻을 수 있는 장점은 식별자에 기능을 추가할 수 있다. (is2ndGeneration 메서드 참조)</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"purchase_order"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
  <span class="nd">@EmbeddedId</span>
  <span class="kd">private</span> <span class="nc">OrderNo</span> <span class="n">orderId</span><span class="o">;</span>
  <span class="o">...</span>
<span class="o">}</span>

<span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderNo</span> <span class="kd">implements</span> <span class="nc">Serializable</span> <span class="o">{</span>
  <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"order_number"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">number</span><span class="o">;</span>
  
  <span class="c1">// 1세대 시스템의 주문 번호와 2세대 시스템의 주문 번호가 있다고 가정할 때 이를 구분하기 위한 메서드 구현</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">is2ndGeneration</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">number</span><span class="o">.</span><span class="na">startWith</span><span class="o">(</span><span class="s">"N"</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="별도-테이블에-저장하는-밸류-매핑">별도 테이블에 저장하는 밸류 매핑</h3><ul><li>애그리거트에 속한 객체가 밸류인지 엔티티인지 구분하는 방법은 고유 식별자를 갖는지 여부를 확인하는 것이다.<li>하지만, 식별자를 찾을 때 매핑되는 테이블의 식별자(PK)를 애그리거트 구성요소의 식별자와 동일한 것으로 착각해선 안된다.<li>별도 테이블로 저장되고 테이블에 PK가 있다 해서 테이블과 매핑되는 애그리거트 구성요소가 고유 식별자를 갖는 것은 아니다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235649211-20ffc22c-f7bb-4f96-80ad-ae9c279e0ac6.png" alt="image" /></p><ul><li><b>위 이미지에서 ARTICLE_CONTENT 테이블의 ID 칼럼이 식별자이므로 ARTICLE_CONTENT와 매핑되는 AriticleContent를 엔티티로 생각할 수 있는데, 이것 때문에 Article 과 ArticleContent를 두 엔티티 간의 일대일 연관으로 매핑하는 실수를 할 수 있다.</b><li>ArticleContent를 엔티티로 생각할 수 있지만 ArticleContent 는 Article 의 내용을 담고 있는 밸류로 생각하는 것이 맞다.<ul><li>ARTICLE_CONTENT의 ID 는 식별자이기는 하지만 이 식별자를 사용하는 이유는 ARTICLE 테이블의 데이터와 연결하기 위함이지 ARTICLE_CONTENT를 위한 별도 식별자가 필요하기 때문은 아니다.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/235649714-766a4e39-882d-44de-8741-20549f167a97.png" alt="image" /></p><ul><li>이때 <code class="language-plaintext highlighter-rouge">@SecondaryTable</code> 과 <code class="language-plaintext highlighter-rouge">@AttributeOverride</code>를 사용하여 밸류를 매핑한 테이블을 지정한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"article"</span><span class="o">)</span>
<span class="nd">@SecondaryTable</span><span class="o">(</span>
	<span class="n">name</span> <span class="o">=</span> <span class="s">"article_content"</span><span class="o">,</span>
  <span class="n">pkJoinColumns</span> <span class="o">=</span> <span class="nd">@PrimaryKeyJoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"id"</span><span class="o">)</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Article</span> <span class="o">{</span>
  <span class="nd">@Id</span>
  <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
  
  <span class="nd">@AttributeOverrides</span><span class="o">({</span>
    <span class="nd">@AttributeOverride</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"content"</span><span class="o">,</span> <span class="n">column</span> <span class="o">=</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">table</span> <span class="o">=</span> <span class="s">"article_content"</span><span class="o">)),</span>
    <span class="nd">@AttributeOverride</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"contentType"</span><span class="o">,</span> <span class="n">column</span> <span class="o">=</span> <span class="nd">@Column</span><span class="o">(</span><span class="n">table</span> <span class="o">=</span> <span class="s">"article_content"</span><span class="o">))</span>
  <span class="o">})</span>
  <span class="kd">private</span> <span class="nc">ArticleContent</span> <span class="n">content</span><span class="o">;</span>

  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">@SecondaryTable</code>의 name 속성은 밸류를 저장할 테이블을 지정한다.<ul><li>pkJoinColumns 속성은 밸류 테이블에서 엔티티 테이블로 조인할 때 사용할 칼럼을 지정한다.<li>content 필드에 <code class="language-plaintext highlighter-rouge">@AttributeOverride</code> 를 사용하여 해당 밸류 데이터가 저장된 테이블 이름을 지정한다.</ul><li><code class="language-plaintext highlighter-rouge">@SecondaryTable</code>을 이용하면 아래 코드를 실행할 때 두 테이블을 조인해서 데이터를 조회한다</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nc">Article</span> <span class="n">article</span> <span class="o">=</span> <span class="n">entityManager</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Article</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="mi">1L</span><span class="o">);</span>
</pre></table></code></div></div><ul><li>게시글 목록을 보여주는 화면은 article 테이블의 데이터만 필요하지, article_content 테이블의 데이터는 필요하지 않다.<li>그런데, <code class="language-plaintext highlighter-rouge">@SecondaryTable</code> 을 사용하면 목록 화면에 보여줄 <code class="language-plaintext highlighter-rouge">Article</code>을 조회할 때 article_content 테이블까지 조인해서 데이터를 읽어오게 되는 문제가 발생한다.<li><b>이 문제를 해결하기 위해 ArticleContent 를 엔티티로 매핑하고 이를 지연 로딩으로 설정하여 해결할 수도 있다. (둘 다 필요할때만 페치 조인으로 가져오는 방식으로)</b><li><b>하지만 이 방식은 엔티티가 아닌 모델을 엔티티로 만드는 것이므로 좋은 방법은 아니다.</b><ul><li><b>대신 조회 전용 기능을 구현하는 방법을 사용하는 것이 좋다.</b><li>JPA에서 조회 전용 쿼리를 실행하는 방법은 5장에서 살펴본다.</ul></ul><h2 id="밸류-컬렉션을-entity-로-매핑하기">밸류 컬렉션을 @Entity 로 매핑하기</h2><ul><li>개념적으로 밸류인데 구현 기술 한계나 팀 표준으로 @Entity를 사용해야 할 때가 있다.<ul><li>예를 들어, 이미지 업로드 방식에 따라 이미지 경로와 썸네일 이미지 제공 여부가 달라진다고 했을 때 아래와 같은 계층 구조로 설계할 수 있다.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/236620469-eb4cadc9-4a34-4bc6-afa8-4da88b0d05b5.png" alt="image" /></p><ul><li>JPA는 <code class="language-plaintext highlighter-rouge">@Embeddable</code> 타입의 클래스 상속 매핑을 지원하지 않는다.<li>따라서 상속 구조를 갖는 밸류 타입을 사용하려면 <code class="language-plaintext highlighter-rouge">@Embeddable</code> 대신 <code class="language-plaintext highlighter-rouge">@Entity</code> 를 이용한 상속 매핑으로 처리해야 한다.<li><b>Image는 엔티티가 아니라 밸류이므로 상태를 변경하는 기능은 추가하지 않는다.</b></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="nd">@Inheritance</span><span class="o">(</span><span class="n">startegy</span> <span class="o">=</span> <span class="nc">InheritanceType</span><span class="o">.</span><span class="na">SINGLE_TABLE</span><span class="o">)</span>
<span class="nd">@Descriminator</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"image_type"</span><span class="o">)</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"image"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Image</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="c1">// 밸류 타입이므로 상태 변경 기능이 있어선 안된다</span>
<span class="o">}</span>

<span class="nd">@Entity</span>
<span class="nd">@DiscriminatorValue</span><span class="o">(</span><span class="s">"II"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">InternalImage</span> <span class="kd">extends</span> <span class="nc">Image</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>

<span class="nd">@Entity</span>
<span class="nd">@DiscrimnatorValue</span><span class="o">(</span><span class="s">"EI"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ExternalImage</span> <span class="kd">extends</span> <span class="nc">Image</span> <span class="o">{</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>Image는 밸류이므로 독자적인 라이프사이클을 갖지 않고 Product에 완전히 의존한다.<li>따라서 <code class="language-plaintext highlighter-rouge">cascade</code> 속성을 이용해서 Product 를 저장시 함께 저장되고, Product 삭제시 함께 삭제되도록 설정한다.<li>리스트에서 Image 객체를 제거하면 DB에서 함께 삭제되도록 orphanRemoval 을 true로 설정한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="nd">@OneToMany</span><span class="o">(</span><span class="n">cascade</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CascadeType</span><span class="o">.</span><span class="na">PERSIST</span><span class="o">,</span> <span class="nc">CascadeType</span><span class="o">.</span><span class="na">REMOVE</span><span class="o">},</span> <span class="n">orphanRemoval</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
  <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product_id"</span><span class="o">)</span>
  <span class="nd">@OrderColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"list_idx"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Image</span><span class="o">&gt;</span> <span class="n">images</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  <span class="o">...</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeImages</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">Image</span><span class="o">&gt;</span> <span class="n">newImages</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">images</span><span class="o">.</span><span class="na">clear</span><span class="o">();</span>
    <span class="n">images</span><span class="o">.</span><span class="na">addAll</span><span class="o">(</span><span class="n">newImages</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>하이버네이트에선 위처럼 엔티티를 위한 컬렉션 객체(images)의 clear 메서드를 호출시 select 쿼리로 대상 엔티티를 로딩 후 각 개별 엔티티에 대해 delete 쿼리를 수행한다.<ul><li>변경 빈도가 낮으면 괜찮지만 빈도가 높으면 전체 서비스 성능에 문제가 될 수 도 있다.</ul><li>하이버네이트는 위와 반대로 <code class="language-plaintext highlighter-rouge">@Embeddable</code> 타입에 대한 컬렉션의 clear() 메서드를 호출하면 컬렉션에 속한 객체를 로딩하지 않고 한 번의 delete 쿼리로 삭제 처리를 수행한다,,<ul><li>이 경우엔 타입에 따라 다른 기능을 구현하려면 다음과 같이 if-else를 써야 하는 단점이 발생한다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="nd">@Embeddable</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Image</span> <span class="o">{</span>
  <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"image_type"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">imageType</span><span class="o">;</span>
  <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"image_path"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">path</span><span class="o">;</span>

  <span class="o">...</span>
  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">hasThumbnail</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 성능을 위해 다형을 포기하고 if-else로 구현</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">imageType</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="s">"II"</span><span class="o">))</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>코드 유지보수와 성능의 두 가지 측면을 고려해서 구현방식을 적절히 선택해야 한다.</ul><h2 id="id-참조와-조인-테이블을-이용한-단방향-mn-매핑">ID 참조와 조인 테이블을 이용한 단방향 M:N 매핑</h2><ul><li>앞서 3장에서 애그리거트 간 집합 연관은 성능상의 이유로 피해야 한다고 했다.<li>그럼에도 불구하고 필요하다면 ID 참조를 이용한 단방향 집합 연관을 적용해 볼 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product"</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
  <span class="nd">@EmbeddedId</span>
  <span class="kd">private</span> <span class="nc">ProductId</span> <span class="n">id</span><span class="o">;</span>
    
  <span class="nd">@ElementCollection</span> 
  <span class="nd">@CollectionTable</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product_category"</span><span class="o">,</span> <span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product_id"</span><span class="o">))</span>
  <span class="kd">private</span> <span class="nc">Set</span><span class="o">&lt;</span><span class="nc">CategoryId</span><span class="o">&gt;</span> <span class="n">categoryIds</span><span class="o">;</span>

  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>ID 참조를 이용한 애그리거트 간 단방향 M:N 연관은 밸류 컬렉션 매핑과 동일한 방식으로 설정한 것을 알 수 있다.<li><code class="language-plaintext highlighter-rouge">@ElementCollection</code> 을 이용하기 때문에 Product 를 삭제할 때 매핑에 사용한 조인 테이블의 데이터도 함께 삭제된다.<li>애그리거트를 직접 참조하는 방식을 사용했다면 영속성 전파나 로딩 전략을 고민해야 하는데 ID 참조방식을 사용함으로써 이런 고민을 할 필요가 사라지게 된다.</ul><h2 id="애그리거트-로딩-전략">애그리거트 로딩 전략</h2><ul><li>JPA 매핑을 설정할 때 항상 기억해야 할 점은 애그리거트에 속한 객체가 모두 모여야 완전한 하나가 된다는 것이다.<li>즉, 다음과 같이 애그리거트 루트를 로딩시 루트에 속한 모든 객체가 완전한 상태여야 함을 의미한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">// product 는 완전한 하나여야 한다.</span>
<span class="nc">Prodcut</span> <span class="n">product</span> <span class="o">=</span> <span class="n">productRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
</pre></table></code></div></div><ul><li>엔티티에 대한 매핑의 fetch 속성을 즉시 로딩(FetchType,EAGER)로 설정하면 find() 메서드로 애그리거트 루트를 구할 때 연관된 구성요소를 DB에서 함께 읽어온다.<li>하지만 컬렉션에 대해 로딩 전략을 EAGER 로 설정시엔 오히려 즉시 로딩 방식이 문제가 될 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="nd">@OneToMany</span><span class="o">(</span>
    <span class="n">cascade</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CascadeType</span><span class="o">.</span><span class="na">PERSIST</span><span class="o">,</span> <span class="nc">CascadeType</span><span class="o">.</span><span class="na">REMOVE</span><span class="o">},</span>
    <span class="n">orphanRemoval</span> <span class="o">=</span> <span class="kc">true</span><span class="o">,</span>
    <span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">Eager</span><span class="o">)</span>
  <span class="nd">@JoineColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product_id"</span><span class="o">)</span>
  <span class="nd">@OrderColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"list_idx"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Image</span><span class="o">&gt;</span> <span class="n">images</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

  <span class="nd">@ElementCollection</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">EAGER</span><span class="o">)</span>
  <span class="nd">@CollectionTable</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product_option"</span><span class="o">,</span> <span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product_id"</span><span class="o">))</span>
  <span class="nd">@OrderColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"list_idx"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Option</span><span class="o">&gt;</span> <span class="n">options</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  
  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>위와 같이 images 와 options 모두 EAGER 로 지정되어있을때 카타시안 조인을 사용해 불러오는데 이는 쿼리 결과에 중복을 발생한다.<ul><li>Proudct의 image 가 2개이고 option이 2개이면 쿼리 결과로 구해지는 행 개수는 4개일 것이다.<li>만약 데이터가 많다고하면 성능 문제가 될 수도 있다.</ul><li><b>애그리거트는 개념적으로 하나여야 하지만, 루트 엔티티를 로딩하는 시점에 애그리거트에 속한 객체를 모두 로딩해야 하는 것은 아니다.</b><li>애그리거트가 완전해야 하는 이유는 두 가지다.<ul><li>1)상태를 변경하는 기능 실행시 애그리거트 상태가 완전해야 하기 때문에<li>2)표현 영역에서 애그리거트의 상태 정보를 보여줄 때 필요하기 때문에</ul><li>두 번째 이유는 별도의 조회 전용 기능을 구현하는 방식을 사용하는 것이 유리할 때가 많기에 애그리거트의 완전한 로딩과 관련된 문제는 상태 변경과 더 관련이 있다.<li>하지만 상태 변경 기능을 실행하기 위해 조회 시점에 즉시 로딩을 이용해서 애그리거트를 완전한 상태로 로딩할 필욘 없다.<li>JPA는 트랜잭션 범위 내에서 지연 로딩을 허용하기 때문에 다음 코드처럼 실제로 상태를 변경하는 시점에 필요한 구성요소만 로딩해도 문제가 되지 않는다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeOptions</span><span class="o">(</span><span class="nc">ProductId</span> <span class="n">id</span><span class="o">,</span> <span class="kt">int</span> <span class="n">optIdxToBeDeleted</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// Product 를 로딩. 컬렉션은 지연 로딩으로 설정했다면, Option은 로딩하지 않음</span>
  <span class="nc">Prodcut</span> <span class="n">product</span> <span class="o">=</span> <span class="n">productRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
  <span class="c1">// 트랜잭션 범위이므로 지연 로딩으로 설정한 연관 로딩 가능</span>
  <span class="n">product</span><span class="o">.</span><span class="na">removeOption</span><span class="o">(</span><span class="n">optIdxToBeDeleted</span><span class="o">);</span>
<span class="o">}</span>

<span class="nd">@Entity</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Product</span> <span class="o">{</span>
  <span class="nd">@ElementCollection</span><span class="o">(</span><span class="n">fetch</span> <span class="o">=</span> <span class="nc">FetchType</span><span class="o">.</span><span class="na">LAZY</span><span class="o">)</span>
  <span class="nd">@CollectionTable</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product_option"</span><span class="o">,</span> <span class="n">joinColumns</span> <span class="o">=</span> <span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product_id"</span><span class="o">))</span>
  <span class="nd">@OrderColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"list_idx"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Option</span><span class="o">&gt;</span> <span class="n">options</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
  
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">removeOption</span><span class="o">(</span><span class="kt">int</span> <span class="n">optIdx</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 실제 컬렉션에 접근할 때 로딩</span>
    <span class="k">this</span><span class="o">.</span><span class="na">options</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">optIdx</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>상태를 변경하는 기능을 실행하는 빈도보다 조회하는 기능을 실행하는 빈도가 훨씬 높다.<ul><li>그러므로 상태 변경을 위해 지연 로딩을 사용할 때 발생하는 추가 쿼리로 인한 실행 속도 저하는 문제 되지 않는다.</ul><li>위와 같은 이유로 애그리거트 내의 모든 연관을 즉시 로딩으로 설정할 필욘 없다. 애그리거트에 맞게 즉시 로딩과 지연 로딩을 적절히 선택해야 한다.</ul><h2 id="애그리거트의-영속성-전파">애그리거트의 영속성 전파</h2><ul><li>애그리거트를 저장하거나 삭제할땐 애그리거트에 속한 모든 객체를 함께 저장하거나, 함께 삭제해야 한다.<li><code class="language-plaintext highlighter-rouge">@Embeddable</code> 매핑 타입의 경우엔 함께 저장되고 삭제되므로 cascade 속성을 추가로 설정하지 않아도 된다.<li>반면에 @Entity 타입에 대한 매핑은 cascade 속성을 사용해서 저장과 삭제시 함께 처리되도록 설정해야 한다.<li><code class="language-plaintext highlighter-rouge">@OneToOne</code>, <code class="language-plaintext highlighter-rouge">@OneToMany</code> 는 cascade 속성의 기본값이 없으므로 다음 코드처럼 cascade 속성 값으로 CascadeType.PERSIST, CascadeType.REMOVE 를 설정해야 한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nd">@OneToMany</span><span class="o">(</span><span class="n">cascade</span> <span class="o">=</span> <span class="o">{</span><span class="nc">CascadeType</span><span class="o">.</span><span class="na">PERSIST</span><span class="o">,</span> <span class="nc">CascadeType</span><span class="o">.</span><span class="na">REMOVE</span><span class="o">},</span>
          <span class="n">orphanRemoval</span> <span class="o">=</span> <span class="kc">true</span><span class="o">)</span>
<span class="nd">@JoinColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"product_id"</span><span class="o">)</span>
<span class="nd">@OrderColumn</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"list_idx"</span><span class="o">)</span>
<span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Image</span><span class="o">&gt;</span> <span class="n">images</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</pre></table></code></div></div><h2 id="식별자-생성-기능">식별자 생성 기능</h2><ul><li>식별자는 아래 세 가지 방식 중 하나로 생성한다.<ul><li>1)사용자가 직접 생성<li>2)도메인 로직으로 생성<li>3)DB 를 이용한 일련번호 생성</ul></ul><h3 id="1-사용자가-직접-생성">1) 사용자가 직접 생성</h3><ul><li>식별자 생성주체가 사용자이므로 도메인 영역에 식별자 생성 기능을 구현할 필요 없다.</ul><h3 id="2-도메인-로직으로-생성">2) 도메인 로직으로 생성</h3><ul><li>별도 서비스로 식별자 생성 기능을 분리해야 한다.<li>식별자 생성 규칙은 도메인 규칙이므로 도메인 영역에 식별자 생성 기능을 위치시켜야 한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderIdService</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nc">OrderId</span> <span class="nf">createId</span><span class="o">(</span><span class="nc">UserId</span> <span class="n">userId</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">userId</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">IllegalArgumentException</span><span class="o">(</span><span class="s">"invalid userid: "</span> <span class="o">+</span> <span class="n">userId</span><span class="o">);</span>

      <span class="k">return</span> <span class="k">new</span> <span class="nf">OrderId</span><span class="o">(</span><span class="n">userId</span><span class="o">.</span><span class="na">toString</span><span class="o">()</span> <span class="o">+</span> <span class="s">"-"</span> <span class="o">+</span> <span class="n">timestamp</span><span class="o">());</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="nc">String</span> <span class="nf">timestamp</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="nc">Long</span><span class="o">.</span><span class="na">toString</span><span class="o">(</span><span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>또한 식별자 생성 규칙을 규현하기에 적합한 또 다른 위치는 리포지터리이다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ProductRepository</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="nc">ProductId</span> <span class="nf">nexxtId</span><span class="o">();</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="3-db-를-이용한-일련번호-생성">3) DB 를 이용한 일련번호 생성</h3><ul><li>JPA는 저장 시점에 생성한 식별자를 @Id로 매핑한 프로퍼티/필드에 할당한다.<li>실제 저장(영속화)된 후에 할당된 식별자를 사용할 수 있다.</ul><h2 id="reference-1">Reference</h2><ul><li>예제 코드 및 이미지<ul><li><a href="https://heeveloper.github.io/2020/07/18/04-%EB%A6%AC%ED%8F%AC%EC%A7%80%ED%84%B0%EC%99%80-%EB%AA%A8%EB%8D%B8-%EA%B5%AC%ED%98%84/">https://heeveloper.github.io/2020/07/18/04-%EB%A6%AC%ED%8F%AC%EC%A7%80%ED%84%B0%EC%99%80-%EB%AA%A8%EB%8D%B8-%EA%B5%AC%ED%98%84/</a></ul></ul><h1 id="chapter5-스프링-데이터-jpa를-이용한-조회기능">Chapter5-스프링 데이터 JPA를 이용한 조회기능</h1><h2 id="시작에-앞서">시작에 앞서</h2><ul><li>CQRS 는 명령(COMMAND) 모델과 조회(Query) 모델을 분리하는 패턴이다.<ul><li>명령 모델은 상태(데이터)를 변경하는 기능을 구현할 때 사용된다(ex. 회원 가입, 암호 변경, 주문 취소)<li>조회 모델은 데이터를 조회하는 기능을 구현시 사용된다.(ex. 주문 목록, 주문 상세)</ul><li>주문 취소, 배송지 변경 기능을 포함하여 앞에서 살펴본 것 처럼 도메인 모델은 명령 모델로 주로 사용된다.<li>반면에, 이 장에서 설명할 정렬, 페이징, 검색 조건 지정과 같은 기능은 주문 목록, 상품 상세와 같은 조회기능에서 사용된다. 즉 이장에서 살펴볼 구현 방법은 조회 모델을 구현시 주로 사용한다.</ul><blockquote><p><strong>Note</strong>: 모든 DB연동 코드를 JPA만 사용해서 구현해야 한다고 생각하진 말자. MyBatis, JdbcTemplate 등 다양한 기술을 사용해서 조회 모델을 구현할 수 있다.</p></blockquote><h2 id="검색을-위한-스펙">검색을 위한 스펙</h2><ul><li>검색 조건이 고정되어 있다면 특정 조건으로 조회하는 기능을 만들면 되지만, 만약 검색 조건을 다양하게 조합해야 할 때 사용할 수 있는 것이 스펙(Specification)이다.<li>스펙은 애그리거트가 특정 조건을 충족하는지를 검사할 때 사용하는 인터페이스다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kt">boolean</span> <span class="nf">isSatisfiedBy</span><span class="o">(</span><span class="no">T</span> <span class="n">agg</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>agg 파라미터는 검사 대상이 되는 객체이며 리포지터리에서 사용하면 애그리거트 루트가 되고 스펙을 DAO 에 사용하면 검색 결과로 리턴할 데이터 객체가 된다.<li>isSatisfiedBy() 메서드는 검사 대상 객체가 조건을 충족하면 true를 리턴하고, 그렇지 않으면 false 를 리턴한다.<li>예를 들어, Order 애그리거트 객체가 특정 고객의 주문인지 확인하는 스펙은 다음과 같이 구현 가능하다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrdererSpec</span> <span class="kd">implements</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">orderId</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">OrdererSpec</span><span class="o">(</span><span class="nc">String</span> <span class="n">ordererId</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">ordererId</span> <span class="o">=</span> <span class="n">ordererId</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isSatisfiedBy</span><span class="o">(</span><span class="nc">Order</span> <span class="n">agg</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">agg</span><span class="o">.</span><span class="na">getOrdererId</span><span class="o">().</span><span class="na">getMemberId</span><span class="o">().</span><span class="na">getId</span><span class="o">().</span><span class="na">equasl</span><span class="o">(</span><span class="n">orererId</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>리포지터리나 DAO는 검색 대상을 걸러내는 용도로 스펙을 사용한다.<li>만약 리포지토리가 메모리에 모든 애그리거트를 보관하고 있다면 다음과 같이 스펙을 사용할 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">MemberOrderRepository</span> <span class="kd">implements</span> <span class="nc">OrderRepository</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="nf">findAll</span><span class="o">(</span><span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">spec</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">allOrders</span> <span class="o">=</span> <span class="n">findAll</span><span class="o">();</span>
    <span class="k">return</span> <span class="n">allOrders</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">filter</span><span class="o">(</span><span class="n">order</span> <span class="o">-&gt;</span> <span class="n">spec</span><span class="o">.</span><span class="na">isSatisfiedBy</span><span class="o">(</span><span class="n">order</span><span class="o">))</span>
                    <span class="o">.</span><span class="na">toList</span><span class="o">();</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span>

<span class="c1">// 검색 조건을 표현하는 스펙을 생성</span>
<span class="nc">SPecification</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">ordererSpec</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">OrdererSpec</span><span class="o">(</span><span class="s">"madvirus"</span><span class="o">);</span>
<span class="c1">// 리포지터리에 전달</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">Order</span><span class="o">&gt;</span> <span class="n">orders</span> <span class="o">=</span> <span class="n">orderRepository</span><span class="o">.</span><span class="na">findAll</span><span class="o">(</span><span class="n">ordererSpec</span><span class="o">);</span>
</pre></table></code></div></div><ul><li>하지만 실제 스펙은 이렇게 구현하지 않는다.<li>모든 애그리거트 객체를 메모리에 보관핟기도 어렵고 설사 메모리에 다 보관할 수 있다하더라도 조회 성능에 심각한 문제가 발생하기 때문이다.<li>실제 스펙은 사용하는 기술에 맞춰 구현하면 되는데 스프링 데이터 JPA를 이용한 스펙 구현에 대해 알아볼 것이다.</ul><h2 id="스프링-데이터-jpa를-이용한-스펙-구현">스프링 데이터 JPA를 이용한 스펙 구현</h2><ul><li>스프링 데이터 JPA 는 검색 조건을 표현하기 위한 인터페이스인 Specification 을 제공한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Serializable</span> <span class="o">{</span>
  <span class="c1">// not, where, and, or 메서드 생략</span>

  <span class="nd">@Nullable</span>
  <span class="nc">Predicate</span> <span class="nf">toPredicate</span><span class="o">(</span><span class="nc">Root</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">root</span><span class="o">,</span> 
                        <span class="nc">CriteriaQuery</span> <span class="n">query</span><span class="o">,</span> 
                        <span class="nc">CriteriaBuilder</span> <span class="n">cb</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>제네릭 타입 파라미터 T는 JPA엔티티 타입을 의미하며, toPredicate() 메서드는 JPA Criteria API에서 조건을 표현하는 Predicate 를 생성한다.<li>이를 활용한 예시는 아래와 같다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrdererIdSpec</span> <span class="kd">implements</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">ordererId</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">OrdererIdSpec</span><span class="o">(</span><span class="nc">String</span> <span class="n">ordererId</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">ordererId</span> <span class="o">=</span> <span class="n">ordererId</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="nc">Predicate</span> <span class="nf">toPredicate</span><span class="o">(</span><span class="nc">Root</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">root</span><span class="o">,</span> 
                        <span class="nc">CriteriaQuery</span> <span class="n">query</span><span class="o">,</span> 
                        <span class="nc">CriteriaBuilder</span> <span class="n">cb</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">cb</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">OrderSummary_</span><span class="o">.</span><span class="na">ordererId</span><span class="o">),</span> <span class="n">ordererId</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>OrdererSummary 엔티티에 대한 검색 조건을 표현한다.<li>ordererId 프로퍼티 값이 생성자로 전달받은 값과 동일한지 비교하는 Predicate 를 생성한다.<li>스펙 구현 클래스를 개별적으로 만들지 않고 별도 클래스에 스펙 생성 기능을 모아도 된다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderSummarySpec</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="nf">ordererId</span><span class="o">(</span><span class="nc">String</span> <span class="n">ordererId</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="nc">Root</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="n">root</span><span class="o">,</span> <span class="nc">CriteriaQuery</span><span class="o">&lt;?&gt;</span> <span class="n">query</span><span class="o">,</span> <span class="nc">CriteriaBuilder</span> <span class="n">cb</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="n">cb</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">root</span><span class="o">.&lt;</span><span class="nc">String</span><span class="o">&gt;</span><span class="n">get</span><span class="o">(</span><span class="s">"ordererId"</span><span class="o">),</span> <span class="n">ordererId</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="nf">orderDateBetween</span><span class="o">(</span><span class="nc">LocalDateTime</span> <span class="n">from</span><span class="o">,</span> <span class="nc">LocalDateTime</span> <span class="n">to</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">return</span> <span class="o">(</span><span class="nc">Root</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="n">root</span><span class="o">,</span> <span class="nc">CriteriaQuery</span><span class="o">&lt;?&gt;</span> <span class="n">query</span><span class="o">,</span> <span class="nc">CriteriaBuilder</span> <span class="n">cb</span><span class="o">)</span> <span class="o">-&gt;</span>
      <span class="n">cb</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">root</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">OrderSummary_</span><span class="o">.</span><span class="na">orderDate</span><span class="o">),</span> <span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 스펙 생성이 필요한 코드는 스펙 생성 기능을 제공하는 클래스를 이용해서 조금 더 간결하게 스펙을 생성 가능하다.</span>
<span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="n">betweenSpec</span> <span class="o">=</span> <span class="nc">OrderSummarySpecs</span><span class="o">.</span><span class="na">orderDateBetween</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">);</span>
</pre></table></code></div></div><h3 id="jpa-정적-메타-모델">JPA 정적 메타 모델</h3><ul><li>위 예제 코드에서 OrderSummary_.ordererId 로 사용되는 부분이 있는데, OrderSummary_ 클래스는 JPA정적 메타 모델을 정의한 코드이다.<li>정적 메타 모델 클래스는 다음과 같이 구현 가능하다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nd">@StaticMetamoidel</span><span class="o">(</span><span class="nc">OrderSummary</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderSummary_</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="nc">SingularAttribute</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">number</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="nc">SingularAttribute</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="n">version</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="nc">SingularAttribute</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">ordererId</span><span class="o">;</span>
  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">volatile</span> <span class="nc">SingularAttribute</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="n">ordererName</span><span class="o">;</span>
  <span class="o">...</span> <span class="n">생략</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>정적 메타 모델은 <code class="language-plaintext highlighter-rouge">@StaticMetamodel</code> 애너테이션을 이용해서 관련 모델을 지정한다.<li>메타 모델 클래스는 모델 클래스의 이름 뒤에 ‘_‘을 붙인 이름을 갖는다.<li>정적 메타 모델 클래스는 대상 모델의 각 프로퍼티와 동일한 이름을 갖는 정적 필드를 정의한다.<li>이 정적 필드는 프로퍼티에 대한 메타 모델로서 프로퍼티 타입에 따라 SingularAttribute, ListAttribute 등의 타입을 사용해서 메타 모델을 정의한다.<li>정적 메타 모델을 사용하는 대신 문자열로 프로퍼티를 지정할 수도 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">cb</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">root</span><span class="o">.&lt;</span><span class="nc">String</span><span class="o">&gt;</span><span class="n">get</span><span class="o">(</span><span class="s">"ordererId"</span><span class="o">),</span> <span class="n">ordererId</span><span class="o">);</span>
</pre></table></code></div></div><ul><li>하지만 문자열은 오타 가능성이 있고, 실행전까진 오타가 있다는 것을 놓치기 쉽다.<li>게다가 IDE의 코드 자동 완성 기능을 사용할 수 없어 입력할 코드도 많아진다.<li>이런 이유로 Criteria를 사용할땐 정적 메타 모델 클래스를 사용하는 것이 코드 안정성이나 생산성 측면에서 유리하다.<li>정적 메타 모델 클래스를 직접 작성할 수 있지만 하이버네이트와 같은 JPA 프로바이더는 정적 메타 모델을 생성하는 도구를 제공하고 있으므로 이들 도구를 사용하면 편리하다.</ul><h2 id="리포지터리dao에서-스펙-사용하기">리포지터리/DAO에서 스펙 사용하기</h2><ul><li>스펙을 충족하는 엔티티를 검색하고 싶다면 findAll() 메서드를 사용하면 된다.<li>스프링 데이터 JPA 사용시 JpaSpecificationExecutor 를 상속받아서 사용 가능하다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">JpaSpecificationExecutor</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="c1">// 생략...</span>
  
  <span class="nc">List</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">findAll</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">spec</span><span class="o">);</span>

  <span class="c1">// 생략...</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="스펙-조합">스펙 조합</h2><ul><li>스프링 데이터 JPA가 제공하는 스펙 인터페잇느느 스펙을 조합할 수 있는 두 메서드 <code class="language-plaintext highlighter-rouge">and()</code>, <code class="language-plaintext highlighter-rouge">or()</code> 를 제공하다.<ul><li>and(): 두 스펙을 모두 충족하는 조건을 표현하는 스펙 생성<li>or(): 두 스펙 중 하나 이상 충족하는 조건을 표현하는 스펙을 생성</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="kd">extends</span> <span class="nc">Serializable</span> <span class="o">{</span>

  <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">not</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">spec</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
  <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">where</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">spec</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
  <span class="k">default</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">and</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">other</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
  <span class="k">default</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">or</span><span class="o">(</span><span class="nd">@Nullable</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">other</span><span class="o">)</span> <span class="o">{</span> <span class="o">...</span> <span class="o">}</span>
  
  <span class="nd">@Nullable</span>
  <span class="nc">Predicate</span> <span class="nf">toPredicate</span><span class="o">(</span><span class="nc">Root</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">root</span><span class="o">,</span> <span class="nc">CriteriaQuery</span> <span class="n">query</span><span class="o">,</span> <span class="nc">CriteriaBuilder</span> <span class="n">cb</span><span class="o">);</span> 
<span class="o">}</span>
</pre></table></code></div></div><ul><li>아래 코드는 spec1.and(spec2) 는 spec1 과 spec2 를 모두 충족하는 조건을 표현하는 spec3를 생성한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="n">spec1</span> <span class="o">=</span> <span class="nc">OrderSummarySpecs</span><span class="o">.</span><span class="na">ordererId</span><span class="o">(</span><span class="s">"user1"</span><span class="o">);</span>
<span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="n">spec2</span> <span class="o">=</span> <span class="nc">OrderSummarySpecs</span><span class="o">.</span><span class="na">orderDateBetween</span><span class="o">(</span><span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">2022</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">),</span>
 <span class="nc">LocalDateTime</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">2022</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>

<span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="n">spec3</span> <span class="o">=</span> <span class="n">spec1</span><span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">spec2</span><span class="o">);</span>
</pre></table></code></div></div><ul><li>아래와 같은 체이닝 기법으로 사용가능하여 불필요한 변수를 선언하지 않아도 된다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="n">spec</span> <span class="o">=</span> <span class="nc">OrderSummarySpecs</span><span class="o">.</span><span class="na">ordererId</span><span class="o">(</span><span class="s">"user1"</span><span class="o">)</span>
<span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="nc">OrderSummarySpecs</span><span class="o">.</span><span class="na">orderDateBetween</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">));</span>
</pre></table></code></div></div><ul><li>not() 메서드는 정적 메서드로 조건을 반대로 적용할때 사용한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="n">spec1</span> <span class="o">=</span> <span class="nc">Specification</span><span class="o">.</span><span class="na">not</span><span class="o">(</span><span class="nc">OrderSummarySpecs</span><span class="o">.</span><span class="na">ordererId</span><span class="o">(</span><span class="s">"user1"</span><span class="o">));</span>
</pre></table></code></div></div><ul><li>null 가능성이 있는 스펙 객체와 다른 스펙을 조합해야 할 때 Null 체크를 매번 하려면 다소 귀찮다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="n">nullableSpec</span> <span class="o">=</span> <span class="n">createNullableSpec</span><span class="o">();</span> <span class="c1">// null일 수 있음</span>
<span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="n">oterSpec</span> <span class="o">=</span> <span class="n">createOtherSpec</span><span class="o">();</span>

<span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">nullable</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">?</span> <span class="n">otherSpec</span> <span class="o">:</span> <span class="n">nullableSpec</span><span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">otherSpec</span><span class="o">);</span>
</pre></table></code></div></div><ul><li>where() 메서드를 사용면 이런 귀찮음을 줄일 수 있다.<ul><li>null을 전달하면 아무 조건도 생성하지 않는 스펙 객체를 리턴하고 null이 아니면 인자로 받은 스펙 객체를 그대로 리턴하다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="n">spec</span> <span class="o">=</span> <span class="nc">Specification</span><span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="n">createNulalbleSpec</span><span class="o">()).</span><span class="na">and</span><span class="o">(</span><span class="n">createOtherSpec</span><span class="o">());</span>
</pre></table></code></div></div><h2 id="정렬-지정하기">정렬 지정하기</h2><ul><li>스프링 데이터 JPA는 두 가지 방법을 사용해서 정렬을 지정 가능하다.</ul><h2 id="1-메서드-이름에-orderby를-사용해서-정렬-기준-지정">1) 메서드 이름에 OrderBy를 사용해서 정렬 기준 지정</h2><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">OrderSummaryRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
  
  <span class="c1">// 메서드 이름</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="nf">findAllByOrderByOrderDateDescNumberAsc</span><span class="o">(</span><span class="nc">String</span> <span class="n">ordererId</span><span class="o">);</span> <span class="c1">// OrderDate 프로퍼티 기준으로 내림차순 정렬 후 Number 프로퍼티 기준으로 오름차순으로 정렬</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>위 방법의 단점은 정렬 조건이 많아질수록 메서드명이 길어진다는 것과 메서드 일므으로 정렬 순서가 정해지기 때문에 상황에 따라 정렬순서를 변경할 수도 없다.<li>이땐 아래 Sort 타입을 사용하면 된다.</ul><h2 id="2-sort를-인자로-전달">2) Sort를 인자로 전달</h2><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">OrderSummaryRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
   
  <span class="c1">// Sort</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="nf">findAllByOrdererId</span><span class="o">(</span><span class="nc">String</span> <span class="n">ordererId</span><span class="o">,</span> <span class="nc">Sort</span> <span class="n">sort</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>Sort 객체를 생성해서 인자로 넘겨주면 스프링 데이터 JPA 내부적으로 알아서 정렬 쿼리를 적용한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nc">Sort</span> <span class="n">sort</span> <span class="o">=</span> <span class="nc">Sort</span><span class="o">.</span><span class="na">by</span><span class="o">(</span><span class="s">"number"</span><span class="o">).</span><span class="na">ascending</span><span class="o">();</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="n">orderSummaryDao</span><span class="o">.</span><span class="na">findByOrdererId</span><span class="o">(</span><span class="s">"user1"</span><span class="o">,</span> <span class="n">sort</span><span class="o">);</span>

<span class="c1">// 두 개 이상의 정렬 순서를 지정하고 싶다면 Sort#and() 메서드를 사용해서 두 sort 객체를 연결하면 된다.</span>
<span class="nc">Sort</span> <span class="n">sort1</span> <span class="o">=</span> <span class="nc">Sort</span><span class="o">.</span><span class="na">by</span><span class="o">(</span><span class="s">"number"</span><span class="o">).</span><span class="na">ascending</span><span class="o">();</span>
<span class="nc">Sort</span> <span class="n">sort2</span> <span class="o">=</span> <span class="nc">Sort</span><span class="o">.</span><span class="na">by</span><span class="o">(</span><span class="s">"orderDate"</span><span class="o">).</span><span class="na">descending</span><span class="o">();</span>

<span class="nc">Sort</span> <span class="n">sort</span> <span class="n">sort1</span><span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">sort2</span><span class="o">);</span>

<span class="c1">// 메서드 체이닝도 가능하다.</span>
<span class="nc">Sort</span> <span class="n">sort</span> <span class="o">=</span> <span class="nc">Sort</span><span class="o">.</span><span class="na">by</span><span class="o">(</span><span class="s">"number"</span><span class="o">).</span><span class="na">ascending</span><span class="o">().</span><span class="na">and</span><span class="o">(</span><span class="nc">Sort</span><span class="o">.</span><span class="na">by</span><span class="o">(</span><span class="s">"orderDate"</span><span class="o">).</span><span class="na">descending</span><span class="o">());</span>
</pre></table></code></div></div><h2 id="페이징-처리하기">페이징 처리하기</h2><ul><li>스프링 데이터 JPA 는 페이징 처리를 위해 Pageable 인터페이스 타입을 이용한다.<li>Sort 타입과 마찬가지로 find 메서드에 Pageable 타입 파라미터를 사용하면 페이징을 자동으로 처리해준다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">OrderSummaryRepository</span> <span class="kd">extends</span> <span class="nc">JpaRepository</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">,</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="o">{</span>
  
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="nf">findByOrderByNumberDesc</span><span class="o">(</span><span class="nc">String</span> <span class="n">ordererId</span><span class="o">,</span> <span class="nc">Pagable</span> <span class="n">pagable</span><span class="o">);</span>

  <span class="c1">// 목록뿐 아니라 조건에 해당하는 전체 개수 및 페이징 처리에 필요한 데이터도 함께 제공</span>
  <span class="nc">Page</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="nf">findByOrderByNumberDesc</span><span class="o">(</span><span class="nc">String</span> <span class="n">ordererId</span><span class="o">,</span> <span class="nc">Pagable</span> <span class="n">pagable</span><span class="o">);</span>
  
<span class="o">}</span>
</pre></table></code></div></div><ul><li>이를 실제 호출할땐 Pageable 의 구현체인 PageRequest 객체를 생성해야 한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="nc">PageRequest</span> <span class="n">pageReq</span> <span class="o">=</span> <span class="nc">PageRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span> <span class="c1">// 페이지 번호, 한 페이지의 개수 (페이지 번호는 0부터 시작)</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">&gt;</span> <span class="n">user</span> <span class="o">=</span> <span class="n">memberDataDao</span><span class="o">.</span><span class="na">findbyNameLike</span><span class="o">(</span><span class="s">"사용자%"</span><span class="o">,</span> <span class="n">pageReq</span><span class="o">);</span>
</pre></table></code></div></div><ul><li>PageRequest 와 Sort 를 사용하면 정렬 순서도 지정가능하다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">Sort</span> <span class="n">sort</span> <span class="o">=</span> <span class="nc">Sort</span><span class="o">.</span><span class="na">by</span><span class="o">(</span><span class="s">"name"</span><span class="o">).</span><span class="na">descending</span><span class="o">();</span>
<span class="nc">PageRequest</span> <span class="n">pageReq</span> <span class="o">=</span> <span class="nc">PageRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="n">sort</span><span class="o">);</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">&gt;</span> <span class="n">user</span> <span class="o">=</span> <span class="n">memberDataDao</span><span class="o">.</span><span class="na">findbyNameLike</span><span class="o">(</span><span class="s">"사용자%"</span><span class="o">,</span> <span class="n">pageReq</span><span class="o">);</span>
</pre></table></code></div></div><ul><li>Pageable 을 사용하는 메서드의 리턴타입이 Page 일 경우 스프링 데이터 JPA는 목록 조회 쿼리와 함께 COUNT 쿼리도 실행해서 조건에 해당하는 데이터 갯수를 구한다.<li>Page 는 전체 개수, 페이지 개수 등 페이징 처리에 필요한 데이터도 함께 제공한다.<li>다음은 Page 가 제공하는 메서드의 일부를 보여준다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="nc">PageRequest</span> <span class="n">pageReq</span> <span class="o">=</span> <span class="nc">PageRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="mi">3</span><span class="o">);</span>
<span class="nc">Page</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">&gt;</span> <span class="n">user</span> <span class="o">=</span> <span class="n">memberDataDao</span><span class="o">.</span><span class="na">findbyBlocked</span><span class="o">(</span><span class="kc">false</span><span class="o">,</span> <span class="n">pageReq</span><span class="o">);</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">&gt;</span> <span class="n">content</span> <span class="o">=</span> <span class="n">page</span><span class="o">.</span><span class="na">getContent</span><span class="o">();</span> <span class="c1">// 조회 결과 목록</span>
<span class="kt">long</span> <span class="n">totalElements</span> <span class="o">=</span> <span class="n">page</span><span class="o">.</span><span class="na">getTotalElements</span><span class="o">();</span> <span class="c1">// 조건에 해당하는 전체 개수</span>
<span class="kt">int</span> <span class="n">totalPages</span> <span class="o">=</span> <span class="n">page</span><span class="o">.</span><span class="na">getTotalPages</span><span class="o">();</span> <span class="c1">// 전체 페이지 번호</span>
<span class="kt">int</span> <span class="n">number</span> <span class="o">=</span> <span class="n">page</span><span class="o">.</span><span class="na">getNumber</span><span class="o">();</span> <span class="c1">// 현재 페이지 번호</span>
<span class="kt">int</span> <span class="n">numberOfElements</span> <span class="o">=</span> <span class="n">page</span><span class="o">.</span><span class="na">getNumberOfElements</span><span class="o">();</span> <span class="c1">// 조회 결과 개수</span>
<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">page</span><span class="o">.</span><span class="na">getSize</span><span class="o">();</span> <span class="c1">// 페이지 크기</span>
</pre></table></code></div></div><ul><li>스펙을 사용하는 findAll() 메서드도 Pageable 을 사용할 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberDataDao</span> <span class="kd">extends</span> <span class="nc">Repository</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">,</span> <span class="nc">String</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nc">Page</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">&gt;</span> <span class="nf">findAll</span><span class="o">(</span><span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">&gt;</span> <span class="n">spec</span><span class="o">,</span> <span class="nc">Pageable</span> <span class="n">pageable</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><blockquote><p><strong>Note</strong>: 프로퍼티를 비교하는 findBy프로퍼티 형식의 메서드는 Pageable 타입을 사용하더라도 리턴타입이 List 면 COUNT 쿼리를 실행하지 않는다. 반면 스펙을 사용한 findAll 메서드에 Pageable 타입을 사용하면 리턴타입이 Page 가 아니어도 COUNT 쿼리를 실행한다. 만약 스펙을 사용하고 페이징 처리를 하면서 COUNT 쿼리는 실행하고 싶지 않다면 스프링 데이터 JPA가 제공하는 커스텀 리포지터리 기능을 이용해서 직접 구현해야 한다. 구현 방법이 궁금하면 https://javacan.tistory.com/entry/spring-data-jpa-range-query 문서를 참고하면 좋다.</p></blockquote><ul><li>쳐음부터 N개의 데이터가 필요하다면 Pageable 을 사용하지 않고 findFirstN형식의 메서드를 사용할 수도 있다.<li>예를 들어 다음 메서드는 name 프로퍼티 기준으로 like 검색한 결과를 name 프로퍼티 기준으로 오름차순 정렬해서 처음 3개를 조회한다. First 대신 Top을 사용해도 된다.<ul><li>만약 First나 Top 뒤에 숫자가 없으면 한 개 결과만 리턴한다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="nc">List</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">&gt;</span> <span class="nf">findFirst3ByNameLikeOrderByName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">);</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">&gt;</span> <span class="nf">findTop3ByNameLikeOrderByName</span><span class="o">(</span><span class="nc">String</span> <span class="n">name</span><span class="o">);</span>

<span class="nc">MemberData</span> <span class="nf">findFirstByBlockedOrderById</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">blocked</span><span class="o">);</span>
</pre></table></code></div></div><h2 id="스펙-조합을-위한-스펙-빌더-클래스">스펙 조합을 위한 스펙 빌더 클래스</h2><ul><li>스펙을 생성하다보면 다음 코드처럼 조건에 따라 스펙을 조합해야 할 때가 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">&gt;</span> <span class="n">spec</span> <span class="o">=</span> <span class="nc">Specification</span><span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>

<span class="k">if</span> <span class="o">(</span><span class="n">searchReq</span><span class="o">.</span><span class="na">isOnleyNotBlocked</span><span class="o">())</span> <span class="o">{</span>
  <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="nc">MemberDataSpecs</span><span class="o">.</span><span class="na">nonBlocked</span><span class="o">());</span>
<span class="o">}</span>

<span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">hasText</span><span class="o">(</span><span class="n">searchRequest</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span> <span class="o">{</span>
  <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="nc">MemberDataSpecs</span><span class="o">.</span><span class="na">nameLike</span><span class="o">(</span><span class="n">searchRequest</span><span class="o">.</span><span class="na">getName</span><span class="o">()));</span>
<span class="o">}</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="n">memberDataDao</span><span class="o">.</span><span class="na">findAll</span><span class="o">(</span><span class="nc">Spec</span><span class="o">,</span> <span class="nc">PageRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>
</pre></table></code></div></div><ul><li>위 코드는 if와 각 스펙을 조합하는 코드가 섞여 있어 실수하기 좋고 복잡한 구조를 갖는다.<li>이 점을 보완하기 위해 필자는 스펙 빌더를 만들어 사용한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">&gt;</span> <span class="n">spec</span> <span class="o">=</span> <span class="nc">SpecBuilder</span><span class="o">.</span><span class="na">builder</span><span class="o">(</span><span class="nc">MemberData</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
        <span class="o">.</span><span class="na">ifTrue</span><span class="o">(</span><span class="n">searchRequest</span><span class="o">.</span><span class="na">isOnlyNotBlocked</span><span class="o">(),</span>
        <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">MemberDataSpecs</span><span class="o">.</span><span class="na">nonBlocked</span><span class="o">())</span>
        <span class="o">.</span><span class="na">ifHasText</span><span class="o">(</span><span class="n">searchReq</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span>
        <span class="n">name</span> <span class="o">-&gt;</span> <span class="nc">MemberDataSpecs</span><span class="o">.</span><span class="na">nameLike</span><span class="o">(</span><span class="n">searchReq</span><span class="o">.</span><span class="na">getName</span><span class="o">()))</span>
        <span class="o">.</span><span class="na">toSpec</span><span class="o">();</span>

<span class="nc">List</span><span class="o">&lt;</span><span class="nc">MemberData</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="n">memberDataDao</span><span class="o">.</span><span class="na">findAll</span><span class="o">(</span><span class="n">spec</span><span class="o">,</span> <span class="nc">PageRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">5</span><span class="o">));</span>
</pre></table></code></div></div><ul><li>if 블록을 사용할 때와 비교하면 코드양은 비슷하지만 메서드를 사용해서 조건을 표현하고 메서드 호출 체인으로 연속된 변수할당을 줄여 코드 가독성을 높이고 구조가 단순해진다.<li>스펙 빌더 코드는 아래와 같다. and(), ifHasText(), ifTrue() 메서드 외에는 직접 추가해서 사용하면 된다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpecBuilder</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nc">Builder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">builder</span><span class="o">(</span><span class="nc">Class</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">type</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nc">Builder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;();</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Builder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="o">{</span>
        <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">specs</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>

        <span class="kd">private</span> <span class="kt">void</span> <span class="nf">addSpec</span><span class="o">(</span><span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">spec</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">spec</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">specs</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">spec</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nc">Builder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">and</span><span class="o">(</span><span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">spec</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">addSpec</span><span class="o">(</span><span class="n">spec</span><span class="o">);</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nc">Builder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">ifHasText</span><span class="o">(</span><span class="nc">String</span> <span class="n">str</span><span class="o">,</span>
                                    <span class="nc">Function</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">specSupplier</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="nc">StringUtils</span><span class="o">.</span><span class="na">hasText</span><span class="o">(</span><span class="n">str</span><span class="o">))</span> <span class="o">{</span>
                <span class="n">addSpec</span><span class="o">(</span><span class="n">specSupplier</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">str</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nc">Builder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">ifTrue</span><span class="o">(</span><span class="nc">Boolean</span> <span class="n">cond</span><span class="o">,</span>
                                 <span class="nc">Supplier</span><span class="o">&lt;</span><span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">specSupplier</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">cond</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">cond</span><span class="o">.</span><span class="na">booleanValue</span><span class="o">())</span> <span class="o">{</span>
                <span class="n">addSpec</span><span class="o">(</span><span class="n">specSupplier</span><span class="o">.</span><span class="na">get</span><span class="o">());</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="o">&lt;</span><span class="no">V</span><span class="o">&gt;</span> <span class="nc">Builder</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">ifNotNull</span><span class="o">(</span><span class="no">V</span> <span class="n">value</span><span class="o">,</span>
                                        <span class="nc">Function</span><span class="o">&lt;</span><span class="no">V</span><span class="o">,</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;&gt;</span> <span class="n">specSupplier</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">value</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">addSpec</span><span class="o">(</span><span class="n">specSupplier</span><span class="o">.</span><span class="na">apply</span><span class="o">(</span><span class="n">value</span><span class="o">));</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="kd">public</span> <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="nf">toSpec</span><span class="o">()</span> <span class="o">{</span>
            <span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">spec</span> <span class="o">=</span> <span class="nc">Specification</span><span class="o">.</span><span class="na">where</span><span class="o">(</span><span class="kc">null</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">Specification</span><span class="o">&lt;</span><span class="no">T</span><span class="o">&gt;</span> <span class="n">s</span> <span class="o">:</span> <span class="n">specs</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">spec</span> <span class="o">=</span> <span class="n">spec</span><span class="o">.</span><span class="na">and</span><span class="o">(</span><span class="n">s</span><span class="o">);</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">spec</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="동적-인스턴스-생성">동적 인스턴스 생성</h2><ul><li>JPA 는 쿼리 결과에서 임의의 객체를 동적으로 생성할 수 있는 기능을 제공하고 있다.<ul><li>Projection 을 의미한다.</ul><li>조회 전용 모델을 만드는 이유는 표현 영역을 통해 사용자에게 데이터를 보여주기 위함이다.<li>동적 인스턴스의 장점은 JPQL 을 그대로 사용하므로 객체 기준 쿼리를 사용하면서도 지연/즉시 로딩과 같은 고민이 필요없이 데이터를 조회할 수 있다는 점이다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">OrderSummaryDao</span> <span class="kd">extends</span> <span class="nc">Repository</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">,</span><span class="nc">String</span><span class="o">&gt;{</span>
	<span class="nd">@Query</span><span class="o">(</span><span class="s">"select new com.myship.order.query.dto.OrderView(o.number, o.state, m.name, m.id, p.name)
    from Order o join o.orderLines ol, Member m, Product p
    where o.orderer.memberId.id = m.id
    	and index(ol) = 0
        and ol.productId.id = p.id
        order by o.number.number desc"</span><span class="o">)</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderView</span><span class="o">&gt;</span> <span class="nf">findOrderView</span><span class="o">(</span><span class="nc">String</span> <span class="n">ordererId</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderView</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">number</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">OrderState</span> <span class="n">state</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">memberName</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">memberId</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kd">final</span> <span class="nc">String</span> <span class="n">productName</span><span class="o">;</span>
  
  <span class="kd">public</span> <span class="nf">OrderView</span><span class="o">(</span><span class="nc">OrderNo</span> <span class="n">number</span><span class="o">,</span> 
                  <span class="nc">OrderState</span> <span class="n">state</span><span class="o">,</span>
                  <span class="nc">String</span> <span class="n">memberName</span><span class="o">,</span> 
                  <span class="nc">MemberId</span> <span class="n">memberId</span><span class="o">,</span> 
                  <span class="nc">String</span> <span class="n">productName</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">number</span> <span class="o">=</span> <span class="n">number</span><span class="o">.</span><span class="na">getNumeber</span><span class="o">();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">memberName</span> <span class="o">=</span> <span class="n">memberName</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">memberId</span> <span class="o">=</span> <span class="n">memberId</span><span class="o">.</span><span class="na">getId</span><span class="o">();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">productName</span> <span class="o">=</span> <span class="n">productName</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="o">...</span> <span class="c1">// get 메서드</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="하이버네이트-subselect-사용">하이버네이트 @Subselect 사용</h2><ul><li>하이버네이트는 JPA 확장 기능으로 <code class="language-plaintext highlighter-rouge">@Subselect</code> 를 제공한다.<li><code class="language-plaintext highlighter-rouge">@Subselect</code> 는 쿼리 결과를 @Entity로 매핑할 수 있는 유용한 기능이다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">org.hibernate.annotations.Immutable</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.hibernate.annotations.Subselect</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">org.hibernate.annotations.Synchronize</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">javax.persistence.Column</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.persistence.Entity</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.persistence.Id</span><span class="o">;</span>

<span class="nd">@Entity</span>
<span class="nd">@Immutable</span>
<span class="nd">@Subselect</span><span class="o">(</span>
        <span class="sc">'''</span><span class="err">'</span>
        <span class="n">select</span> <span class="n">o</span><span class="o">.</span><span class="na">order_number</span> <span class="n">as</span> <span class="n">number</span><span class="o">,</span>
        <span class="n">o</span><span class="o">.</span><span class="na">version</span><span class="o">,</span> <span class="n">o</span><span class="o">.</span><span class="na">orderer_id</span><span class="o">,</span> <span class="n">o</span><span class="o">.</span><span class="na">orderer_name</span><span class="o">,</span>
        <span class="n">o</span><span class="o">.</span><span class="na">total_amounts</span><span class="o">,</span> <span class="n">o</span><span class="o">.</span><span class="na">receiver_name</span><span class="o">,</span> <span class="n">o</span><span class="o">.</span><span class="na">state</span><span class="o">,</span> <span class="n">o</span><span class="o">.</span><span class="na">order_date</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">product_id</span><span class="o">,</span> <span class="n">p</span><span class="o">.</span><span class="na">name</span> <span class="n">as</span> <span class="n">product_name</span>
        <span class="n">from</span> <span class="n">purchase_order</span> <span class="n">o</span> <span class="n">inner</span> <span class="n">join</span> <span class="n">order_line</span> <span class="n">ol</span>
            <span class="n">on</span> <span class="n">o</span><span class="o">.</span><span class="na">order_number</span> <span class="o">=</span> <span class="n">ol</span><span class="o">.</span><span class="na">order_number</span>
            <span class="n">cross</span> <span class="n">join</span> <span class="n">product</span> <span class="n">p</span>
        <span class="n">where</span> <span class="n">ol</span><span class="o">.</span><span class="na">line_idx</span> <span class="o">=</span> <span class="mi">0</span> <span class="n">and</span> <span class="n">ol</span><span class="o">.</span><span class="na">product_id</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="na">product_id</span>
        <span class="sc">'''</span><span class="err">'</span>
<span class="o">)</span>
<span class="nd">@Synchronize</span><span class="o">({</span><span class="s">"purchase_order"</span><span class="o">,</span> <span class="s">"order_line"</span><span class="o">,</span> <span class="s">"product"</span><span class="o">})</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderSummary</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">number</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">version</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"orderer_id"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">ordererId</span><span class="o">;</span>

    <span class="nd">@Column</span><span class="o">(</span><span class="n">name</span><span class="o">=</span><span class="s">"orderer_name"</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">ordererName</span><span class="o">;</span>

    <span class="kd">protected</span> <span class="nf">OrderSummary</span><span class="o">(){</span>

    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">@Immutable</code>, <code class="language-plaintext highlighter-rouge">@Subelect</code>, <code class="language-plaintext highlighter-rouge">@Synchronize</code> 는 하이버네이트 전용 애너테이션인데 이 애너테이션을 사용하면 테이블이 아닌 쿼리 결과를 @Entity로 매핑할 수 있다.<li><code class="language-plaintext highlighter-rouge">@Subselect</code> 는 조회 쿼리를 값으로 갖는다. 하이버네이트는 이 select 쿼리의 결과를 매핑할 테이블처럼 사용한다.<li>DBMS가 여러 테이블을 조인ㅇ해서 조회한 결과를 한 테이블처럼 보여주기 위한 용도로 뷰를 사용하는 것처럼 <code class="language-plaintext highlighter-rouge">@Subselect</code> 를 사용하면 쿼리 실행 결과를 매핑할 테이블처럼 사용한다.<li>뷰를 수정할 수 없듯이 <code class="language-plaintext highlighter-rouge">@Subselect</code> 로 조회한 <code class="language-plaintext highlighter-rouge">@Entity</code> 역시 수정할 수 없다.<li>실수로 <code class="language-plaintext highlighter-rouge">@Subselect</code> 를 이용한 <code class="language-plaintext highlighter-rouge">@Entity</code>의 매핑 필드를 수정하면 하이버네이트는 변경 내역을 반영하는 update 쿼리를 실행할텐데 매핑 한 테이블이 없으므로 에러가 발생한다.<li>이런 문제를 방지하기 위해 <code class="language-plaintext highlighter-rouge">@Immutable</code> 을 사용하는데 하이버네이트는 해당 엔티티의 매핑 필드/프로퍼티가 변경되도 DB에 반영하지 않고 무시한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// purchase_order 테이블에서 조회</span>
<span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">orderNumber</span><span class="o">);</span>
<span class="n">order</span><span class="o">.</span><span class="na">changeShippingInfo</span><span class="o">(</span><span class="n">newInfo</span><span class="o">);</span> <span class="c1">// 상태 변경</span>

<span class="c1">// 변경 내역이 DB에 반영되지 않았는데 purchase_order 테이블에서 조회</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="n">summaries</span> <span class="o">=</span> <span class="n">orderSummaryRepository</span><span class="o">.</span><span class="na">findByOrdererId</span><span class="o">(</span><span class="n">userId</span><span class="o">);</span>
</pre></table></code></div></div><ul><li>위 코드는 Order의 상태를 변경한 뒤에 OrderSummary 를 조회하고 있다.<li><b>특별한 이유가 없으면 하이버네이트는 트랜잭션을 커밋하는 시점에 변경사항을 DB에 반영하므로, Order의 변경 내역을 아직 purchase_order 테이블에 반영하지 않은 상태에서 purchase_order 테이블을 사용하는 OrderSummary 를 조회하게 된다. 즉, OrderSummary 에는 최신 값이 아닌 이전 값이 담기게 된다.</b><li>이런 문제를 해소하기 위한 용도로 사용한 것이 <code class="language-plaintext highlighter-rouge">@Synchronize</code> 이다.<ul><li>해당 엔티티와 관련된 테이블 목록을 명시한다.<li>하이버네이트는 엔티티를 로딩전에 지정한 테이블과 관련된 변경사항이 발생하면 플러시를 먼저 한다.<li>OrderSummary 의 <code class="language-plaintext highlighter-rouge">@Synchronize</code> 는 ‘purchase_order’ 테이블을 지정하고 있으므로 OrderSummary 를 로딩하기 전에 purchase_order 테이블에 변경이 발생하면 관련 내역을 먼저 플러시 한다.<li>따라서 OrderSummary를 로딩하는 시점엔 변경 내역이 반영된다.</ul><li><code class="language-plaintext highlighter-rouge">@Subselect</code> 를 사용해도 일반 Entity 와 같기 때문에 EntityManager#find(), JPQL, Criteria 를 사용해서 조회할 수 있는 것이 @Subselect 의 장점이다. 이것은 초반에 설명한 스펙을 사용할 수 있따는 것도 포함된다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">// @Subselect 를 적용한 @Entity 는 일반 @Entity 와 동일한 방법으로 조회할 수 있다.</span>
<span class="nc">Specification</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="n">spec</span> <span class="o">=</span><span class="n">orderDateBetween</span><span class="o">(</span><span class="n">from</span><span class="o">,</span> <span class="n">to</span><span class="o">);</span>
<span class="nc">Pageable</span> <span class="n">pageable</span> <span class="o">=</span> <span class="nc">PageRequest</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">10</span><span class="o">);</span>
<span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderSummary</span><span class="o">&gt;</span> <span class="n">results</span> <span class="o">=</span> <span class="n">orderSummaryDao</span><span class="o">.</span><span class="na">findAll</span><span class="o">(</span><span class="n">spec</span><span class="o">,</span> <span class="n">pageable</span><span class="o">);</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">@Subselect</code>는 이름처럼 @Subselect 의 값으로 지정한 쿼리를 from절의 서브 쿼리로 사용한다. 즉, 실행하는 쿼리는 당므과 같은 형식을 갖는다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">select</span> <span class="n">osm</span><span class="p">.</span><span class="n">number</span> <span class="k">as</span> <span class="n">number1_0_</span><span class="p">,</span> <span class="p">...</span> <span class="err">생략</span>
<span class="k">from</span>  <span class="p">(</span>
    <span class="k">select</span> <span class="n">o</span><span class="p">.</span><span class="n">order_number</span> <span class="k">as</span> <span class="n">number</span><span class="p">,</span>
    <span class="n">o</span><span class="p">.</span><span class="k">version</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">orderer_id</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">orderer_name</span><span class="p">,</span>
    <span class="n">o</span><span class="p">.</span><span class="n">total_amounts</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">receiver_name</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="k">state</span><span class="p">,</span> <span class="n">o</span><span class="p">.</span><span class="n">order_date</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">product_id</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">name</span> <span class="k">as</span> <span class="n">product_name</span>
    <span class="k">from</span> <span class="n">purchase_order</span> <span class="n">o</span> <span class="k">inner</span> <span class="k">join</span> <span class="n">order_line</span> <span class="n">ol</span>
        <span class="k">on</span> <span class="n">o</span><span class="p">.</span><span class="n">order_number</span> <span class="o">=</span> <span class="n">ol</span><span class="p">.</span><span class="n">order_number</span>
        <span class="k">cross</span> <span class="k">join</span> <span class="n">product</span> <span class="n">p</span>
    <span class="k">where</span> <span class="n">ol</span><span class="p">.</span><span class="n">line_idx</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">and</span> <span class="n">ol</span><span class="p">.</span><span class="n">product_id</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">product_id</span>
<span class="p">)</span> <span class="n">osm</span>
<span class="k">where</span> <span class="n">osm</span><span class="p">.</span><span class="n">orderer_id</span> <span class="o">=</span> <span class="o">?</span> <span class="k">order</span> <span class="k">by</span> <span class="n">osm</span><span class="p">.</span><span class="n">number</span> <span class="k">desc</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">@Subselect</code> 를 사용할 때는 쿼리가 이러한 형태를 갖는다는 점을 유념해야 한다.<li>서브 쿼리를 사용하고 싶지 않다면 네이티브 SQL 쿼리를 사용하거나 마이바티스와 같은 별도 매퍼를 사용해서 조회 기능을 구현해야 한다.</ul><h2 id="reference-2">Reference</h2><ul><li>예제 코드 및 이미지<ul><li><a href="https://velog.io/@csh0034/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-05.-%EC%8A%A4%ED%94%84%EB%A7%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-JPA%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%A1%B0%ED%9A%8C-%EA%B8%B0%EB%8A%A5">https://velog.io/@csh0034/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-05.-%EC%8A%A4%ED%94%84%EB%A7%81-%EB%8D%B0%EC%9D%B4%ED%84%B0-JPA%EB%A5%BC-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%A1%B0%ED%9A%8C-%EA%B8%B0%EB%8A%A5</a></ul></ul><h1 id="chapter6-응용-서비스와-표현-영역">Chapter6-응용 서비스와 표현 영역</h1><h2 id="표현-영역과-응용-영역">표현 영역과 응용 영역</h2><ul><li>응용 영역과 표현 영역은 사용자와 도메인을 연결해주는 매개체 역할을 한다.</ul><h3 id="응용-영역의-책임">응용 영역의 책임</h3><ul><li>응용 영역은 실제 사용자가 원하는 기능을 제공한다.</ul><h3 id="표현-영역의-책임">표현 영역의 책임</h3><ul><li>응용 서비스가 요구하는 형식으로 사용자 요청을 변환<li>응용 서비스를 실행 한 후 실행 결과를 사용자에 알맞은 형식으로 응답</ul><blockquote><p>사용자와의 상호작용은 표현 영역이 처리하기 때문에 응용 서비스는 표현 영역에 의존하지 않는다. 응용 영역은 사용자가 웹 브라우저를 사용하는지, REST API를 호출하는지, TCP 소켓을 사용하는지 여부를 알 필요가 없다. 단지, 응용 영역은 기능 실해에 필요한 입력값을 전달받고 실행 결과만 리턴하면 될 뿐이다.</p></blockquote><h2 id="응용-서비스의-역할">응용 서비스의 역할</h2><h3 id="1-도메인-객체-간의-실행-흐름-제어">1. 도메인 객체 간의 실행 흐름 제어</h3><ul><li>사용자(클라이언트)가 요청한 기능을 실행한다.<li>사용자의 요청을 처리하기 위해 리포지터리로부터 도메인 객체를 구하고, 도메인 객체를 사용한다.<li>도메인 객체 간의 흐름을 제어하기 때문에 아래와 같이 단순한 형태를 가진다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="nc">Result</span> <span class="nf">doSomeFunc</span><span class="o">(</span><span class="nc">SomeReq</span> <span class="n">req</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 1. 리포지터리에서 애그리거트를 구한다.</span>
    <span class="nc">SomeAgg</span> <span class="n">agg</span> <span class="o">=</span> <span class="n">someAggRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
    <span class="n">checkNull</span><span class="o">(</span><span class="n">agg</span><span class="o">);</span>

    <span class="c1">// 2. 애그리거트의 도메인 기능을 실행한다.</span>
    <span class="n">agg</span><span class="o">.</span><span class="na">doFunc</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>

    <span class="c1">// 3. 결과를 리턴한다.</span>
    <span class="k">return</span> <span class="nf">createSuccessResult</span><span class="o">(</span><span class="n">agg</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>응용 서비스가 이것보다 복잡하다면 응용 서비스에서 도메인 로직의 일부를 구현하고 있을 가능성이 높다.</ul><h3 id="2-트랜잭션-처리">2. 트랜잭션 처리</h3><ul><li>데이터 일관성을 보장하기 위한 트랜잭션 처리를 한다.</ul><blockquote><p>위 두 가지 이외에도 접근 제어와 이벤트 처리가 있는데 뒤에서 살펴본다.</p></blockquote><h2 id="도메인-로직-넣지-않기">도메인 로직 넣지 않기</h2><ul><li>아래 예제 코드와 같이 패스워드 일치 여부를 검사하는 도메인 로직은 도메인 영역에서 제공해야 한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">changePassword</span><span class="o">(</span><span class="nc">String</span> <span class="n">oldPw</span><span class="o">,</span> <span class="nc">String</span> <span class="n">newPw</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">matchPassword</span><span class="o">(</span><span class="n">oldPw</span><span class="o">))</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">BadPasswordException</span><span class="o">();</span>
        <span class="n">setPassword</span><span class="o">(</span><span class="n">newPw</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 현재 암호와 일치하는지 검사하는 도메인 로직</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">matchPassword</span><span class="o">(</span><span class="nc">String</span> <span class="n">pwd</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">passwordEncoder</span><span class="o">.</span><span class="na">matchs</span><span class="o">(</span><span class="n">pwd</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">setPassword</span><span class="o">(</span><span class="nc">String</span> <span class="n">newPw</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">isEmpty</span><span class="o">(</span><span class="n">newPw</span><span class="o">))</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">IllegalArgumentException</span><span class="o">(</span><span class="s">"no new password"</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">password</span> <span class="o">=</span> <span class="n">newPw</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>도메인 로직을 도메인 영역과 응용 서비스에서 분산해서 구현하면 코드 품질에 두 가지 문제가 발생한다.</ul><h3 id="1-코드의-응집성-떨어진다">1. 코드의 응집성 떨어진다.</h3><ul><li>도메인 데이터와 그 데이터를 조작하는 도메인 로직이 한 영역에 위치하지 않고 서로 다른 영역에 위치한다는 것은 도메인 로직을 파악하기 위해 여러 영역을 분석해야 한다는 것을 뜻한다.</ul><h3 id="2-여러-응용-서비스에서-동일한-도메인-로직을-구현할-가능성이-높아진다는-것이다">2. 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높아진다는 것이다.</h3><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DeactivationService</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deactivate</span><span class="o">(</span><span class="nc">String</span> <span class="n">memberId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">pwd</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">memberId</span><span class="o">);</span>
    
    <span class="k">if</span> <span class="o">(!</span><span class="n">passwordEncoder</span><span class="o">.</span><span class="na">matches</span><span class="o">(</span><span class="n">oldPw</span><span class="o">,</span> <span class="n">member</span><span class="o">.</span><span class="na">getPassword</span><span class="o">()))</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">BadPasswordException</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="n">member</span><span class="o">.</span><span class="na">deactivate</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>위처럼 도메인 로직을 여러 응용 서비스에서 구현하게 되면 중복 코드가 발생하게 된다.<ul><li>만약 패스워도 변경시에도 패스워드 일치 여부를 확인하는 로직이 필요하다면 중복해서 코드를 작성하게 될 것이다.</ul><li>이는 결과적으로 코드 변경을 어렵게 만든다.</ul><blockquote><p><strong>Note</strong>: 소프트웨어의 중요한 경쟁 요소 중 하나는 변경의 용이성인데, 변경이 어렵게 된다는 것은 그만큼 소프트웨어의 가치가 떨어진다는 것을 뜻한다. 소프트웨어의 가치를 높이려면 도메인 로직을 도메인 영역에 모아서 코드 중복이 발생하지 않도록 하고 응집도를 높여야 한다.</p></blockquote><h2 id="응용-서비스의-구현">응용 서비스의 구현</h2><ul><li>응용 서비스는 표현 영역과 도메인 영역을 연결하는 매개체 역할을 하는데 이는 디자인 패턴에서 파사트(facade)와 같은 역할을 한다.<li>응용 서비스 자체는 복잡한 로직을 수행하지 않기 때문에 응용 서비스의 구현은 어렵지 않다.<li>응용 서비스 구현시 몇 가지 고려할 사항과 트랜잭션과 같은 구현 기술의 연동에 대해 살펴보자.</ul><h3 id="응용-서비스의-크기">응용 서비스의 크기</h3><p><b>1)응용 서비스 클래스에 회원 도메인의 모든 기능 구현하기</b></p><ul><li>장점: 한 도메인과 관련된 기능을 구현한 코드가 한 클래스에 위치하므로 각 기능에서 동일 로직에 대한 코드 중복을 제거할 수 있다.<li>단점: 한 서비스 클래스의 크기가 커진다. 연관성이 적은 코드가 한클래스에 함께 위치할 가능성이 높아짐을 의미하는데, 결과적으로 관련 없는 코드가 뒤섞여서 코드를 이해하는데 방해가 될 수 있다.<ul><li>예를 들어, 암호 초기화 기능을 구현한 initializePassword() 메서드는 암호 초기화 후 신규 암호를 사용자에게 통지하기 위해 Notfier 를 사용하는데, changePassword() 메서드에선 필요치 않은 기능이다.<li>하지만 Notifier 가 필드로 존재하므로 이 Notifier 가 어떤 기능 때문에 필요한지 확인하려면 각 기능을 구현한 코드를 뒤져야만 한다.<li>그리고 엄연히 분리하는 것이 좋은 상황임에도 습관적으로 기존에 존재하는 클래스에 억지로 끼워 넣게 된다. 이는 코드를 점점 얽히게 만들어 코드 품질을 낮추는 결과를 초래한다.</ul></ul><p><b>2)구분되는 기능별로 응용 서비스 클래스를 따로 구현하기</b></p><ul><li>장점: 코드 품질을 일정 수준으로 유지하는데 도움이 된다. 또한, 각 클래스별로 필요한 의존 객체만 포함하므로 다른 기능을 구현한 코드에 영향을 받지 않는다.<li>만약, 각 기능마다 동일한 로직을 구현할 경우 여러 클래스에 중복해서 동일한 코드를 구현할 가능성이 있는데, 이를 방지하기 위해 다음과 같이 별도 클래스에 로직을 구현해서 코드가 중복되는 것을 방지할 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="c1">// 각 응용 서비스에서 공통되는 로직을 별도 클래스로 구현</span>
<span class="kd">public</span> <span class="kd">final</span> <span class="kd">class</span> <span class="nc">MemberServiceHelper</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="nc">Member</span> <span class="nf">findExistingMember</span><span class="o">(</span><span class="nc">MemberRepository</span> <span class="n">repo</span><span class="o">,</span> <span class="nc">String</span> <span class="n">memberId</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">memberId</span><span class="o">);</span>
        <span class="k">if</span><span class="o">(</span><span class="n">member</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NoMemberException</span><span class="o">(</span><span class="n">memberId</span><span class="o">);</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">member</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 공통 로직을 제공하는 메서드를 응용 서비스에서 사용</span>
<span class="kn">import</span> <span class="nn">static</span> <span class="n">com</span><span class="o">.</span><span class="na">myshop</span><span class="o">.</span><span class="na">member</span><span class="o">.</span><span class="na">application</span><span class="o">.</span><span class="na">MemberServiceHelper</span><span class="o">.*;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChangePasswordService</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">changePassword</span><span class="o">(</span><span class="nc">String</span> <span class="n">memberId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">oldPw</span><span class="o">,</span> <span class="nc">String</span> <span class="n">newPw</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">findExistingMember</span><span class="o">(</span><span class="n">memberRepository</span><span class="o">,</span> <span class="n">memberId</span><span class="o">);</span>
        <span class="n">member</span><span class="o">.</span><span class="na">setPassword</span><span class="o">(</span><span class="n">newPw</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><blockquote><p><strong>Note</strong>: 저자는 한 클래스가 여러 역할을 갖는 것보다(전자) 각 클래스마다 구분되는 역할을 갖는 것을 선호한다고 한다. 즉, 한 도메인과 관련된 기능을 하나의 응용 서비스 클래스에서 모두 구현하는 방식보단 구분되는 기능을 별도의 서비스 클래스로 구현하는 방식을 사용한다고 한다.</p></blockquote><h2 id="응용-서비스의-인터페이스와-클래스">응용 서비스의 인터페이스와 클래스</h2><ul><li>인터페이스를 유용하게 사용할 수 있는 경우는 다음과 같다.<ul><li>1)구현 클래스가 다수 존재할때<li>2)런타임에 구현 객체를 교체해야 할 경우</ul><li>하지만 응용 서비스는 보통 런타임에 이를 교체할 경우가 거의 없을 뿐만 아니라 한 응용 서비스의 구현 클래스가 두 개인 경우도 매우 드물다.<li><b>인터페이스가 명확하게 필요하기 전까지는 으용 서비스에 대한 인터페이스를 작성하는 것이 좋은 설계라 볼 수 없다.</b><li>표현 영역의 단위 테스트를 할 때 Mockito 와 같은 테스트 도구를 통해 테스트용 가짜 객체를 만들 수 있기 때문에 응용 서비스에 대한 인터페이스가 없어도 문제 없다.</ul><h2 id="메서드-파라미터와-값-리턴">메서드 파라미터와 값 리턴</h2><ul><li>응용 서비스에서 애그리거트 자체를 리턴하면 코딩은 편할 수 잇찌만 도메인의 로직 실행을 응용 서비스와 표현 영역 두 곳에서 할 수 있게 된다.<li>이는 기능 실행 로직을 응용 서비스와 표현 영역에 분산시켜 코드의 응집도를 낮추는 원인이 된다.<li>물론 팀 내 컨벤션으로 응용 서비스가 애그리거트를 리턴할 경우 해당 애그리거트의 기능을 컨트롤러나 뷰 코드에서 실행하지 않도록 규정할 수도 있다.<li>하지만, 그보다는 응용 서비스는 표현 영역에서 필요한 데이터만 리턴하는 것이 기능 실행 로직의 응집도를 높이는 확실한 방법이다.</ul><h2 id="표현-영역에-의존하지-않기">표현 영역에 의존하지 않기</h2><ul><li>응용 서비스의 파라미터 타입을 결정할 때 주의할 점은 표현 영역과 관련된 타입을 사용하면 안된다는 점이다.<ul><li>ex. <code class="language-plaintext highlighter-rouge">HttpServletRequest</code>, <code class="language-plaintext highlighter-rouge">HttpSession</code> 등</ul><li>표현 영역에 의존하지 않기 이렇게 했을 때 아래와 같은 문제점이 발생한다.</ul><h3 id="1-응용-서비스만-단독으로-테스트하기-어려워짐">1) 응용 서비스만 단독으로 테스트하기 어려워짐</h3><h3 id="2-표현-영역의-구현-변경시-응용-서비스의-구현도-함께-변경해줘야됨">2) 표현 영역의 구현 변경시 응용 서비스의 구현도 함께 변경해줘야됨</h3><h3 id="3-응용-서비스가-표현-영역의-역할까지-대신하는-상황이-벌어질-수도-있다">3) 응용 서비스가 표현 영역의 역할까지 대신하는 상황이 벌어질 수도 있다.</h3><ul><li>예를 들어, 응용 서비스에 파라미터로 HttpServletRequest를 전달했는데 응용 서비스에 HttpSession 을 생성 후 세션에 인증 관련 정보를 담는다 해보자.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AuthenticationService</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">authenticate</span><span class="o">(</span><span class="nc">HttpServletRequest</span> <span class="n">request</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">String</span> <span class="n">id</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getParamter</span><span class="o">(</span><span class="s">"id"</span><span class="o">);</span>
    <span class="nc">String</span> <span class="n">password</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getParameter</span><span class="o">(</span><span class="s">"password"</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">checkIdPasswordMatching</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">password</span><span class="o">))</span> <span class="o">{</span>
      <span class="c1">// 응용 서비스에서 표현 영역의 상태 처리</span>
      <span class="nc">HttpSession</span> <span class="n">session</span> <span class="o">=</span> <span class="n">request</span><span class="o">.</span><span class="na">getSession</span><span class="o">();</span>
      <span class="n">session</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">"auth"</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Authentication</span><span class="o">(</span><span class="n">id</span><span class="o">));</span>
    <span class="o">}</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>HttpSession 이나 쿠키는 표현 영역의 상태에 해당하는데 이 상태를 응용 서비스에서 변경해 버리면 표현 영역의 코드만으로 표현 영역의 상태가 어떻게 변경되는지 이해하기 어려워진다.<ul><li>즉, 표현 영역의 응집도가 깨지는 것이다. 이는 결과적으로 코드 유지보수 비용을 증가시키는 원인이 된다.</ul><li>앞서 언급한 문제가 발생되지 않도록 하는 가장 쉬운 방법은 서비스 메서드의 파라미터와 리턴 타입으로 표현 영역의 구현 기술을 사용하지 않는 것이다.</ul><h2 id="트랜잭션-처리">트랜잭션 처리</h2><ul><li>프레임워크가 제공하는 트랜잭션 기능을 적극 사용하는 것이 좋다. 스프링의 <code class="language-plaintext highlighter-rouge">@Transactional</code> 은 RuntimeException 이 발생하면 롤백시켜버리고 그렇지 않으면 커밋을 자동으로 하게 된다.</ul><h2 id="도메인-이벤트-처리">도메인 이벤트 처리</h2><ul><li>응용 서비스의 역할 중 하나는 도메인 영역에서 발생한 이벤트를 처리하는 것이다.<li>여기서 이벤트는 도메인에서 발생한 상태 변경을 의미하며 ‘암호 변경됨’, ‘주문 취소함’ 과 같은 것이 이벤트가 될 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Member</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">Password</span> <span class="n">password</span><span class="o">;</span>
	
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">initializePassword</span><span class="o">()</span> <span class="o">{</span>
		<span class="nc">String</span> <span class="n">newPassword</span> <span class="o">=</span> <span class="n">generateRandomPassword</span><span class="o">();</span>
		<span class="k">this</span><span class="o">.</span><span class="na">password</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Password</span><span class="o">(</span><span class="n">newPassword</span><span class="o">);</span>
		<span class="nc">Events</span><span class="o">.</span><span class="na">raise</span><span class="o">(</span><span class="k">new</span> <span class="nc">PasswordChangedEvent</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">id</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span> <span class="c1">// 도메인 이벤트 발생!!</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>도메인에서 이벤트를 발생시키면 그 이벤트를 받아서 처리할 코드가 필요한데, 그 역할을 하는 것이 바로 응용 서비스다.<li>암호 초기화의 경우 암호 초기화됨 이벤트가 발생하면 변경한 암호를 이메일로 발송하는 이벤트 핸들러를 등록할 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">InitPasswordService</span> <span class="o">{</span>
  
  <span class="nd">@Transactional</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">initializePassword</span><span class="o">(</span><span class="nc">String</span> <span class="n">memberId</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Events</span><span class="o">.</span><span class="na">handle</span><span class="o">((</span><span class="nc">PasswordChangeEvent</span> <span class="n">evt</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
      <span class="c1">// evt.getid()에 해당하는 회원에게 이메일 발송하는 기능 구현</span>
    <span class="o">});</span>
    
    <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">memberId</span><span class="o">);</span>
    <span class="n">checkMemberExists</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
    <span class="n">member</span><span class="o">.</span><span class="na">initializePassword</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>위 이벤트 처리 코드를 보고 왜 다음과 같이 코드를 작성해도 되는데 다소 복잡해 보이는 이벤트를 사용했는지 궁금할 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nd">@Transactional</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">initializePassword</span><span class="o">(</span><span class="nc">String</span> <span class="n">memberId</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">memberId</span><span class="o">);</span>
  <span class="n">checkMemberExists</span><span class="o">(</span><span class="n">member</span><span class="o">);</span>
  <span class="n">member</span><span class="o">.</span><span class="na">initializePassword</span><span class="o">();</span> <span class="c1">// 이벤트 발생하지 않음</span>
  <span class="n">sendNewpasswordMailToMember</span><span class="o">(</span><span class="n">member</span><span class="o">);</span> <span class="c1">// 실행 안돼야 함</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li><b>이벤트를 사용하면 코드가 다소 복잡해지는 대신 도메인 간의 의존성이나 외부 시스템에 대한 의존을 낮춰주는 장점을 얻을 수 있다.</b><li>또한 시스템을 확장하는 데에 이벤트가 핵심 역할을 수행하게 된다.<li>이런 이유로 이벤트를 사용하는데, 이에 대한 자세한 내용은 이벤트를 다루는 10장과 CQRS 에 대해 다루는 11장에서 살펴볼 예정이다.</ul><h2 id="표현-영역-1">표현 영역</h2><ul><li>표현 영역의 책임은 크게 다음과 같다.<ul><li>1)사용자가 시스템을 사용할 수 있는 (화면)흐름을 제공하고 제어한다.<li>2)사용자의 요청에 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공한다.<li>3)사용자의 세션을 관리 (웹의 경우 쿠키나 서버 세션을 이용해 사용자의 연결 상태를 관리)</ul></ul><h2 id="값-검증">값 검증</h2><ul><li>값 검증은 표현 영역과 응용 서비스 두 곳에서 모두 수행 가능하다.<li>원칙적으로 모든 값에 대한 검증은 응용 서비스에서 처리한다.<li>예를 들어, 회원 가입을 처리하는 응용 서비스는 다음과 같이 파라미터로 전달받은 값이 올바른지 검사해야 한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">JoinService</span> <span class="o">{</span>
  <span class="nd">@Transactional</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">join</span><span class="o">(</span><span class="nc">JoinRequest</span> <span class="n">joinReq</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">checkEmpty</span><span class="o">(</span><span class="n">joinRequest</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="s">"id"</span><span class="o">);</span>
		<span class="n">checkEmpty</span><span class="o">(</span><span class="n">joinRequest</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="s">"name"</span><span class="o">);</span>
    <span class="n">checkPassword</span><span class="o">(</span><span class="n">joinRequest</span><span class="o">.</span><span class="na">getPassword</span><span class="o">(),</span> <span class="s">"password"</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">joinReq</span><span class="o">.</span><span class="na">getPassword</span><span class="o">().</span><span class="na">equals</span><span class="o">(</span><span class="n">joinReq</span><span class="o">.</span><span class="na">getConfirmPassword</span><span class="o">()))</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">InvalidPropertyException</span><span class="o">(</span><span class="s">"confirmPassword"</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="c1">// 로직 검사</span>
    <span class="n">checkDuplicatedId</span><span class="o">(</span><span class="n">joinReq</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
    <span class="o">...</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">checkEmpty</span><span class="o">(</span><span class="nc">String</span> <span class="n">value</span><span class="o">,</span> <span class="nc">String</span> <span class="n">propertyName</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span><span class="o">(</span><span class="n">value</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">value</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">EmptyPropertyException</span><span class="o">(</span><span class="n">propertyName</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">checkDuplicateId</span><span class="o">(</span><span class="nc">String</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">.</span><span class="na">countsById</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">DuplicatedIdexception</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>그런데 표현 영역은 잘못된 값이 존재하면 이를 사용자에게 알려주고 값을 다시 입력받아야 한다.<li>스프링 MVC의 경우 폼에 입력한 값이 잘못된 경우 에러 메시지를 보여주기 위한 용도로 Errors 나 BindingResult를 사용하는데, 스프링 MVC의 컨트롤러에서 위와 같은 응용 서비스를 사용하면 폼에 에러 메시지를 보여주기 위해 다음과 같이 다소 번잡한 코드를 작성해야 한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Controller</span> <span class="o">{</span>

  <span class="nd">@RequestMapping</span>
  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">join</span><span class="o">(</span><span class="nc">JoinReuqest</span> <span class="n">joinRequest</span><span class="o">,</span> <span class="nc">Errors</span> <span class="n">erros</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">joinService</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="n">joinRequest</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">successView</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">EmptyPropertyException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// 표현 영역은 잘못 입력한 값이 존재하면 이를 사용자에게 알려주고</span>
      <span class="c1">// 폼을 다시 입력할 수 있도록 하려면, 관련 기능을 사용해야 한다.</span>
      <span class="n">errors</span><span class="o">.</span><span class="na">rejectValue</span><span class="o">(</span><span class="n">ex</span><span class="o">.</span><span class="na">getPropertyName</span><span class="o">(),</span> <span class="s">"empty"</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">formView</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">InvalidPropertyException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">errors</span><span class="o">.</span><span class="na">rejectValue</span><span class="o">(</span><span class="n">ex</span><span class="o">.</span><span class="na">getPropertyName</span><span class="o">(),</span> <span class="s">"invalid"</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">formView</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">DuplicateIdException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">errors</span><span class="o">.</span><span class="na">rejectValue</span><span class="o">(</span><span class="n">ex</span><span class="o">.</span><span class="na">getPropertyName</span><span class="o">(),</span> <span class="s">"duplicate"</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">formView</span><span class="o">;</span>
    <span class="o">}</span>

  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>응용 서비스에서 각 값이 존재하는지 형식이 올바른지 확인할 목적으로 익셉션을 사용할 때의 문제점은 사용자에게 좋지 않은 경험을 제공한다는 것이다.<ul><li>사용자는 폼에 값을 입력 후 전송했는데 입력한 값이 잘못되어 다시 폼에 입력해야 할 때 한 개 항목이 아닌 모든 항목에 대해 잘못된 값이 존재하는지 알고 싶을 것이다.<li>그래야 한 번에 잘못된 값을 제대로 입력할 수 있기 때문이다.</ul><li>그런데, 응용 서비스에서 값을 검사하는 시점에 첫 번째 값이 올바르지 않아 익셉션을 발생시키면 나머지 항목에 대해서는 값을 검사하지 않게 된다.<li>이러면 사용자는 첫번쨰 값에 대한 에러 메시지만 보게 되고 나머지 항목에 대해선 값이 올바른지 여부를 알 수 없게 된다. 이는 사용자가 같은 폼에 값을 여러 번 입력하게 만든다.<li>이런 사용자 불편을 해소하려면 다음과 같이 응용 서비스에 값을 전달하기 전에 표현 영역에서 값을 검사하면 된다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Controller</span> <span class="o">{</span>
	<span class="nd">@RequestMapping</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">join</span><span class="o">(</span><span class="nc">JoinRequest</span> <span class="n">joinRequest</span><span class="o">,</span> <span class="nc">Errors</span> <span class="n">errors</span><span class="o">)</span> <span class="o">{</span>
		<span class="n">checkEmpty</span><span class="o">(</span><span class="n">joinRequest</span><span class="o">.</span><span class="na">getId</span><span class="o">(),</span> <span class="s">"id"</span><span class="o">,</span> <span class="n">errors</span><span class="o">);</span>
		<span class="n">checkEmpty</span><span class="o">(</span><span class="n">joinRequest</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="s">"name"</span><span class="o">,</span> <span class="n">errors</span><span class="o">);</span>
		<span class="o">...</span> <span class="c1">// 나머지 값 검증</span>

		<span class="c1">// 모든 값의 형식을 검증한 뒤,  에러가 존재하면 다시 폼을 보여줌</span>
		<span class="k">if</span><span class="o">(</span><span class="n">errors</span><span class="o">.</span><span class="na">hasErrors</span><span class="o">())</span> <span class="k">return</span> <span class="n">formView</span><span class="o">;</span>

		<span class="k">try</span> <span class="o">{</span>
      <span class="n">joinService</span><span class="o">.</span><span class="na">join</span><span class="o">(</span><span class="n">joinRequest</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">successView</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">DuplicateIdException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
      <span class="n">erros</span><span class="o">.</span><span class="na">rejectValue</span><span class="o">(</span><span class="n">ex</span><span class="o">.</span><span class="na">getPropertyName</span><span class="o">(),</span> <span class="s">"duplicate"</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">formView</span><span class="o">;</span>
    <span class="o">}</span>
	<span class="o">}</span>

	<span class="kd">private</span> <span class="kt">void</span> <span class="nf">checkEmpty</span><span class="o">(</span><span class="nc">String</span> <span class="n">value</span><span class="o">,</span> <span class="nc">String</span> <span class="n">property</span><span class="o">,</span> <span class="nc">Errors</span> <span class="n">errors</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">if</span><span class="o">(</span><span class="n">isEmpty</span><span class="o">(</span><span class="n">value</span><span class="o">))</span> <span class="n">erros</span><span class="o">.</span><span class="na">rejectValue</span><span class="o">(</span><span class="n">property</span><span class="o">,</span> <span class="s">"empty"</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>스프링에서 제공하는 Validator 인터페이스를 구현한 검증기를 따로 구현하면 위 코드를 더 간결하게 줄일 수 있다.<li>표현 영역에서 필수 값과 값의 형식을 검사하면 실질적으로 응용 서비스는 논리적 오류만 검사하면 된다.<ul><li>표현 영역: 필수 값과 값의 형식, 범위 등을 검증<li>응용 서비스: 데이터의 존재 유무와 같은 논리적 오류를 검증</ul><li>엄격하게 두 영역에서 모두 값검사를 하고 싶다면 동일한 검증기를 사용해서 검증 코드를 줄일 수 있다.</ul><blockquote><p><strong>Note</strong>: 저자의 경험상 응용 서비스를 실행하는 주체가 표현 영역이면 응용 서비스는 논리적 오류 위주로 값을 검증해도 문제가 없었지만 응용 서비스를 실행하는 주체가 다양하면 응용 서비스에서 반드시 파라미터로 전달받은 값이 올바른지 검사를 해야 한다.</p></blockquote><h2 id="권한-검사">권한 검사</h2><ul><li>권한을 검사하기 위해 스프링 시큐리티나 아파치 Shiro 같은 프레임워크는 유연하고 확장 가능한 구조를 가진다.<li>보안 프레임워크의 복잡도를 떠나 보통 다음 세 곳에서 권한 검사를 수행할 수 있다.<ul><li>1)표현 영역<li>2)응용 서비스<li>3)도메인</ul><li>예를 들어, 회원 정보 변경을 처리하는 URL에 대해 표현 영역에서 다음과 같이 접근 제어를 할 수 있다.<ul><li>이 URL을 처리하는 컨트롤러에 웹 요청을 전달하기 전에 인증 여불르 검사해서 인증된 사용자의 요청만 컨트롤러에 전달한다.<li>인증된 사용자가 아닐 경우 로그인 화면으로 리다이렉트 시킨다.</ul><li>이런 접근 제어를 하기 좋은 위치가 서블릿 필터이다.<ul><li>서블릿 필터에서 사용자의 인증 정보를 생성 후 인증 여부를 검사하는 것이다.</ul><li>URL만으로 접근제어를 할 수 없는 경우 응용 서비스의 메서드 단위로 권한 검사를 수행해야 한다.<li>스프링 시큐리티는 AOP를 활용해서 다음과 같이 어노테이션으로 서비스 메서드에 대한 권한 검사를 할 수 있는 기능을 제공한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BlockMemberService</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">MemberRepository</span> <span class="n">memberRepository</span><span class="o">;</span>

	<span class="nd">@PreAuthorize</span><span class="o">(</span><span class="s">"hasRole('ADMIN')"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">block</span><span class="o">(</span><span class="nc">String</span> <span class="n">memberId</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="n">memberRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">memberId</span><span class="o">);</span>
		<span class="k">if</span> <span class="o">(</span><span class="n">member</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoMemberException</span><span class="o">();</span>
		<span class="n">member</span><span class="o">.</span><span class="na">block</span><span class="o">();</span>
		<span class="o">...</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>개별 도메인 단위로 권한 검사를 해야 하는 경우는 응용 서비스의 메서드 수준에서 권한 검사를 할 수 없기 때문에 다음과 같이 직접 권한 검사 로직을 구현해줘야 한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DeleteArticleService</span> <span class="o">{</span>

	<span class="kd">public</span> <span class="kt">void</span> <span class="nf">delete</span><span class="o">(</span><span class="nc">String</span> <span class="n">userId</span><span class="o">,</span> <span class="nc">Long</span> <span class="n">articleId</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">Article</span> <span class="n">article</span> <span class="o">=</span> <span class="n">articleRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">articleId</span><span class="o">);</span>
		<span class="n">checkArticleExistence</span><span class="o">(</span><span class="n">article</span><span class="o">);</span>
		<span class="n">permissionService</span><span class="o">.</span><span class="na">checkDeletePermission</span><span class="o">(</span><span class="n">userId</span><span class="o">,</span> <span class="n">article</span><span class="o">);</span>
		<span class="n">article</span><span class="o">.</span><span class="na">markDeleted</span><span class="o">();</span>
	<span class="o">}</span>
	
  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>스프링 시큐리티와 같은 보안 프레임워크를 확장해서 개별 도메인 객체 수준의 권한 검사 기능을 프레임워크에 통합 할 수도 있을 것이다.<ul><li><b>하지만, 이해가 높지 않아 프레임워크 확장을 우너하는 수준으로 할 수 없다면 프레임워크를 사용하는 대신 도메인에 맞는 권한 검사 기능을 구현하는 것이 코드 유지보수에 유리할 수 있다.</b></ul></ul><h2 id="조회-전용-기능과-응용-서비스">조회 전용 기능과 응용 서비스</h2><ul><li>서비스 코드가 다음과 같이 단순한 조회 전용 기능을 호출하는 것으로 끝나는 경우가 많다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderListService</span> <span class="o">{</span>
	<span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderView</span><span class="o">&gt;</span> <span class="nf">getOrderList</span><span class="o">(</span><span class="nc">String</span> <span class="n">ordererId</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">orderViewDao</span><span class="o">.</span><span class="na">selectByOrderer</span><span class="o">(</span><span class="n">ordererId</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>이런 경우라면 굳이 서비스를 만들 필요 없이 표현 영역에서 바로 조회 전용 기능을 사용해도 된다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderController</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">OrderViewDao</span> <span class="n">orderViewDao</span><span class="o">;</span>

	<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/myorders"</span><span class="o">)</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">list</span><span class="o">(</span><span class="nc">ModelMap</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
		<span class="nc">String</span> <span class="n">ordererId</span> <span class="o">=</span> <span class="nc">SecurityContext</span><span class="o">.</span><span class="na">getAuthentication</span><span class="o">().</span><span class="na">getId</span><span class="o">();</span>
		<span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderView</span><span class="o">&gt;</span> <span class="n">orders</span> <span class="o">=</span> <span class="n">orderViewDao</span><span class="o">.</span><span class="na">selectByOrderer</span><span class="o">(</span><span class="n">ordererId</span><span class="o">);</span>
		<span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"orders"</span><span class="o">,</span> <span class="n">orders</span><span class="o">);</span>
		<span class="k">return</span> <span class="s">"order/list"</span><span class="o">;</span>
	<span class="o">}</span>
  
  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="reference-3">Reference</h2><ul><li>예제 코드 및 이미지<ul><li><a href="https://heeveloper.github.io/2020/07/22/06-%EC%9D%91%EC%9A%A9-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%99%80-%ED%91%9C%ED%98%84-%EC%98%81%EC%97%AD/">https://heeveloper.github.io/2020/07/22/06-%EC%9D%91%EC%9A%A9-%EC%84%9C%EB%B9%84%EC%8A%A4%EC%99%80-%ED%91%9C%ED%98%84-%EC%98%81%EC%97%AD/</a></ul></ul><h1 id="chapter7-도메인-서비스">Chapter7-도메인 서비스</h1><h2 id="여러-애그리거트가-필요한-기능도메인-서비스가-필요한-이유">여러 애그리거트가 필요한 기능(도메인 서비스가 필요한 이유)</h2><ul><li>도메인 영여그이 코드를 작성하다보면 한 애그리거트로 기능을 구현할 수 없을 때가 있다.<ul><li>대표적인 예가, 결제 금액 계산 로직인데 아래와 같은 사항들을 고려볼 수 있다.<li><code class="language-plaintext highlighter-rouge">상품 애그리거트</code> : 구매하는 상품의 가격. 또는 상품에 따라 추가되는 배송비<li><code class="language-plaintext highlighter-rouge">주문 애그리거트</code> : 상품별 구매 개수<li><code class="language-plaintext highlighter-rouge">할인 쿠폰 애그리거트</code> : 쿠폰별 지정된 할인 금액, 비율과 중복 사용 여부 등의 조건<li><code class="language-plaintext highlighter-rouge">회원 애그리거트</code> : 회원 등급에 따른 추가 할인</ul><li>이런 경우 실제 결제 금액을 계산해야 하는 주체는 어떤 애그리거트일까?<li>총 주문 금액을 계산하는 것은 주문 애그리거트가 할 수 있지만 실제 결제 금액은 이야기가 다르다. 총 주문 금액에서 할인 금액을 계산해야 한다.<li>그렇다고 할인 쿠폰 규칙을 갖고 있는 할인 쿠폰 애그리거트에서 계산한다면 할인 쿠폰을 두 개 이상 적용할 때 단일 할인 쿠폰 애그리거트로는 총 결제 금액을 계산할 수 없다.<li>생각해 볼 수 있는 방법은 주문 애그리거트가 필요한 애그리거트나 필요 데이터를 모두 가지도록 한 뒤 할인 금액 계산 책임을 주문 애그리거트에 할당하는 것이다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="kd">private</span> <span class="nc">Orderer</span> <span class="n">orderer</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderLine</span><span class="o">&gt;</span> <span class="n">orderLines</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Coupon</span><span class="o">&gt;</span> <span class="n">usedCoupons</span><span class="o">;</span>
  
  <span class="kd">private</span> <span class="nc">Money</span> <span class="nf">calculatePayAmounts</span><span class="o">()</span> <span class="o">{</span>
    <span class="c1">// 총 지불 금액 계산 로직</span>
    <span class="o">...</span>
  <span class="o">}</span>
  
  <span class="kd">private</span> <span class="nc">Money</span> <span class="nf">calculateDiscount</span><span class="o">(</span><span class="nc">Coupon</span> <span class="n">coupon</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 쿠폰에 따른 할인 금액 계산 로직</span>
    <span class="o">...</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="nc">Money</span> <span class="nf">calculateDiscount</span><span class="o">(</span><span class="nc">MemberGrade</span> <span class="n">grade</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 회원 등급에 따른 할인 금액 계산 로직</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li><b>여기서 고민거리는 결제 금액 계산 로직이 주문 애그리거트의 책임이 맞느냐에 대한 것이다.</b><li>예를 들어, 특별 감사 세일로 전 품목에 한 달간 5% 추가 할인을 하기로 했을 때, 이 할인 정책은 주문 애그리거트의 구성요소와는 관련이 없음에도 불구하고 결제 금액 계산 책임이 주문 애그리거트에 있다는 이유로 주문 애그리거트 코드를 수정해야 한다.<li>이렇게 한 애그리거트에 넣기 애매한 도메인 기능을 특정 애그리거트에서 억지로 구현하면 안된다.<li><b>이 경우 애그리거트는 자신의 책임 범위를 넘어서는 기능을 구현하기 때문에 코드가 길어지고 외부에 대한 의존이 높아지게 된다.</b><ul><li><b>이는 코드를 복잡하게 만들어 수정을 어렵게 만드는 요인이 되며 게다가 애그리거트의 범위를 넘어서는 도메인 개념이 애그리거트에 숨어들어서 명시적으로 드러나지 않게 된다.</b></ul><li>이때 가장 쉬운 해결책이 <code class="language-plaintext highlighter-rouge">도메인 서비스</code> 를별도로 구현하는 것이다.</ul><h2 id="도메인-서비스">도메인 서비스</h2><ul><li>응용 서비스가 응용 로직을 다룬다면 도메인 서비스는 도메인 로직을 다룬다.<li>도메인 서비스가 도메인 영역의 애그리거트나 밸류와 같은 다른 구성요소와 비교할 때 다른 점이 있다면 상태 없이 로직만 구현한다는 점이다.<li><code class="language-plaintext highlighter-rouge">할인 금액 계산</code> 로직을 위한 도메인 서비스는 다음과 같이 도메인의 의미가 드러나는 용어를 타입과 메서드 이름으로 짓는다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DiscountCalculationService</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="nc">Money</span> <span class="nf">calculateDiscountAmounts</span><span class="o">(</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderLIne</span><span class="o">&gt;</span> <span class="n">orderLines</span><span class="o">,</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Coupon</span><span class="o">&gt;</span> <span class="n">coupons</span><span class="o">,</span>
    <span class="nc">MemberGrade</span> <span class="n">grade</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Money</span> <span class="n">couponDiscount</span> <span class="o">=</span> <span class="n">coupons</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                    <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">coupon</span> <span class="o">-&gt;</span> <span class="n">calculateDiscount</span><span class="o">(</span><span class="n">coupon</span><span class="o">))</span>
                    <span class="o">.</span><span class="na">reduce</span><span class="o">(</span><span class="nc">Money</span><span class="o">(</span><span class="mi">0</span><span class="o">),</span> <span class="o">(</span><span class="n">v1</span><span class="o">,</span> <span class="n">v2</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="n">v1</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">v2</span><span class="o">));</span>

    <span class="nc">Money</span> <span class="n">membershipDiscount</span> <span class="o">=</span> <span class="n">calculateDiscount</span><span class="o">(</span><span class="n">orderer</span><span class="o">.</span><span class="na">getMember</span><span class="o">().</span><span class="na">getGrade</span><span class="o">());</span>

    <span class="k">return</span> <span class="n">couponDiscount</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="n">membershipDiscount</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="nc">Money</span> <span class="nf">calculateDiscount</span><span class="o">(</span><span class="nc">Coupon</span> <span class="n">coupon</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="nc">Money</span> <span class="nf">calculateDiscount</span><span class="o">(</span><span class="nc">MemberGrade</span> <span class="n">grade</span><span class="o">)</span> <span class="o">{</span>
    <span class="o">...</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>할인 계산 서비스를 사용하는 주체는 애그리거트가 될 수도 있고 응용 서비스가 될 수도 있다.<li>위 도메인 서비스를 주문 애그리거트에 전달하면 다음과 같은 형태가 된다. 이 경우 사용하는 주체는 애그리거트가 된다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kt">void</span> <span class="nf">calculateAmounts</span><span class="o">(</span>
   <span class="nc">DiscountCalculationService</span> <span class="n">disCalSvc</span><span class="o">,</span> <span class="nc">MemberGrade</span> <span class="n">grade</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Money</span> <span class="n">totalAmounts</span> <span class="o">=</span> <span class="n">getTotalAmounts</span><span class="o">();</span>
  <span class="nc">Money</span> <span class="n">discountAmounts</span> <span class="o">=</span> <span class="n">disCalSvc</span><span class="o">.</span><span class="na">calculateDiscountAmounts</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">orderLInes</span><span class="o">,</span> <span class="k">this</span><span class="o">.</span><span class="na">coupons</span><span class="o">,</span> <span class="n">greade</span><span class="o">);</span>
  <span class="k">this</span><span class="o">.</span><span class="na">paymentAmounts</span> <span class="o">=</span> <span class="n">totalAmounts</span><span class="o">.</span><span class="na">minus</span><span class="o">(</span><span class="n">discountAmounts</span><span class="o">);</span>
 <span class="o">}</span>
 <span class="o">...</span>
</pre></table></code></div></div><ul><li>애그리거트 객체에 도메인 서비스를 전달하는 것은 응용 서비스의 책임이다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderService</span> <span class="o">{</span>
 <span class="kd">private</span> <span class="nc">DiscountCalculationService</span> <span class="n">discountCalculationService</span><span class="o">;</span>

 <span class="nd">@Transactional</span>
 <span class="kd">public</span> <span class="nc">OrderNo</span> <span class="nf">placeOrder</span><span class="o">(</span><span class="nc">OrderRequest</span> <span class="n">orderRequest</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">OrderNo</span> <span class="n">orderno</span> <span class="o">=</span> <span class="n">orderRepository</span><span class="o">.</span><span class="na">nextId</span><span class="o">();</span>
  <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">createOrder</span><span class="o">(</span><span class="n">orderNo</span><span class="o">,</span> <span class="n">orderRequest</span><span class="o">);</span>
  <span class="n">orderRepository</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
  <span class="c1">// 응용 서비스 실행 후 표현 영역에서 필요한 값 리턴</span>

  <span class="k">return</span> <span class="n">orderNo</span><span class="o">;</span>
 <span class="o">}</span>

 <span class="kd">private</span> <span class="nc">Order</span> <span class="nf">createOrder</span><span class="o">(</span><span class="nc">OrderNo</span> <span class="n">orderNo</span><span class="o">,</span> <span class="nc">OrderRequest</span> <span class="n">orderReq</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span><span class="n">findMember</span><span class="o">(</span><span class="n">orderReq</span><span class="o">.</span><span class="na">getOrdererId</span><span class="o">());</span>
  <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Order</span><span class="o">(</span><span class="n">orderNo</span><span class="o">,</span> <span class="n">orderReq</span><span class="o">.</span><span class="na">gerOrderLines</span><span class="o">(),</span>
       <span class="n">orderReq</span><span class="o">.</span><span class="na">getCoupons</span><span class="o">(),</span> <span class="n">createOrderer</span><span class="o">(</span><span class="n">member</span><span class="o">),</span>
       <span class="n">orderReq</span><span class="o">.</span><span class="na">getShippingInfo</span><span class="o">());</span>
  <span class="n">order</span><span class="o">.</span><span class="na">calculateAmounts</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">discountCalculationService</span><span class="o">,</span> <span class="n">member</span><span class="o">.</span><span class="na">getGrade</span><span class="o">());</span>
  <span class="k">return</span> <span class="n">order</span><span class="o">;</span>
 <span class="o">}</span>
 <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>위와 반대로 도메인 서비스의 기능을 실행할 떄 애그리거트를 전달하기도 한다.<ul><li>이런식으로 동작하는 것중 하나가 <code class="language-plaintext highlighter-rouge">계좌 이체 기능</code> 이다.<li>계좌 이체의 경우 두 계좌 애그리거트가 관여하는데 한 애그리거트는 금액을 출금하고 한 애그리거트는 금액을 입금한다.<li>이를 위한 도메인 서비스는 다음과 같이 구현할 수 있을 것이다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">TransferService</span> <span class="o">{</span>
 <span class="kd">public</span> <span class="kt">void</span> <span class="nf">transfer</span><span class="o">(</span><span class="nc">Account</span> <span class="n">fromAcc</span><span class="o">,</span> <span class="nc">Account</span> <span class="n">toAcc</span><span class="o">,</span> <span class="nc">Money</span> <span class="n">amounts</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">fromAcc</span><span class="o">.</span><span class="na">withdraw</span><span class="o">(</span><span class="n">amounts</span><span class="o">);</span>
  <span class="n">toAcc</span><span class="o">.</span><span class="na">credit</span><span class="o">(</span><span class="n">amounts</span><span class="o">);</span>
 <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>응용 서비스는 두 Account 애그리거트를 구한 뒤에 해당 도메인 영역의 Transfer-Service를 이용해 계좌 이체 도메인의 기능을 실행할 것이다.<li>도메인 서비스는 도메인 로직을 수행하지 응용 로직을 수행하지는 않는다.<ul><li><b>트랜잭션 처리와 같은 로직은 응용로직이므로 도메인 서비스가 아닌 응용 서비스에서 처리한다.</b></ul></ul><h3 id="도메인-서비스-객체를-애그리거트에-주입하지-않기저자-개인-생각">도메인 서비스 객체를 애그리거트에 주입하지 않기(저자 개인 생각)</h3><ul><li>애그리거트의 메서드를 실행할 때 도메인 서비스 객체를 파라미터로 전달한다는 것은 애그리거트가 도메인 서비스에 의존한다는 것을 뜻한다.<li>스프링의 DI 와 AOP를 공부하다 보면 애그리거트가 의존하는 도메인 서비스를 의존 주입으로 처리하고 싶어질 수 있는데 이는 저자 개인적으로 좋은 방법이 아니라 생각한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
  <span class="nd">@Autowired</span>
  <span class="kd">private</span> <span class="nc">DiscountCalculationService</span> <span class="n">discountCalculationService</span><span class="o">;</span>
  
  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>도메인 모델의 데이터를 담는 필드는 모델에서 중요한 구성요소이다.<li>그런데, discountCalculationSErvice 필드는 데이터 자체와는 관련이 없으며 Order 객체를 DB 에 보관할 때 다른 필드와는 달리 저장 대상도 아니다.<li>또 Order가 제공하는 모든 기능에서 discountCalculationService 를 필요로 하는 것도 아니다. 일부 기능만 필요로 한다.<li>일부 기능을 위해 굳이 도메인 서비스 객체를 애그리거트에 의존 주입할 이유는 없다.<li>이는 프레임워크의 기능을 사용하고 싶은 개발자의 욕심을 채우는 것에 불과하다.</ul><blockquote><p><strong>Note</strong>: 특정 기능이 응용 서비스인지 도메인 서비스인지 감을 잡기 어려울땐 해당 로직이 애그리거트의 상태를 변경하거나 애그리거트의 상태 값을 계산하는지 검사해보면 된다. 예를 들어, 계좌 이체 로직은 계좌 애그리거트의 상태를 변경한다. 결제 금액 로직은 주문 애그리거트의 주문 금액을 계산한다. 이 두 로직은 각각 애그리거트를 변경하고 애그리거트의 값을 계산하는 도메인 로직이다. 도메인 로직이면서 한 애그리거트에 넣기 적합하지 않으므로 이 두 로직은 도메인 서비스로 구현하게 된다.</p></blockquote><h2 id="도메인-서비스의-패키지-위치">도메인 서비스의 패키지 위치</h2><ul><li>도메인 서비스는 도메인 로직을 실행하므로 도메인 서비스의 위치는 다른 도메인 구성요소와 동일한 패키지에 위치한다.<li>예를 들어, 주문 금액 계산을 위한 도메인 서비스는 아래 이미지와 같이 주문 애그리거트와 동일 패키지에 위치한다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/00968ef3-3cd5-4224-9941-a1e12e4638f0" alt="image" /></p><ul><li><b>도메인 서비스의 개수가 많거나 엔티티나 밸류와 같은 다른 구성요소와 명시적으로 구분하고 싶다면 domain 패키지 밑에 domain.moel, domain.service, domain.repository 와 같이 하위 패키지를 구분해서 위치시켜도 된다.</b></ul><h2 id="도메인-서비스의-인터페이스와-클래스">도메인 서비스의 인터페이스와 클래스</h2><ul><li>도메인 서비스의 로직이 고정되어 있지 않은 경우 도메인 서비스 자체를 인터페이스로 구현하고 이를 구현한 클래스를 둘 수도 있따.<li>특히 도메인 로직을 외부 시스템이나 별도 엔진을 이용해서 구현해야 할 경우에 인터페이스와 클래스를 분리하게 된다.<li>예를 들어, 할인 금액 계산 로직을 룰 엔진을 이용해서 구현한다면 아래 이미지와 같이 도메인 영역에는 도메인 서비스 인터페이스가 위치하고 실제 구현은 인프라스트럭처 영역에 위치시킬 수 있다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/f6da2628-4ac6-4666-98bb-45c82946dc91" alt="image" /></p><ul><li><b>위 이미지와 같이 도메인 서비스의 구현이 특정 구현 기술에 의존적이거나 외부 시스템의 API를 실행한다면 도메인 영역의 도메인 서비스는 인터페이스로 추상화해야 한다.</b><li>이를 통해 도메인 영역이 특정 구현에 종속되는 것을 방지할 수 있고 도메인 영역에 대한 테스트가 수월해진다.</ul><h2 id="reference-4">Reference</h2><ul><li>예제 코드 및 이미지<ul><li><a href="https://heeveloper.github.io/2020/08/27/07-%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%84%9C%EB%B9%84%EC%8A%A4/">https://heeveloper.github.io/2020/08/27/07-%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%84%9C%EB%B9%84%EC%8A%A4/</a><li><a href="https://minkukjo.github.io/dev/2020/11/19/DDD-07/">https://minkukjo.github.io/dev/2020/11/19/DDD-07/</a></ul></ul><h1 id="chapter8-애그리거트-트랜잭션-관리">Chapter8-애그리거트 트랜잭션 관리</h1><h2 id="애그리거트와-트랜잭션">애그리거트와 트랜잭션</h2><ul><li>한 주문 애그리거트에 대해 운영자는 배송 상태로 변경할 때 사용자는 배송지 주소를 변경하면 어떻게 될까?<li>아래 이미지는 발생할 수 있는 다양한 경우 중 한 가지를 시간 순서로 표시한 것이다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/675abb4a-95fe-481e-ac2a-c5c320c35c5b" alt="image" /></p><ul><li>운영자 스레드와 고객 스레드는 개념적으로 동일한 애그리거트지만 물리적으로 서로 다른 애그리거트 객체를 사용한다.<li>때문에 운영자 스레드가 주문 애그리거트 객체를 배송 상태로 변경하더라도 고객 스레드가 사용하는 주문 애그리거트 객체엔 영향을 주지 않는다.<li>고객 스레드 입장에서 주문 애그리거트 객체는 아직 배송 상태 전이므로 배송지 정보를 변경 가능하다.<li>그렇기 때문에 애그리거트의 일관성이 깨지게 되는 것이다.<li>이런 문제가 발생하지 않도록 하려면 다음의 두 가지 중 하나를 해야 한다.<ul><li><b>1)운영자가 배송지 정보를 조회하고 상태를 변경하는 동안 고객이 애그리거트를 수정하지 못하게 막는다.</b><li><b>2)운영자가 배송지 정보를 조회한 이후에 고객이 정보를 변경하면 운영자가 애그리거트를 다시 조회한 뒤 수정하도록 한다.</b></ul><li>위 두 가지는 애그리거트 자체의 트랜잭션과 관련이 있다.<li>DBMS가 지원하는 트랜잭션과 함께 애그리거트를 위한 추가적인 트랜잭션 처리 기법이 필요하다.<li>애그리거트에 대해 사용할 수 있는 대표적인 트랜잭션 처리 방식에는 선점(Pessimistic) 잠금과 비선점(Optimistic) 자금의 두 가지 방식이 있는데 이어서 살펴보자.</ul><blockquote><p><strong>Note</strong>: Pessimistic Lock 과 Optimistic Lock을 비관적 잠금과 낙관적 잠금이라 많이 표현하는데 의미가 조금 더 가까운 선점 잠금과 비선점 잠금이란 용어를 저자는 사용하였다.</p></blockquote><h2 id="선점-잠금pessimistic-lock">선점 잠금(Pessimistic Lock)</h2><ul><li>선점 잠금은 애그리거트를 먼저 구한 스레드가 애그리거트 사용이 끝날 때까지 다른 스레드가 해당 애그리거트를 수정하는 것을 막는 방식이다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/76f05cfb-8a63-4183-b88e-979bf4c78ae1" alt="image" /></p><ul><li>스레드1이 선점 잠금 방식으로 애그리거트를 구한 후 스레드2는 스레드1인 애그리거트에 대한 잠금을 해제할 때 까지 블로킹된다.<li>이러한 선점 잠금을 사용하면, 한 스레드가 애그리거트를 구하고 수정하는 동안 다른 스레드가 수정할 수 없으므로 동시에 애그리거트를 수정할 때 발생하는 데이터 충돌 문제를 해소할 수 있다.<ul><li>앞서 배송지 정보 수정과 배송 상태 변경을 동시에 하는 문제에 선점 잠금을 적용하면 아래 이미지와 같이 동작한다.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/c57ad2f2-4e5d-4605-afa3-0338978db852" alt="image" /></p><ul><li>운영자 스레드가 먼저 선점 잠금 방식으로 주문 애그리거트를 구한 경우 운영자 스레드가 잠금을 해제할 때까지 고객 스레드는 대기 상태가 된다.<li>운영자 스레드가 배송 상태로 변경한 뒤 트랜잭션을 커밋하면 잠금을 해제한다.<li>잠금이 해제된 시점에 고객스레드가 구하는 주문 애그리거트는 운영자 스레드가 수정한 배송 상태의 주문 애그리거트이다.<li>배송 상태이므로 배송지 변경시 에러를 발생하고 트랜잭션은 실패하게 된다.<li>이 시점에 고객은 ‘이미 배송이 시작되어 배송지를 변경할 수 없습니다’ 와 같은 안내 문구를 보게 될 것이다.<li><b>선점 잠금은 보통 DBMS가 제공하는 행 단위 잠금을 사용해서 구현한다.</b><li><b>오라클을 비롯한 다수 DBMS가 for update 와 같은 쿼리를 사용해서 특정 레코드에 한 사용자만 접근할 수 있는 잠금 장치를 제공한다.</b><li>JPA의 EntityManager 는 LockModeType 을 인자로 받는 find() 메서드를 제공하는데, LockModeType.PESSIMISTIC_WRITE를 값으로 전달하면 해당 엔티티와 매핑된 테이블을 이용해서 선점 잠금 방식을 적용할 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">entityManager</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">orderNo</span><span class="o">,</span> <span class="nc">LockModeType</span><span class="o">.</span><span class="na">PESSIMISTIC_WRITE</span><span class="o">;</span>
</pre></table></code></div></div><ul><li>JPA 프로바이더와 DBMS에 따라 잠금 모드의 구현이 다른데, 하이버네이트의 경우 <code class="language-plaintext highlighter-rouge">PESSIMISTIC_WRITE</code>를 잠금 모드로 사용하면 <code class="language-plaintext highlighter-rouge">for update</code> 쿼리를 사용해서 선점 잠금을 구현한다.<li>스프링 데이터 JPA는 <code class="language-plaintext highlighter-rouge">@Lock</code> 어노테이션을 통해 잠금 모드를 지정한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">org.springframework.data.jpa.repository.Lock</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.persistence.LockModeType</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberRepository</span> <span class="kd">extends</span> <span class="nc">Repository</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">,</span> <span class="nc">MemberId</span><span class="o">&gt;</span> <span class="o">{</span>

  <span class="nd">@Lock</span><span class="o">(</span><span class="nc">LockModeType</span><span class="o">.</span><span class="na">PESSIMITIC_WRITE</span>
  <span class="nd">@Query</span><span class="o">(</span><span class="s">"select m from Member m where m.id = :id"</span><span class="o">)</span>
  <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findByIdForUpdate</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="s">"id"</span><span class="o">)</span> <span class="nc">MemberId</span> <span class="n">memberId</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="선점-잠금과-교착-상태">선점 잠금과 교착 상태</h2><ul><li>선점 잠금 기능을 사용할 땐 잠금 순서에 따른 교착 상태(deadlock)가 발생하지 않도록 주의해야 한다.<li>예를 들어, 다음과 같은 수서로 두 스레드가 잠금 시도를 한다 해보자.</ul><div class="language-text highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>1. 스레드1: A 애그리거트에 대한 선점 잠금 구함
2. 스레드2: B 애그리거트에 대한 선점 잠금 구함
3. 스레드1: B 애그리거트에 대한 선점 잠금 시도
4. 스레드2: A 애그리거트에 대한 선점 잠금 시도
</pre></table></code></div></div><ul><li>위 순서에 따르면 스레드1, 2 모두 영원히 B, A 애그리거트에 대한 선점 잠금을 구할 수 없다.<li>두 스레드는 상대방 스레드가 먼저 선점한 잠금을 구할수 없어 더 이상 다음 단계를 진행하지 못하게 되어 교착상태에 빠지게 된다.<li>선점 잠금에 따른 교착 상태는 상대적으로 사용자 수가 많을 때 발생할 가능성이 높고, 사용자수가 많아지면 교착 상태에 빠지는 스레드는 더 빠르게 증가한다.<li><b>이런 문제가 발생하지 않도록 하려면 잠금을 구할 때 최대 대기 시간을 지정해야 한다. JPA에서 선점 잠금을 시도할 떄 최대 대기 시간을 지정하려면 다음과 같이 힌트를 사용한다.</b></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nc">Map</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">,</span> <span class="nc">Object</span><span class="o">&gt;</span> <span class="n">hints</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">HashMap</span><span class="o">&lt;&gt;();</span>
<span class="n">hints</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="s">"javax.persistence.lock.timeout"</span><span class="o">,</span> <span class="mi">2000</span><span class="o">);</span>
<span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">entityManager</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">orderNo</span><span class="o">,</span> <span class="nc">LockModeType</span><span class="o">.</span><span class="na">PESSIMISTIC_WRITE</span><span class="o">,</span> <span class="n">hints</span><span class="o">);</span>
</pre></table></code></div></div><ul><li>‘javax.persistence.lock.timeout’ 힌트는 잠금을 구하는 대기 시간을 밀리초 단위로 지정한다.<li>지정한 시간 이내에 잠금을 구하지 못하면 익셉션을 발생시킨다.<li>이 힌트를 사용할 때 주의할 점은 DBMS에 따라 힌트가 적용되지 않을 수도 있따는 걳이다.<ul><li>힌트를 이용할 땐 사용중인 DBMS가 관련 기능을 지원하는지 확인해야 한다.</ul><li>스프링 데이터 JPA 는 <code class="language-plaintext highlighter-rouge">@QueryHints</code> 어노테이션을 사용해서 쿼리 힌트를 지정할 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kn">import</span> <span class="nn">org.sprintframework.data.jpa.repository.QueryHints</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">javax.persistence.QueryHint</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">MemberRepository</span> <span class="kd">extends</span> <span class="nc">Repository</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">,</span> <span class="nc">MemberId</span><span class="o">&gt;</span> <span class="o">{</span>
  <span class="nd">@Lock</span><span class="o">(</span><span class="nc">LockModeType</span><span class="o">.</span><span class="na">PESSIMISTIC_WRITE</span><span class="o">)</span>
  <span class="nd">@QueryHints</span><span class="o">({</span>
    <span class="nd">@QueryHint</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"javax.persistence.lock.timeout"</span><span class="o">,</span> <span class="n">value</span> <span class="o">=</span> <span class="s">"2000"</span><span class="o">)</span>
  <span class="o">})</span>
  <span class="nd">@Query</span><span class="o">(</span><span class="s">"select m from Member m where m.id = :id"</span><span class="o">)</span>
  <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">Member</span><span class="o">&gt;</span> <span class="nf">findByIdForUpdate</span><span class="o">(</span><span class="nd">@Param</span><span class="o">(</span><span class="s">"id"</span><span class="o">)</span> <span class="nc">MemberId</span> <span class="n">memberId</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><blockquote><p><strong>Note</strong>: DBMS에 따라 교착 상태인 커넥션을 처리하는 방식이 다르니(쿼리 /커넥션별 대기 시간 지정) 선점 잠금 사용시 사용하는 DBMS에 대해 JPA가 어떤 식으로 대기 시간을 처리하는지 반드시 확인해야 한다.</p></blockquote><h2 id="비선점-잠금">비선점 잠금</h2><ul><li>선점 잠금이 강력해9 보이긴 하지만 모든 트랜잭션 충돌 문제가 해결되는 것은 아니다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/6ce28fa6-d1dc-4f54-b497-90a231e1876d" alt="image" /></p><ul><li>위 이미지의 실행 순서는 아래와 같다.</ul><div class="language-text highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>1. 운영자는 배송을 위해 주문 정보를 조회한다. 시스템은 정보를 제공한다.
2. 고객이 배송지 변경을 위해 변경 폼을 요청한다. 시스템은 변경 폼을 제공한다.
3. 고객이 새로운 배송지를 입력 후 폼을 전송하여 배송지를 변경한다.
4. 운영자가 1번에서 조회한 주문 정보를 기준으로 배송지를 정하고 배송 상태 변경을 요청한다.
</pre></table></code></div></div><ul><li>여기서 문제는 운영자가 배송지 정보를 조회하고 배송 상태로 변경하는 사이에 고객이 배송지를 변경한다는 것이다.<li>운영자는 고객이 변경하기 전 배송지 정보를 이용하여 배송 준비를 한 뒤에 배송 상태로 변경하데 된다.<li>즉, 배송 상태 변경 전에 배송지를 한 번 더 확인하지 않으면 운영자는 다른 배송지로 물건을 발송하게 되고, 고객은 배송지를 변경했음에도 불구하고 엉뚱한 곳으로 주문한 물건을 받는 상황이 발생한다.<li>이 문제는 선점 잠금 방식으로는 해결할 수 없다. 이때 필요한 것이 <code class="language-plaintext highlighter-rouge">비선점 잠금</code>이다.<ul><li><b>비선점 잠금은 동시에 접근하는 것을 막는 대신 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능여부를 확인하는 방식이다.</b></ul><li>비선점 잠금을 구현하려면 애그리거트에 버전으로 사용할 숫자 타입 프로퍼티를 추가해야 한다.<li>애그리거트를 수정할 때마다 버전으로 사용할 프로퍼티 값이 1씩 증가하는데 이떄 다음과 같은 쿼리를 사용한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="no">UPDATE</span> <span class="n">aggtable</span> <span class="no">SET</span> <span class="n">version</span> <span class="o">=</span> <span class="n">version</span> <span class="o">+</span> <span class="mi">1</span><span class="o">,</span> <span class="n">colx</span> <span class="o">=</span> <span class="o">?,</span> <span class="n">coly</span> <span class="o">=</span> <span class="o">?</span>
<span class="no">WHERE</span> <span class="n">aggid</span> <span class="o">=</span> <span class="o">?</span> <span class="n">and</span> <span class="n">version</span> <span class="o">=</span> <span class="n">현재</span> <span class="n">버젼</span>
</pre></table></code></div></div><ul><li>이 쿼리는 수정할 애그리거트와 매핑되는 테이블의 버전 값이 현재 애그리거트의 버전과 동일한 경우에만 데이터를 수정한다.<li>그리고 수정에 성공하면 버전 값을 1 증가시킨다.<li>다른 트랜잭션이 먼저 데이터를 수정해서 버전 값이 바뀌면 데이터 수정에 실패하게 된다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/2560ee13-f4b5-4b9c-b535-63f56abc3bb8" alt="image" /></p><ul><li>스레드1과 2는 같은 버전을 갖는 애그리거트를 읽어와 수정하는데 스레드1이 먼저 수정 및 커밋 후 스레드2가 수정을 하게 되면 버전이 달라지기 때문에 데이터 수정에 실패하게 된다.<li>JPA는 버전을 이용한 비선점 잠금 기능을 지원한다.<li>다음과 같이 버전으로 사용할 필드에 <code class="language-plaintext highlighter-rouge">@Version</code> 어노테이션을 붙이고 매핑되는 에티읍ㄹ에 버전을 젖아할 칼럼을 추가하면 된다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="nd">@Entity</span>
<span class="nd">@Table</span><span class="o">(</span><span class="n">name</span> <span class="o">=</span> <span class="s">"purchase_order"</span><span class="o">)</span>
<span class="nd">@Access</span><span class="o">(</span><span class="nc">AccessType</span><span class="o">.</span><span class="na">FIELD</span><span class="o">)</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
  <span class="nd">@EmbeddedId</span>
  <span class="kd">private</span> <span class="nc">OrderNo</span> <span class="n">number</span><span class="o">;</span>

  <span class="nd">@Version</span>
  <span class="kd">private</span> <span class="kt">long</span> <span class="n">version</span><span class="o">;</span>

  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>JPA는 엔티티가 변경되어 update 쿼리를 날릴 때 <code class="language-plaintext highlighter-rouge">@Version</code>에 명시한 필드를 이용해서 비선점 잠금 쿼리를 실행한다.<li>즉, 애그리거트 객체의 버전이 10일 경우 update 쿼리를 실행할 때 아래와 같은 쿼리를 사용해서 버전이 일치하는 경우에만 데이터를 수정한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="no">UPDATE</span> <span class="n">purchagse_order</span> <span class="no">SET</span> <span class="o">...</span><span class="na">생략</span><span class="o">,</span> <span class="n">version</span> <span class="o">=</span> <span class="n">version</span> <span class="o">+</span> <span class="mi">1</span>
<span class="no">WHERE</span> <span class="n">number</span> <span class="o">=</span> <span class="o">?</span> <span class="n">and</span> <span class="n">version</span> <span class="o">=</span> <span class="mi">10</span>
</pre></table></code></div></div><ul><li>응용 서비스는 버전에 대해 알 필요가 없다.<li>기능 실행 과정에서 애그리거트 데이터가 변경되면 JPA는 트랜잭션 종료 시점에 비선점 잠금을 위한 쿼리를 실행한다.<li>비선점 잠금을 위한 쿼리를 실행할 때 쿼리 실행 결과로 수정된 행의 개수가 0이면 이미 누군가 앞서 데이터를 수정한 것이다.<li>이는 트랜잭션이 충돌한 것이므로 트랜잭션 종료 시점에 익셉션이 발생한다. (OptimisticLockingFailureException)<li>표현 영역의 코드는 이 익셉션의 발생 여부에 따라 트랜잭션 충돌이 일어났는지 확인할 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderController</span> <span class="o">{</span>
	<span class="o">...</span>
	<span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"/changeShipping"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">POST</span><span class="o">)</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">changeShipping</span><span class="o">(</span><span class="nc">ChangeShippingRequest</span> <span class="n">changeReq</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">try</span> <span class="o">{</span>
			<span class="n">changeShippingService</span><span class="o">.</span><span class="na">changeShipping</span><span class="o">(</span><span class="n">changeReq</span><span class="o">);</span>
			<span class="k">return</span> <span class="s">"changeShippingSuccess"</span><span class="o">;</span>
		<span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="n">optimisticLockingFailureException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
				<span class="c1">// 누군가 먼저 같은 주문 애그리거트를 수정했으므로, </span>
				<span class="c1">// 트랜잭션 충돌이 일어났다는 메시지를 보여준다. </span>
				<span class="k">return</span> <span class="s">"changeShippingExConflic"</span><span class="o">;</span>
		<span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/b4243021-1a97-4d5a-8d72-f164458fe718" alt="image" /></p><ul><li>시스템은 사용자에게 수정 폼을 제공시에 애그리거트 버전을 함께 제공하고, 폼을 서버에 전송시 이 버전을 함께 전송한다.<ul><li>이때 사용자가 전송한 버전과 애그리거트 버전이 동일한 경우에만 수정 기능을 실행하도록 하여 트랜잭션 충돌문제를 해소할 수 있다.</ul><li>비선점 잠금 방식을 여러 트랜잭션으로 확장하려면 애그리거트 정보를 뷰로 보여줄 때 버전 정보도 함께 사용자 화면에 전달해야 한다.<li>HTML 폼을 생성하는 경우 버전 값을 갖는 hidden 타입 <code class="language-plaintext highlighter-rouge">&lt;input&gt;</code> 태그를 생성해서 폼 전송시 버전 값이 서버에 함께 전달되도록 한다.</ul><div class="language-html highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nt">&lt;</span><span class="err">!</span><span class="na">-</span> <span class="na">애그리거트</span> <span class="na">정보를</span> <span class="na">보여줄</span> <span class="na">땐</span> <span class="na">뷰</span> <span class="na">코드는</span> <span class="na">버전</span> <span class="na">값을</span> <span class="na">함꼐</span> <span class="na">전송한다.</span> <span class="na">-</span><span class="nt">&gt;</span>
<span class="nt">&lt;form</span> <span class="na">th:action=</span><span class="s">"@{startShipping}"</span> <span class="na">method=</span><span class="s">"post"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"hidden"</span> <span class="na">name=</span><span class="s">"version"</span> <span class="na">th:value=</span><span class="s">"${orderDto.version}"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"hidden"</span> <span class="na">name=</span><span class="s">"orderNumber"</span> <span class="na">th:value=</span><span class="s">"${orderDto.orderNumber}"</span><span class="nt">&gt;</span>
  ...
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"submit"</span> <span class="na">value=</span><span class="s">"배송 상태로 변경하기"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/form&gt;</span>
</pre></table></code></div></div><ul><li>응용 서비스에 전달할 요청 데이터는 사용자가 전송한 버전값을 포함한다. 예를 들어, 배송 상태 변경을 처리하는 응용 서비스가 전달받는 데이터는 다음과 같이 주문 번호와 함께 해당 주문을 조회한 시점의 버전 값을 포함해야 한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StartShippingRequest</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">orderNumber</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kt">long</span> <span class="n">version</span><span class="o">;</span>


  <span class="o">...</span><span class="na">생성자</span><span class="o">,</span> <span class="n">getter</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>응용 서비스는 전달받은 버전 값을 이용해서 애그리거트의 버전과 일치하는지 확인하고 일치하는 경우에만 요청한 기능을 수행한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">StartShippingService</span> <span class="o">{</span>
  <span class="nd">@PreAuthorize</span><span class="o">(</span><span class="s">"hasRole('ADMIN')"</span><span class="o">)</span>
  <span class="nd">@Transactional</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">startShipping</span><span class="o">(</span><span class="nc">StartShippingRequest</span> <span class="n">req</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="k">new</span> <span class="nc">OrderNo</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getOrderNumber</span><span class="o">()));</span>
    <span class="n">checkOrder</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(!</span><span class="n">order</span><span class="o">.</span><span class="na">matchVersion</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getVersion</span><span class="o">()))</span> <span class="o">{</span>
      <span class="k">throw</span> <span class="k">new</span> <span class="nf">VersionConfilictException</span><span class="o">();</span>
    <span class="o">}</span>
    <span class="n">order</span><span class="o">.</span><span class="na">startShipping</span><span class="o">();</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>matchVersion 메서드는 현재 애그리거트 버전과 인자로 전달받은 버전의 결과에 따라 분기를 태운다.<li>만약 다를 경우 버전이 충돌했다는 익셉션을 발생시켜 표현 계층에 이를 알린다.<li>표현 계층은 버전 충돌 익셉션이 발생하면 버전 충돌을 사용자에게 알려주고 사용자가 알맞은 후속 처리를 할 수 있도록 한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="nd">@Controller</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderAdminController</span> <span class="o">{</span>
	<span class="kd">private</span> <span class="nc">StartShippingService</span> <span class="n">startShippingService</span><span class="o">;</span>

	<span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"/startShipping"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">POST</span><span class="o">)</span>
	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">startShipping</span><span class="o">(</span><span class="nc">StartShippingRequest</span> <span class="n">startReq</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">try</span> <span class="o">{</span>
			<span class="n">startShippingService</span><span class="o">.</span><span class="na">startShipping</span><span class="o">(</span><span class="n">startReq</span><span class="o">);</span>
			<span class="k">return</span> <span class="s">"shippingStarted"</span><span class="o">;</span>
		<span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">OptimisticLockingFailureException</span> <span class="o">|</span> <span class="nc">VersionConflicException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
			<span class="c1">// 트랜잭션 충돌</span>
			<span class="k">return</span> <span class="s">"startShippingTxConflict"</span><span class="o">;</span>
		<span class="o">}</span>
	<span class="o">}</span>
	<span class="o">...</span> 
</pre></table></code></div></div><ul><li>위 코드는 비선점 잠금과 관련해서 발생하는 두 개의 익셉션을 처리하고 있다.<li>하나는 스프링 프레임워크가 발생시키는 <code class="language-plaintext highlighter-rouge">OptimisticLockingFailureException</code> 이고 다른 하나는 으용 서비스 코드에서 발생시키는 <code class="language-plaintext highlighter-rouge">VersionConfilctException</code> 이다.<li>이 두 익셉션은 개발자 입장에선 트랜잭션 충돌이 발생한 신점을 명확히 구분한다.<ul><li><code class="language-plaintext highlighter-rouge">VersionConfilctException</code> 은 이미 누군가 애그리거트를 수정했다는 것을 의미<li><code class="language-plaintext highlighter-rouge">OptimisticLockingFailureException</code> 은 누군가가 거의 동시에 애그리거트를 수정했따는 것을 의미</ul><li>버전 충돌 상황에 대한 구분이 명시적으로 필요없다면 응용 서비스에서 프레임워크용 익셉션을 발생시키는 것도 고려 할 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kt">void</span> <span class="nf">startShipping</span><span class="o">(</span><span class="nc">StartShippingRequest</span> <span class="n">req</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">orderRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="k">new</span> <span class="nc">OrderNo</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getOrderNumber</span><span class="o">()));</span>
  <span class="n">checkOrder</span><span class="o">(</span><span class="n">order</span><span class="o">);</span>
  <span class="k">if</span> <span class="o">(!</span><span class="n">order</span><span class="o">.</span><span class="na">matchVersion</span><span class="o">(</span><span class="n">req</span><span class="o">.</span><span class="na">getVersion</span><span class="o">()))</span> <span class="o">{</span>
    <span class="c1">// 프레임워크가 제공하는 비선점 트랜잭션 충돌 관련 익셉션 사용</span>
    <span class="k">throw</span> <span class="k">new</span> <span class="nf">OptimisticLockingFailureException</span><span class="o">(</span><span class="err">"</span><span class="n">version</span> <span class="n">conflict</span><span class="o">);</span>
  <span class="o">}</span>
  <span class="n">order</span><span class="o">.</span><span class="na">startShipping</span><span class="o">();</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="강제-버전-증가">강제 버전 증가</h2><ul><li>애그리거트 루트 외에 다른 엔티티의 값만 변경된다면 이 경우 JPA는 루트 엔티티 버전값을 증가 시키지 않는다.<li>애그리거트 관점에서 보면 애그리거트가 바뀐 것이기 때문에 버전 값을 증가시켜야 비선점 잠금이 올바르게 동작한다.<li>JPA는 <code class="language-plaintext highlighter-rouge">LockModeType.OPTIMISTIC_FORCE_INCREMENT</code>를 사용해 엔티티를 구할때 강제로 버전 값을 증가시키는 잠금 모드를 지원하고 있다.<ul><li>이를 통해 해당 엔티티의 상태 변경 여부와 상관 없이 트랜잭션 종료 시점에 버전 값 증가처리를 강제 할 수 있다.<li>이 잠금 모들르 사용시 애그리거트 루트 엔티티가 아닌 다른 엔티티나 밸류가 변경되더라도 버전 값을 증가시킬 수 있으므로 비선점 잠금 기능을 안전하게 적용할 수 있다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="nd">@Repository</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JpaOrderRepository</span> <span class="kd">implements</span> <span class="nc">OrderRepository</span> <span class="o">{</span>
	<span class="nd">@PersistenceContext</span>
	<span class="kd">private</span> <span class="nc">EntityMangager</span> <span class="n">entityManager</span><span class="o">;</span>

	<span class="nd">@Override</span>
	<span class="kd">public</span> <span class="nc">Order</span> <span class="nf">findbyIdOptimisticLockMode</span><span class="o">(</span><span class="nc">OrderNo</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
		<span class="k">return</span> <span class="n">entityManager</span><span class="o">.</span><span class="na">find</span><span class="o">(</span><span class="nc">Order</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">id</span>
				<span class="nc">LockModeType</span><span class="o">.</span><span class="na">OPTIMISTTIC_FORCE_INCREMENT</span><span class="o">);</span>
	<span class="o">}</span>
<span class="o">...</span>
</pre></table></code></div></div><ul><li>스프링 데이터 JPA를 사용하면 앞서 살펴본 @Lock 어노테이션을 이용해서 지정하면 된다.</ul><h2 id="오프라인-선점-잠금">오프라인 선점 잠금</h2><ul><li>아틀라시안의 컨플루언스(Confluence)는 문서를 편집시 누군가 먼저 편집을 하는 중이면 다른 사용자가 문서를 수정하고 있다는 안내 문구를 보여준다.<li>이런 안내를 통해 여러 사용자가 동시에 한 문서를 충돌을 사전에 방지할 수 있게 해준다.<li>만약, 더 엄격하게 데이터 충돌을 막고 싶다면 누군가 수정화면을 보고 있을때 수정화면 자체를 실행하지 못하도록 해야 한다.<li>한 트랜잭션 범위에서만 적용되는 선점 잠금 방식이나 나중에 버전 충돌을 확인하는 비선점 잠금 방식으론 이를 구현할 수 없다.<li><p><b>이때 필요한 것이 오프라인 선점 잠금(Offline Pessimistic Lock)이다.</b></p><li>단일 트랜잭션에서 동시 변경을 막는 선점 잠금 방식과 달리 <code class="language-plaintext highlighter-rouge">오프라인 선점 잠금</code>은 여러 트랜잭션에 걸쳐 동시 변경을 막는다.<li>첫 번째 트랜잭션을 시작할 때 오프라인 잠금을 선점하고, 마지막 트랜잭션에서 잠금을 해제한다.<li>잠금을 해제하기 전까지 다른 사용자는 잠금을 구할 수 없다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/b6e6af24-b314-481b-a6b9-30fe5592bd3c" alt="image" /></p><ul><li>오프라인 선점 잠금을 사용하면 위 이미지의 과정1처럼 폼 요청 과정에서 잠금을 선점하고, 과정3처럼 수정 과정에서 잠금을 해제한다.<li>이미 잠금을 선점한 상태에서 다른 사용자가 폼을 요청하면 과정2처럼 잠금을 구할 수 없어 에러 화면을 보게 된다.</ul><h3 id="잠금-유효-시간의-필요성">잠금 유효 시간의 필요성</h3><ul><li><b>만약 사용자A가 과정3의 수정 요청을 수행하지 않고 프로그램을 종료하면 어떻게 될까?</b><ul><li>이 경우 잠금을 해제하지 않으므로 다른 사용자는 영원히 잠금을 구할 수 없는 상황이 발생한다.<li>이런 사태를 방지하기 위해 오프라인 선점 방식은 잠금 유효시간을 가져야 한다.<li>유효시간이 지나면 자동으로 잠금을 해제해서 다른 사용자가 잠금을 일정 시간 후에 다시 구할수 있도록 해야 한다.<li>사용자A가 잠금 유효시간이 지난 후 1초 뒤에 3번 과정을 수행했다고 가정하자. 잠금이 해제되어 사용자 A는 수정에 실패하게 된다.<li>이런 상황을 만들지 않으려면 일정 주기로 유효 시간을 증가시키는 방식이 필요하다.<li>예를 들어, 수정 폼에서 1분 단위로 Ajax 호출을 해서 잠금 유효 시간을 1분씩 증가시키는 방법이 있다.</ul></ul><h2 id="오프라인-선점-잠금을-위한-lockmanager-인터페이스와-관련-클래스">오프라인 선점 잠금을 위한 LockManager 인터페이스와 관련 클래스</h2><ul><li>오프라인 선점 잠금은 크게 <code class="language-plaintext highlighter-rouge">잠금 선점 시도</code>, <code class="language-plaintext highlighter-rouge">잠금 확인</code>, <code class="language-plaintext highlighter-rouge">잠금 해제</code>, <code class="language-plaintext highlighter-rouge">잠금 유효시간 연장</code>의 네 가지 기능이 필요하다.<li>이 기능을 위한 LockManager 인터페이스는 아래와 같다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// LockManager 인터페이스</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">LockManager</span> <span class="o">{</span>
	<span class="nc">LockId</span> <span class="nf">tryLock</span><span class="o">(</span><span class="nc">String</span> <span class="n">type</span><span class="o">,</span> <span class="nc">String</span> <span class="n">id</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">LockException</span><span class="o">;</span>

	<span class="kt">void</span> <span class="nf">checkLock</span><span class="o">(</span><span class="nc">LockId</span> <span class="n">lockId</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">LockException</span><span class="o">;</span>

	<span class="kt">void</span> <span class="nf">releaseLock</span><span class="o">(</span><span class="nc">LockId</span> <span class="n">lockId</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">LockException</span><span class="o">;</span>

	<span class="kt">void</span> <span class="nf">extendLockExpiration</span><span class="o">(</span><span class="nc">LockId</span> <span class="n">lockId</span><span class="o">,</span> <span class="kt">long</span> <span class="n">inc</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">LockException</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>tryLock 메서드는 rtype과 id 를 파라미터로 갖는다. 이 두 파라미터엔 각각 잠글 대상 타입과 식별자를 값으로 전달하며 된다.<ul><li>예를 들어 식별자가 10인 Article 에 대한 잠금을 구하고자 한다면 tryLock 메서드를 실행시 ‘domain.Article’을 type으로 주고 ‘10’을 id값으로 주면 된다.</ul><li>잠금을 식별할 때 사용하는 LockId는 아래와 같다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">// LockId 클래스</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LockId</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">value</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">LockId</span><span class="o">(</span><span class="nc">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
  <span class="o">}</span>

	<span class="kd">public</span> <span class="nc">String</span> <span class="nf">getValue</span><span class="o">()</span> <span class="o">{</span>
	  <span class="k">return</span> <span class="n">value</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>컨트롤러가 오프라인 선점 잠금 기능을 이용해서 데이터 수정 폼에 동시에 접근하는 것을 제어하는 코드는 아래와 같다.<ul><li>수정 폼에서 데이터를 전송할 때 LockId를 전송할 수 있도록 LockId를 모델에 추가했다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c1">// 서비스: 서비스는 잠금 ID를 리턴한다.</span>
<span class="kd">public</span> <span class="nc">DataAndLockId</span> <span class="nf">getDataWithLock</span><span class="o">(</span><span class="nc">Long</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// 1. 오프라인 선점 잠금 시도</span>
  <span class="nc">LockId</span> <span class="n">locakId</span> <span class="o">=</span> <span class="n">locakManager</span><span class="o">.</span><span class="na">tryLock</span><span class="o">(</span><span class="s">"data"</span><span class="o">,</span> <span class="n">id</span><span class="o">);</span>
  <span class="c1">// 2. 기능 실행</span>
  <span class="nc">Data</span> <span class="n">data</span> <span class="o">=</span> <span class="n">someDao</span><span class="o">.</span><span class="na">select</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
  <span class="k">return</span> <span class="k">new</span> <span class="nf">DataAndLocakId</span><span class="o">(</span><span class="n">data</span><span class="o">,</span> <span class="n">lockId</span><span class="o">);</span>
<span class="o">}</span>

<span class="c1">// 컨트롤러: 서비스가 리턴한 잠금ID를 모델로 뷰에 전달</span>
<span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"/some/edit/{id}"</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">editForm</span><span class="o">(</span><span class="nd">@PathVariable</span><span class="o">(</span><span class="s">"id"</span><span class="o">)</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">,</span> <span class="nc">ModelMap</span> <span class="n">model</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">DataAndLockId</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">dataService</span><span class="o">.</span><span class="na">getDataWithLock</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"data"</span><span class="o">,</span> <span class="n">dl</span><span class="o">.</span><span class="na">getData</span><span class="o">());</span>
    <span class="c1">// 3. 잠금 해제에 사용할 LockId를 모델에 추가</span>
    <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"lockId"</span><span class="o">,</span> <span class="n">dl</span><span class="o">.</span><span class="na">getLockId</span><span class="o">());</span>
    <span class="k">return</span> <span class="s">"editForm"</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>잠금을 선점하는데 실패하면 LockException이 발생한다.<ul><li>이때 다른 사용자가 데이터를 수정 중이니 나중에 다시 시도하라는 안내 화면을 보여주면 된다.</ul><li>수정 폼은 LockId 를 다시 전송해서 잠금을 해제할 수 있도록 한다.</ul><div class="language-html highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nt">&lt;form</span> <span class="na">th:action=</span><span class="s">"@{/some/edit/{id}(id=${data.id})}"</span> <span class="na">method=</span><span class="s">"post"</span><span class="nt">&gt;</span>
  ...
  <span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"hidden"</span> <span class="na">name=</span><span class="s">"lid"</span> <span class="na">th:value=</span><span class="s">"${locakId.value}"</span><span class="nt">&gt;</span>
  ...
<span class="nt">&lt;/form&gt;</span>
</pre></table></code></div></div><ul><li>잠금을 해제하는 코드는 다음과 같이 전달받은 LockId를 이용한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// 서비스: 잠금을 해제한다.</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">edit</span><span class="o">(</span><span class="nc">EditRequest</span> <span class="n">editReq</span><span class="o">,</span> <span class="nc">LockId</span> <span class="n">lockId</span><span class="o">)</span> <span class="o">{</span>
  <span class="c1">// 1. 잠금 선점 확인</span>
  <span class="n">lockManager</span><span class="o">.</span><span class="na">checkLock</span><span class="o">(</span><span class="n">lockId</span><span class="o">);</span>
  <span class="c1">// 2. 기능 실행</span>
  <span class="o">...</span>
  <span class="c1">// 3. 잠금 해제</span>
  <span class="n">lockManager</span><span class="o">.</span><span class="na">releaseLock</span><span class="o">(</span><span class="n">lockId</span><span class="o">);</span>
<span class="o">}</span>

<span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"/some/edit/{id}"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">POST</span><span class="o">)</span>
<span class="kd">public</span> <span class="nc">String</span> <span class="nf">edit</span><span class="o">(</span><span class="nd">@PathVariable</span><span class="o">(</span><span class="s">"id"</span><span class="o">)</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">,</span> 
                   <span class="nd">@ModelAttribute</span><span class="o">(</span><span class="s">"editReq"</span><span class="o">)</span> <span class="nc">EditRequest</span> <span class="n">editReq</span><span class="o">,</span> 
                   <span class="nd">@RequestMapping</span><span class="o">(</span><span class="s">"lid"</span><span class="o">)</span> <span class="nc">String</span> <span class="n">lockIdValue</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">editReq</span><span class="o">.</span><span class="na">setId</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
    <span class="n">someEditService</span><span class="o">.</span><span class="na">edit</span><span class="o">(</span><span class="n">editReq</span><span class="o">,</span> <span class="k">new</span> <span class="nc">LockId</span><span class="o">(</span><span class="n">lockIdValue</span><span class="o">));</span>
    <span class="n">model</span><span class="o">.</span><span class="na">addAttribute</span><span class="o">(</span><span class="s">"data"</span><span class="o">,</span> <span class="n">data</span><span class="o">);</span>

    <span class="k">return</span> <span class="s">"editSuccess"</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>서비스 코드를 보면 checkLock 메서드를 가장 먼저 실행하는데, 잠금을 선점한 이후에 실행하는 기능은 다음과 같은 상황을 고려하여 반드시 주어진 LockId를 갖는 잠금이 유효한지 확인해야 한다.<ul><li>잠금 유효시간이 지났으면 이미 다른 사용자가 잠금을 선점한다.<li>잠금을 선점하지 않은 사용자가 기능을 실행했따면 기능 실행을 막아야 한다.</ul></ul><h2 id="db-를-이용한-lockmanager-구현">DB 를 이용한 LockManager 구현</h2><ul><li>잠금 정보를 저장하기 위한 테이블 생성<ul><li>타입과 아이디를 기본키로 지정해 동시에 두 사용자가 특정 타입 데이터 잠금 구하는 것을 방지<li>각 잠금마다 새로운 LockId를 사용하므로 lockId 컬럼은 유니크 인덱스로 설정</ul></ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">create</span> <span class="k">table</span> <span class="n">locks</span> <span class="p">(</span>
  <span class="nv">`type`</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
  <span class="n">id</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
  <span class="n">lockid</span> <span class="nb">varchar</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
  <span class="n">expiration_time</span> <span class="nb">datetime</span><span class="p">,</span>
  <span class="k">primary</span> <span class="k">key</span> <span class="p">(</span><span class="nv">`type`</span><span class="p">,</span> <span class="n">id</span><span class="p">)</span>
<span class="p">)</span> <span class="nb">character</span> <span class="k">set</span> <span class="n">utf8</span><span class="p">;</span>

<span class="k">create</span> <span class="k">unique</span> <span class="k">index</span> <span class="n">locks_idx</span> <span class="k">ON</span> <span class="n">locks</span> <span class="p">(</span><span class="n">lockid</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>Order 타입의 1번 식별자를 갖는 애그리거트에 대한 잠금을 구하고 싶다면 다음의 insert 쿼리로 locks 테이블에 데이터 삽입</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">insert</span> <span class="k">into</span> <span class="n">locks</span> <span class="k">values</span> <span class="p">(</span><span class="s1">'Order'</span><span class="p">,</span> <span class="s1">'1'</span><span class="p">,</span> <span class="s1">'생성한lockid'</span><span class="p">,</span> <span class="s1">'2016-03-28 09:10:00'</span><span class="p">);</span>
</pre></table></code></div></div><ul><li>locks 테이블의 데이터를 담을 LockData 클래스 생성</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LockData</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">type</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">lockId</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">timestamp</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">LockData</span><span class="o">(</span><span class="nc">String</span> <span class="n">type</span><span class="o">,</span> <span class="nc">String</span> <span class="n">id</span><span class="o">,</span> <span class="nc">String</span> <span class="n">lockId</span><span class="o">,</span> <span class="kt">long</span> <span class="n">timestamp</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">type</span> <span class="o">=</span> <span class="n">type</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">lockId</span> <span class="o">=</span> <span class="n">lockId</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">timestamp</span> <span class="o">=</span> <span class="n">timestamp</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getType</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">type</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getId</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">id</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getLockId</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">lockId</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">long</span> <span class="nf">getTimestamp</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">timestamp</span><span class="o">;</span>
    <span class="o">}</span>

		<span class="c1">// 유효 시간이 지났는지를 판단할 때 사용</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isExpired</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">timestamp</span> <span class="o">&lt;</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>locks 테이블을 이용해서 LockManager를 구현</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
</pre><td class="rouge-code"><pre><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">SpringLockManager</span> <span class="kd">implements</span> <span class="nc">LockManager</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">lockTimeout</span> <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">JdbcTemplate</span> <span class="n">jdbcTemplate</span><span class="o">;</span>

  <span class="kd">private</span> <span class="nc">RowMapper</span><span class="o">&lt;</span><span class="nc">LockData</span><span class="o">&gt;</span> <span class="n">lockDataRowMapper</span> <span class="o">=</span> <span class="o">(</span><span class="n">rs</span><span class="o">,</span> <span class="n">rowNum</span><span class="o">)</span> <span class="o">-&gt;</span>
          <span class="k">new</span> <span class="nf">LockData</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">1</span><span class="o">),</span> <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">2</span><span class="o">),</span>
                  <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="mi">3</span><span class="o">),</span> <span class="n">rs</span><span class="o">.</span><span class="na">getTimestamp</span><span class="o">(</span><span class="mi">4</span><span class="o">).</span><span class="na">getTime</span><span class="o">());</span>

  <span class="kd">public</span> <span class="nf">SpringLockManager</span><span class="o">(</span><span class="nc">JdbcTemplate</span> <span class="n">jdbcTemplate</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">jdbcTemplate</span> <span class="o">=</span> <span class="n">jdbcTemplate</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="cm">/**
   * type과 id에 대한 잠금 시도
   */</span>
  <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="nc">Propagation</span><span class="o">.</span><span class="na">REQUIRES_NEW</span><span class="o">)</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="nc">LockId</span> <span class="nf">tryLock</span><span class="o">(</span><span class="nc">String</span> <span class="n">type</span><span class="o">,</span> <span class="nc">String</span> <span class="n">id</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">LockException</span> <span class="o">{</span>
      <span class="n">checkAlreadyLocked</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">id</span><span class="o">);</span>
      <span class="nc">LockId</span> <span class="n">lockId</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">LockId</span><span class="o">(</span><span class="no">UUID</span><span class="o">.</span><span class="na">randomUUID</span><span class="o">().</span><span class="na">toString</span><span class="o">());</span>
      <span class="n">locking</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">id</span><span class="o">,</span> <span class="n">lockId</span><span class="o">);</span>
      <span class="k">return</span> <span class="n">lockId</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="cm">/**
   * type과 id에 대한 잠금이 존재하는지 검사
   */</span>
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">checkAlreadyLocked</span><span class="o">(</span><span class="nc">String</span> <span class="n">type</span><span class="o">,</span> <span class="nc">String</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">List</span><span class="o">&lt;</span><span class="nc">LockData</span><span class="o">&gt;</span> <span class="n">locks</span> <span class="o">=</span> <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">query</span><span class="o">(</span>
              <span class="s">"select * from locks where type = ? and id = ?"</span><span class="o">,</span>
              <span class="n">lockDataRowMapper</span><span class="o">,</span> <span class="n">type</span><span class="o">,</span> <span class="n">id</span><span class="o">);</span>
      <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">LockData</span><span class="o">&gt;</span> <span class="n">lockData</span> <span class="o">=</span> <span class="n">handleExpiration</span><span class="o">(</span><span class="n">locks</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">lockData</span><span class="o">.</span><span class="na">isPresent</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">AlreadyLockedException</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="cm">/**
   * 유효시간이 지난 락인지 아닌지 판단 후 유효시간 내 락이면 리턴
   */</span>
  <span class="kd">private</span> <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">LockData</span><span class="o">&gt;</span> <span class="nf">handleExpiration</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">LockData</span><span class="o">&gt;</span> <span class="n">locks</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">locks</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="k">return</span> <span class="nc">Optional</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
      <span class="nc">LockData</span> <span class="n">lockData</span> <span class="o">=</span> <span class="n">locks</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">lockData</span><span class="o">.</span><span class="na">isExpired</span><span class="o">())</span> <span class="o">{</span>
          <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">update</span><span class="o">(</span>
                  <span class="s">"delete from locks where type = ? and id = ?"</span><span class="o">,</span>
                  <span class="n">lockData</span><span class="o">.</span><span class="na">getType</span><span class="o">(),</span> <span class="n">lockData</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
          <span class="k">return</span> <span class="nc">Optional</span><span class="o">.</span><span class="na">empty</span><span class="o">();</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="k">return</span> <span class="nc">Optional</span><span class="o">.</span><span class="na">of</span><span class="o">(</span><span class="n">lockData</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="cm">/**
   * locks 테이블에 잠금 데이터를 삽입
   * 데이터 삽입 결과가 없거나 DuplicateKeyException이 발생하면 LockingFailException을 익셉션을 발생시킨다
   */</span>
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">locking</span><span class="o">(</span><span class="nc">String</span> <span class="n">type</span><span class="o">,</span> <span class="nc">String</span> <span class="n">id</span><span class="o">,</span> <span class="nc">LockId</span> <span class="n">lockId</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">try</span> <span class="o">{</span>
          <span class="kt">int</span> <span class="n">updatedCount</span> <span class="o">=</span> <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">update</span><span class="o">(</span>
                  <span class="s">"insert into locks values (?, ?, ?, ?)"</span><span class="o">,</span>
                  <span class="n">type</span><span class="o">,</span> <span class="n">id</span><span class="o">,</span> <span class="n">lockId</span><span class="o">.</span><span class="na">getValue</span><span class="o">(),</span> <span class="k">new</span> <span class="nc">Timestamp</span><span class="o">(</span><span class="n">getExpirationTime</span><span class="o">()));</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">updatedCount</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">LockingFailException</span><span class="o">();</span>
      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">DuplicateKeyException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
          <span class="k">throw</span> <span class="k">new</span> <span class="nf">LockingFailException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
      <span class="o">}</span>
  <span class="o">}</span>

  <span class="cm">/**
   * 잠금 유효 시간 생성
   */</span>
  <span class="kd">private</span> <span class="kt">long</span> <span class="nf">getExpirationTime</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">()</span> <span class="o">+</span> <span class="n">lockTimeout</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="cm">/**
   * 잠금이 유효한지 검사
   */</span>
  <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="nc">Propagation</span><span class="o">.</span><span class="na">REQUIRES_NEW</span><span class="o">)</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">checkLock</span><span class="o">(</span><span class="nc">LockId</span> <span class="n">lockId</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">LockException</span> <span class="o">{</span>
      <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">LockData</span><span class="o">&gt;</span> <span class="n">lockData</span> <span class="o">=</span> <span class="n">getLockData</span><span class="o">(</span><span class="n">lockId</span><span class="o">);</span>
      <span class="k">if</span> <span class="o">(!</span><span class="n">lockData</span><span class="o">.</span><span class="na">isPresent</span><span class="o">())</span> <span class="k">throw</span> <span class="k">new</span> <span class="nc">NoLockException</span><span class="o">();</span>
  <span class="o">}</span>

  <span class="cm">/**
   * lockId에 해당하는 LockData 조회
   */</span>
  <span class="kd">private</span> <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">LockData</span><span class="o">&gt;</span> <span class="nf">getLockData</span><span class="o">(</span><span class="nc">LockId</span> <span class="n">lockId</span><span class="o">)</span> <span class="o">{</span>
      <span class="nc">List</span><span class="o">&lt;</span><span class="nc">LockData</span><span class="o">&gt;</span> <span class="n">locks</span> <span class="o">=</span> <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">query</span><span class="o">(</span>
              <span class="s">"select * from locks where lockid = ?"</span><span class="o">,</span>
              <span class="n">lockDataRowMapper</span><span class="o">,</span> <span class="n">lockId</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
      <span class="k">return</span> <span class="nf">handleExpiration</span><span class="o">(</span><span class="n">locks</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="cm">/**
   * lockId에 해당하는 잠금 유효 시간을 inc 만큼 연장
   */</span>
  <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="nc">Propagation</span><span class="o">.</span><span class="na">REQUIRES_NEW</span><span class="o">)</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">extendLockExpiration</span><span class="o">(</span><span class="nc">LockId</span> <span class="n">lockId</span><span class="o">,</span> <span class="kt">long</span> <span class="n">inc</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">LockException</span> <span class="o">{</span>
      <span class="nc">Optional</span><span class="o">&lt;</span><span class="nc">LockData</span><span class="o">&gt;</span> <span class="n">lockDataOpt</span> <span class="o">=</span> <span class="n">getLockData</span><span class="o">(</span><span class="n">lockId</span><span class="o">);</span>
      <span class="nc">LockData</span> <span class="n">lockData</span> <span class="o">=</span>
              <span class="n">lockDataOpt</span><span class="o">.</span><span class="na">orElseThrow</span><span class="o">(()</span> <span class="o">-&gt;</span> <span class="k">new</span> <span class="nc">NoLockException</span><span class="o">());</span>
      <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">update</span><span class="o">(</span>
              <span class="s">"update locks set expiration_time = ? where type = ? AND id = ?"</span><span class="o">,</span>
              <span class="k">new</span> <span class="nf">Timestamp</span><span class="o">(</span><span class="n">lockData</span><span class="o">.</span><span class="na">getTimestamp</span><span class="o">()</span> <span class="o">+</span> <span class="n">inc</span><span class="o">),</span>
              <span class="n">lockData</span><span class="o">.</span><span class="na">getType</span><span class="o">(),</span> <span class="n">lockData</span><span class="o">.</span><span class="na">getId</span><span class="o">());</span>
  <span class="o">}</span>

  <span class="cm">/**
   * lockId에 해당하는 잠금 데이터를 locks 테이블에서 삭제
   */</span>
  <span class="nd">@Transactional</span><span class="o">(</span><span class="n">propagation</span> <span class="o">=</span> <span class="nc">Propagation</span><span class="o">.</span><span class="na">REQUIRES_NEW</span><span class="o">)</span>
  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">releaseLock</span><span class="o">(</span><span class="nc">LockId</span> <span class="n">lockId</span><span class="o">)</span> <span class="kd">throws</span> <span class="nc">LockException</span> <span class="o">{</span>
      <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="s">"delete from locks where lockid = ?"</span><span class="o">,</span> <span class="n">lockId</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLockTimeout</span><span class="o">(</span><span class="kt">int</span> <span class="n">lockTimeout</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">lockTimeout</span> <span class="o">=</span> <span class="n">lockTimeout</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="reference-5">Reference</h2><ul><li>예제 코드 및 이미지<ul><li><a href="https://heeveloper.github.io/2020/08/29/08-%EC%95%A0%EA%B7%B8%EB%A6%AC%EA%B1%B0%ED%8A%B8-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B4%80%EB%A6%AC/">https://heeveloper.github.io/2020/08/29/08-%EC%95%A0%EA%B7%B8%EB%A6%AC%EA%B1%B0%ED%8A%B8-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-%EA%B4%80%EB%A6%AC/</a><li><a href="https://velog.io/@hoonki/%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C%EC%9D%98-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%EC%84%A0%EC%A0%90-%EC%A0%90%EA%B8%88-%EB%B9%84%EC%84%A0%EC%A0%90-%EC%9E%A0%EA%B8%88-%EC%98%A4%ED%94%84%EB%9D%BC%EC%9D%B8-%EC%84%A0%EC%A0%90-%EC%9E%A0%EA%B8%88">https://velog.io/@hoonki/%EB%A9%80%ED%8B%B0-%EC%8A%A4%EB%A0%88%EB%93%9C-%ED%99%98%EA%B2%BD%EC%97%90%EC%84%9C%EC%9D%98-%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0%EC%84%A0%EC%A0%90-%EC%A0%90%EA%B8%88-%EB%B9%84%EC%84%A0%EC%A0%90-%EC%9E%A0%EA%B8%88-%EC%98%A4%ED%94%84%EB%9D%BC%EC%9D%B8-%EC%84%A0%EC%A0%90-%EC%9E%A0%EA%B8%88</a><li><a href="https://madini.tistory.com/m/34">https://madini.tistory.com/m/34</a></ul></ul><h1 id="chapter9-도메인-모델과-바운디드-컨텍스트">Chapter9-도메인 모델과 바운디드 컨텍스트</h1><h2 id="도메인-모델과-경계">도메인 모델과 경계</h2><ul><li>처음 도메인 모델을 만들때 빠지기 쉬운 함정이 도메인을 완벽하게 표현하는 단일 모델을 만드는 시도를 하는 것이다.<li><p>1장에서 말한 것처럼 한 도메인은 다시 여러 하위 도메인으로 구분되기 떄문에 한 개의 모델로 여러 하위 도메인을 모두 표현하려고 시도하면 모든 하위 도메인에 맞지 않는 모델을 만들게 된다.</p><li>예를 들어, 상품이라는 모델을 생각해자. 카탈로그에서의 상품, 재고 관리에서의 상품, 주문에서의 상품, 배송에서의 상품은 이름만 같지 실제로 의미하는것은 다르다.<li>카탈로그에서의 상품은 상품 이미지, 상품명, 상품 가격, 옵션 목록과 같은 상품정보 위주라면 재고 관리에서의 상품은 실존하는 개별 객체를 추적하기 위한 목적으로 상품을 사용한다.<ul><li>즉 카탈로그는 물리적으로 한 개인의 상품이 재고 관리에서는 여러 개 존재할 수 있다.</ul><li>논리적으로 같은 존재처럼 보이지만 하위 도메인에 따라 다른 용어를 사용하는 경우도 있다.<li>카탈로그 도메인에서 상품이 검색 도메인에서는 문서로 불리기도 한다. 비슷하게 시스템을 사용하는 사람을 회원 도메인에서 회원이라고 부르지만 주문 도메인에서는 주문자 라고 부르고 배송 도메인에서는 보내는 사람이라 부르기도 한다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/78608ba5-a10d-4ad9-8cc3-f8ce7e3ef70d" alt="image" /></p><ul><li><p><b>이렇게 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를수 있기 떄문에 한개의 모델로 모든 하위 도메인을 표현하려는 시도는 올바른 방법이 아니며 표현할 수도 없다.</b></p><li>하위 도메인마다 사용하는 용어가 다르기 떄문에 올바른 도메인 모델을 개발하기 위해서라면 하위 도메인마다 모델을 만들어야 한다.<li>각 모델은 명시적으로 구분되는 경계를 가져서 섞이지 않도록 해야 한다.<li><p>여러 하위도메인의 모델이 섞이기 시작하면 모델의 의미가 약해질뿐 아니라 여러 도메인의 모델이 서로 얽히기 떄문에 각 하위 도메인 별로 다르게 발전하는 요구사항을 모델에 반영하기 어려워 진다.</p><li>모델은 특정한 컨텍스트(문맥) 하에 완전한 의미를 갖는다.<ul><li>같은 제품이라도 카탈로그 컨텍스트와 재고 컨텍스트에서 의미가 서로 다르다.<li>이렇게 구분되는 경계를 갖는 컨텍스트를 DDD 에선 바운디드 컨텍스트 라고 부른다.</ul></ul><h2 id="바운디드-컨텍스트">바운디드 컨텍스트</h2><ul><li>바운디드 컨텍스트는 모델의 경계를 결정하며 한 개의 바운디드 컨텍스트는 논리적으로 한 개의 모델을 갖는다.<li>바운디드 컨텍스트는 용어를 기준으로 구분 한다.<li>카탈로그 컨텍스트와 재고 컨텍스트는 서로 다른 용어를 사용하므로 이 용어를 기준으로 컨텍스트를 분리할수 있다.<li><p>바운디드 컨텍스트는 실제로 사용자에게 기능을 제공하는 물리적 시스템으로 도메인 모델은 이 컨텍스트 안에서 도메인을 구현한다.</p><li><b>이상적으로 하위 도메인과 바운디드 컨텍스트가 1대1 관계를 가지면 좋겠지만 현실은 그렇지 않을 때가 많다.</b><li>바운디드 컨텍스트가 기업의 팀 조직 구조에 따라 결정되기도 한다.<ul><li>예를 들어, 주문 하위 도메인이라도 주문을 처리하는 팀과 복잡한 결제 금액 계산 로직을 구현하는 팀이 따로 있다고 해보자.<li>이 경우 주문 하위도메인에 주문 바운디드 컨텍스트와 결제 금액 계산 바운디드 컨텍스트가 존재하게 된다.<li>아직 용어를 명확하게 하지 못해 두 하위 도메인을 한 바운디드 컨텍스트에서 구현하기도 한다.<li>카탈로그와 재고 관리가 아직 명확하게 구분되지 않은 경우 두 하위 도메인을 하나의 바운디드 컨텍스트에서 구현하기도 한다.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/b971ff7c-fa56-41b6-ac15-0fa8b71b7341" alt="image" /></p><ul><li>규모가 작은 기업은 전체 시스템을 한 개 팀에서 구현할 때도 있다.<li>예를 들어 소규모 쇼핑몰을 운영할 경우 한개의 웹 애플리케이션으로 온라인 쇼핑을 서비스한다.<li>이 경우 하나의 시스템에서 회원, 카탈로그, 재고, 구매, 결제와 관련된 기능을 제공 한다.<li>즉 여러 하위도메인을 한 개의 바운디드 컨텍스트에서 구현한다<ul><li><b>여러 하위 도메인을 하나의 바운디드 컨텍스트에서 개발할때 주의할 점은 하위 도메인의 모델이 섞이지 않도록 하는것이다.</b></ul><li>한 프로젝트에 각 하위 도메인의 모델이 위치하면 아무래도 전체 하위 도메인을 위한 단일 모델을 만들고 싶은 유혹에 빠지기 쉽다.<ul><li>이런 유혹에 걸려들면 결과적으로 도메인 모델이 개별 하위 도메인을 제대로 반영하지 못해서 하위 도메인별 기능 확장이 어렵게 되고 이는 서비스의 경쟁력을 떨어뜨리는 원인이 된다.<li><b>따라서 비록 한개의 바운디드 컨텍스트에서 여러 하위 도메인을 포함하더라도 하위 도메인마다 구분되는 패키지를 갖도록 구현해야 하위 도메인을 위한 모델이 서로 뒤섞이지 않아서 하위 도메인마다 바운디드 컨텍스트를 갖는 효과를 낼 수 있다.</b></ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/0ecfe5c9-c010-4ba8-9d57-8c75ab8ea557" alt="image" /></p><ul><li>바운디드 컨텍스트는 도메인 모델을 구분하는 경계가 되기 때문에 바운디드 컨텍스트는 구현하는 하위 도메인에 알맞은 모델을 포함한다.<li>같은 사용자라 하더라도 주문 바운디드 컨텍스트와 회원 바운디드 컨텍스트가 갖는 모델이 달라진다.<li>또한 같은 상품이라도 카탈로그 바운디드 컨텍스트의 Product와 재고 바운디드 컨텍스트의 Product는 각 컨텍스트에 맞는 모델을 갖는다.<li>따라서 회원의 Member는 애그리것 루트이지만 주문의 Orderer는 밸류가 되고 카탈로그의 Product는 상품이 속할 Catergory와 연관을 갖지만 재고의 Product는 카탈로그의 Category와 연관을 맺지 않는다.</ul><h2 id="바운디드-컨텍스트-구현">바운디드 컨텍스트 구현</h2><ul><li>바운디드 컨텍스트가 도메인 모델만 포함하는 것은 아니다.<ul><li>도메인 기능을 사용자에게 제공하기 위해 표현 영역, 응용 서비스, 인프라 영역 등을 모두 포함한다.<li>도메인 모델의 데이터 구조가 바뀌면 DB 테이블 스키마도 함께 변경해야 하므로 해당 테이블도 바운디드 컨텍스트에 포함된다.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/68841e83-e2cc-4c33-8dc0-70822ff84def" alt="image" /></p><ul><li>표현 영역은 HTML 페이지를 생성할 수도 있고, 다른 바운디드 컨텍스트를 위해 REST API 를 제공할 수도 있다.<li>모든 바운디드 컨텍스트를 반드시 도메인 주도로 개발할 필요는 없다. 상품의 리뷰는 복잡한 도메인 로직을 갖지 않기 때문에 CRUD 방식으로 구현해도 된다.<ul><li>즉, DAO와 데이터 중심의 밸류 객체를 이용해서 리뷰 기능을 구현해도 기능을 유지보수하는데 큰 문제가 없다.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/96730af4-3e6d-4133-9a2d-0eb8aff18906" alt="image" /></p><ul><li>한 바운디드 컨텍스트에서 두 방식을 혼합해서 사용할 수도 있다.<li>대표적인 예가 CQRS 패턴이다.<ul><li>CQRS 는 Command Query Responsibility Segregation 의 약자로 상태를 변경하는 명령 기능과 내용을 조회하는 쿼리 기능을 위한 모델을 구분하는 패턴이다.</ul><li>이 패턴을 단일 바운디드 컨텍스트에 적용하면 아래 이미지와 같이 상태 변경과 관련된 기능은 도메인 모델 기반으로 구현하고, 조회 기능은 서비스-DAO 를 이용해서 구현할 수 있다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/c8191604-1497-431b-932d-a279dba8b607" alt="image" /></p><ul><li>각 바운디드 컨텍스트는 서로 다른 구현 기술을 사용할 수도 있다.<ul><li>예를 들어, 리포지터리 구현 기술을 JPA/하이버네이트&amp;RDB 를 사용하는 바운디드 컨텍스트가 있을 수 있고, MyBatis&amp;NoSQL 를 사용하는 바운디드 컨텍스트가 있을 수 있고..</ul><li>바운디드 컨텍스트가 반드시 사용자에게 보여지는 UI 를 가지고 있어야 하는 것은 아니다.<ul><li>웹 브라우저는 카탈로그 바운디드 컨텍스트를 통해 상세 정보를 읽어온 뒤, 리뷰 바운디드 컨텍스트의 REST API를 직접 호출해서 로딩한 JSON 데이터를 알맞게 가공해서 리뷰 목록을 보여줄 수도 있다.<li>또한 UI 를 처리하는 서버(BFF 와 같은 프록시 서버)를 두고 UI서버에서 바운디드 컨텍스트와 통신해서 사용자 요청을 처리하는 방법도 있다.<li>위 같은 구조에서 UI 서버는 각 바운디드 컨텍스트를 위한 파사드 역할을 수행한다. 브라우저가 UI서버에 요청을 보내면 UI 서버는 카탈로그와 리뷰 바운디드 컨텍스트로부터 필요한 정보를 읽어와 조합한 뒤 브라우저에 응답한다.</ul></ul><h2 id="바운디드-컨텍스트-간-통합">바운디드 컨텍스트 간 통합</h2><ul><li>온라인 쇼핑 사이트에서 매출 증대를 위해 카탈로그 하위 도메인에 개인화 추천 기능을 도입하기로 했다고 하자.<li>기존 카탈로그 시스템을 개발하던 팀과 별도로 추천 시스템을 담당하는 팀이 새로 생겨서 이 팀에서 주도적으로 추천 시스템을 만들기로 했다.<li>이렇게 되면 카탈로그 하위 도메인에는 기존 카탈로그를 위한 바운디드 컨텍스트와 추천 기능을 위한 바운디드 컨텍스트가 생긴다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/5c7bd466-7fe0-45d1-9acc-ccb9a3b7eeb4" alt="image" /></p><ul><li>두 팀이 관련된 바운디드 컨텍스트를 개발하면 자연스럽게 두 바운디드 컨텍스트 간 통합이 발생한다.<li>카탈로그와 추천 바운디드 컨텍스트 간 통합이 필요한 기능은 다음과 같다.<ul><li><code class="language-plaintext highlighter-rouge">사용자가 제품 상세 페이지를 볼 때, 보고 있는 상품과 유사한 상품 목록을 하단에 보여준다.</code></ul><li>사용자가 카탈로그 바운디드 컨텍스트에 추천 제품 목록을 요청하면 카탈로그 바운디드 컨텍스트는 추천 바운디드 컨텍스트로부터 추천 정보를 읽어와 추천 제품 목록을 제공한다.<li>이때 카탈로그 컨텍스트와 추천 컨텍스트의 모델은 서로 다르다.<ul><li>카탈로그는 제품을 중심으로 도메인 모델을 구현하지만 추천은 추천 연산을 위한 모델을 구현한다.<li>예를 들어 추천 시스템은 상품의 상세 정보를 포함하지 않으며 상품 번호 대신 아이템 ID라는 용어를 사용해서 식별자를 표현하고 추천 순위와 같은 데이터를 담게 된다.</ul><li>카탈로그 시스템은 추천 시스템으로부터 추천 데이터를 받아오지만, 카탈로그 시스템에선 추천의 도메인 모델을 사용하기보단 카탈로그 도메인 모델을 사용해서 추천 상품을 표현해야 한다.<ul><li>즉, 다음과 같이 카탈로그의 모델을 기반으로 하는 <code class="language-plaintext highlighter-rouge">도메인 서비스</code>를 이용해서 상품 추천 기능을 표현해야 한다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cm">/**
 * 상품 추천 기능을 표현하는 도메인 서비스
 */</span>
<span class="kd">public</span> <span class="kd">interface</span> <span class="nc">ProductRecommendationService</span> <span class="o">{</span>
    <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="nf">getRecommendationOf</span><span class="o">(</span><span class="nc">ProductId</span> <span class="n">id</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li><b>도메인 서비스를 구현한 클래스는 인프라 스트럭처 영역에 위치한다.</b><li>이 클래스는 외부 시스템과의 연동을 처리하고 외부 시스템의 모델과 현재 도메인 모델 간의 변환을 책임진다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/4ded8111-6896-4363-a9bd-5657dfba7492" alt="image" /></p><ul><li>RecSystemClient는 외부 추천 시스템이 제공하는 REST API를 이용해서 특정 상품을 위한 추천 상품 목록을 로딩한다.<ul><li>이 REST API가 제공하는 데이터는 추천 시스템의 모델을 기반으로 하기에 카탈로그 도메인 모델과 일치하지 않을 수 있다.</ul></ul><div class="language-json highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="p">{</span><span class="w">
    </span><span class="p">{</span><span class="err">itemID:</span><span class="w"> </span><span class="err">'PROD</span><span class="mi">-1000</span><span class="err">'</span><span class="p">,</span><span class="w"> </span><span class="err">type:</span><span class="w"> </span><span class="err">'PRODUCT'</span><span class="p">,</span><span class="w"> </span><span class="err">rank:</span><span class="w"> </span><span class="mi">100</span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="err">itemID:</span><span class="w"> </span><span class="err">'PROD</span><span class="mi">-1001</span><span class="err">'</span><span class="p">,</span><span class="w"> </span><span class="err">type:</span><span class="w"> </span><span class="err">'PRODUCT'</span><span class="p">,</span><span class="w"> </span><span class="err">rank:</span><span class="w"> </span><span class="mi">54</span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></pre></table></code></div></div><ul><li>RecSystemClient가 REST API를 통해 데이터를 읽어와 카탈로그에 맞는 상품 모델로 변환한다. 아래는 해당 코드를 나타낸 것이다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">RecSystemClient</span> <span class="kd">implements</span> <span class="nc">ProductRecommendationService</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">ProductRepository</span> <span class="n">productRepository</span><span class="o">;</span>
    
    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="nf">getRecommendationOf</span><span class="o">(</span><span class="nc">ProductId</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Recommendation</span><span class="o">&gt;</span> <span class="n">items</span> <span class="o">=</span> <span class="n">getRecItems</span><span class="o">(</span><span class="n">id</span><span class="o">.</span><span class="na">getValue</span><span class="o">());</span>
        <span class="k">return</span> <span class="nf">toProducts</span><span class="o">(</span><span class="n">items</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">RecommendationItem</span><span class="o">&gt;</span> <span class="nf">getRecItems</span><span class="o">(</span><span class="nc">String</span> <span class="n">itemId</span><span class="o">)</span> <span class="o">{</span>
      <span class="c1">// externalRecClient는 외부 추천 시스템을 위한 클라이언트라고 가정</span>
        <span class="k">return</span> <span class="n">externalRecClient</span><span class="o">.</span><span class="na">getRecs</span><span class="o">(</span><span class="n">itemId</span><span class="o">);</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">Product</span><span class="o">&gt;</span> <span class="nf">toProducts</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">RecommendationItem</span><span class="o">&gt;</span> <span class="n">items</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">items</span><span class="o">.</span><span class="na">stream</span><span class="o">()</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">item</span> <span class="o">-&gt;</span> <span class="n">toProductId</span><span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">getItemId</span><span class="o">())</span>
                <span class="o">.</span><span class="na">map</span><span class="o">(</span><span class="n">prodId</span> <span class="o">-&gt;</span> <span class="n">productRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">prodId</span><span class="o">))</span>
                <span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">toList</span><span class="o">());</span>
    <span class="o">}</span>
    
    <span class="kd">private</span> <span class="nc">ProductId</span> <span class="nf">toProductId</span><span class="o">(</span><span class="nc">String</span> <span class="n">itemId</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="nf">ProductId</span><span class="o">(</span><span class="n">itemId</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>getRecItems() 메서드에서 사용하는 externalRecClient는 외부 추천 시스템에 연결할 때 사용하는 클라이언트로서 팀에서 배포한 추천 시스템을 관리하는 모듈이라 가정하자.<li>이 모듈이 제공하는 RecommendationItem 은 추천 시스템의 모델을 따를텐데 RecSystemClient 는 추천 시스템의 모델을 받아와 toProducts() 메서드를 이용해서 카탈로그 도메인의 Product 모델로 변환하는 작업을 처리한다.<li>두 모델 간의 변환 과정이 복잡하면 변환 처리를 위한 별도 클래스를 만들고 이 클래스에서 변환을 처리해도 된다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/85428538-b5f4-46af-9888-3efc0db6b373" alt="image" /></p><ul><li><b>Rest API를 호출하는 것은 두 바운디드 컨텍스트를 직접 통합하는 방법이다.</b><li><b>직접 통합하는 대신 간접적으로 통합하는 방법도 있다.</b><ul><li><b>대표적인것이 메시지 큐(ex. kafka, rabiit mq)를 사용하는 것이다.</b><li>추천 시스템은 사용자가 조회한 상품 이력이나 구매 이력과 같은 사용자 활동 이력을 필요로 하는데 이 내역을 전달할 때 메시지 큐를 사용할 수 있다.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/6eccabee-b53e-4d99-8bdc-24e5d31b9cc7" alt="image" /></p><ul><li>위 이미지에서 카탈로그 바운디드 컨텍스트는 추천 시스템이 필요로 하는 사용자 활동 이력을 메시지 큐에 추가한다.<li><p>메시지 큐는 비동기로 메시지를 처리하기 때문에 카탈로그 바운디드 컨텍스트는 메시지를 큐에 추가한 뒤에 추천 바운디드 컨텍스트가 메시지를 처리할 때 까지 기다리지 않고 바로 이어서 자신의 처리를 계속한다.</p><li>추천 바운디드 컨텍스트는 큐에서 이력 메시지를 읽어와 추천을 계산하는데 사용할 것이다.<li>이것은 두 바운디드 컨텍스트가 사용할 메시지의 데이터 구조를 맞춰야 함을 의미한다.<li>각각의 바운디드 컨텍스트를 담당하는 팀은 서로 만나서 주고 받을 데이터 형식에 대해 협의햏야 한다.<li>메시지 시스템을 카탈로그 측에서 관리하고 있따면 큐에 담기는 메시지는 아래와 같이 카탈로그 도메인을 따르는 데이터를 담을 것이다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ViewLog</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">Long</span> <span class="n">memberId</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">Long</span> <span class="n">productId</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">ZonedDateTime</span> <span class="n">timeStamp</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderLog</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">Long</span> <span class="n">memberId</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">OrderNumber</span> <span class="n">orderNumber</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">OrderLineLog</span><span class="o">&gt;</span> <span class="n">orderLineLogs</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">ZonedDateTime</span> <span class="n">timeStamp</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">totalAmounts</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderLineLog</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">Long</span> <span class="n">memberId</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">Long</span> <span class="n">productId</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">ZonedDateTime</span> <span class="n">timeStamp</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>만약 추천 바운디드 컨텍스트 관점에서 접근한다면 아래와 같이 메시지 데이터 구조를 잡을 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ActiveLog</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">Long</span> <span class="n">itemId</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">Long</span> <span class="n">userId</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">ActiveType</span> <span class="n">activeType</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">ZonedDateTime</span> <span class="n">actionDate</span><span class="o">;</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>어떤 도메인 관점에서 모델을 사용하느냐에 따라 두 바운디드 컨텍스트의 구현 코드가 달라지게 된다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="c1">// 1) 카탈로그 관점에서의 모델을 사용할 때의 구현 코드</span>
<span class="c1">// 상품 조회 관련 로그 기록 코드</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ViewLogService</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">MessageClient</span> <span class="n">mesasgeClient</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">appendViewLog</span><span class="o">(</span><span class="nc">String</span> <span class="n">memberId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">productId</span><span class="o">,</span> <span class="nc">Date</span> <span class="n">time</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">messageClient</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="k">new</span> <span class="nc">ViewLog</span><span class="o">(</span><span class="n">memberId</span><span class="o">,</span> <span class="n">productId</span><span class="o">,</span> <span class="n">time</span><span class="o">));</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span>

<span class="c1">// messageClient</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RabbitMQClient</span> <span class="kd">implements</span> <span class="nc">MessageClient</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">RabiitTemplate</span> <span class="n">rabbitTemplate</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">send</span><span class="o">(</span><span class="nc">ViewLog</span> <span class="n">viewLog</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 카탈로그 기준으로 작성한 데이터를 큐에 그대로 보관</span>
    <span class="n">rabbitTemplate</span><span class="o">.</span><span class="na">convertAndSend</span><span class="o">(</span><span class="n">logQueueName</span><span class="o">,</span> <span class="n">viewLog</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 2) 추천 시스템 관점에서의 모델을 사용할 때의 구현 코드</span>
<span class="c1">// 상품 조회 관련 로그 기록 코드</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ViewLogService</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">MessageClient</span> <span class="n">mesasgeClient</span><span class="o">;</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">appendViewLog</span><span class="o">(</span><span class="nc">String</span> <span class="n">memberId</span><span class="o">,</span> <span class="nc">String</span> <span class="n">productId</span><span class="o">,</span> <span class="nc">Date</span> <span class="n">time</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">messageClient</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="k">new</span> <span class="nc">ActivityLog</span><span class="o">(</span><span class="n">productId</span><span class="o">,</span> <span class="n">memberId</span><span class="o">,</span> <span class="nc">ActivityType</span><span class="o">.</span><span class="na">VIEW</span><span class="o">,</span> <span class="n">time</span><span class="o">));</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span>

<span class="c1">// messageClient</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">RabbitMQClient</span> <span class="kd">implements</span> <span class="nc">MessageClient</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">RabiitTemplate</span> <span class="n">rabbitTemplate</span><span class="o">;</span>

  <span class="nd">@Override</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">send</span><span class="o">(</span><span class="nc">ActivityLog</span> <span class="n">activityLog</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">rabbitTemplate</span><span class="o">.</span><span class="na">convertAndSend</span><span class="o">(</span><span class="n">logQueueName</span><span class="o">,</span> <span class="n">activityLog</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li><b>두 바운디드 컨텍스트를 개발하는 팀은 메시징 큐에 담을 데이터 구조를 협의하게 되는데 그 큐를 누가 제공하느냐에 따라 데이터 구조가 결정된다.</b><ul><li>예를 들어, 카탈로그 시스템에서 큐를 제공한다면 큐에 담기는 내용은 카탈로그 도메인을 따른다.<li>카탈로그 도메인은 메시징 큐에 카탈로그 관련 메시지를 저장하게 되고 다른 바운디드 컨텍스트는 이 큐로부터 필요한 메시지를 수신하는 방식을 사용한다.<li>즉, 이 방식은 한쪽에서 메시지를 출한고 다른 쪽에서 메시지를 구독하는 출판/구독 모델을 따른다.(pub/sub 모델)</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/618514dc-4f37-497b-bb4e-c96722156f86" alt="image" /></p><ul><li>큐를 추천시스템에서 제공할 경우 큐를 통해 메시지를 추천 시스템에 전달하는 방식이 된다.<ul><li>이 경우 큐로 인해 비동기로 추천 시스템에 데이터를 전달하는 것을 제외하면 추천 시스템이 제공하는 REST API를 사용해서 데이터를 전달하는 것과 차이가 없다.</ul></ul><blockquote><p><strong>마이크로서비스와 바운디드 컨텍스트</strong>: 마이크로서비스는 애플리케이션을 작은 서비스로 나누어 개발하는 아키텍처 스타일이다. 개별 서비스를 독립된 프로세스로 실행하고 각 서비스가 REST API나 메시징을 이용해서 통신하는 구조를 갖는다. <code class="language-plaintext highlighter-rouge">바운디드 컨텍스트를 마이크로서비스로 구현하면 자연스럽게 컨텍스트별로 모델이 분리된다.</code> 마이크로서비스마다 프로젝트를 생성하므로 바운디드 컨텍스트마다 프로젝트를 만들게 된다. 이것은 코드 수준에서 모델을 분리하여 두 바운디드 컨텍스트의 모델이 섞이지 않도록 해준다.</p></blockquote><h2 id="바운디드-컨텍스트-간-관계">바운디드 컨텍스트 간 관계</h2><ul><li>바운디드 컨텍스트는 어떤 식으로든 연결되기 떄문에 두 바운디드 컨텍스트는 다양한 방식으로 관계를 맺는다.</ul><h3 id="1-한-쪽에서-api를-제공하고-다른-쪽에서-api를-호출하는-관계가장-흔한-관계">1) 한 쪽에서 API를 제공하고 다른 쪽에서 API를 호출하는 관계(가장 흔한 관계)</h3><ul><li>REST API가 대표적이다.<li>이 관계에서 API를 사용하는 바운디드 컨텍스트는 API를 제공하는 바운디드 컨텍스트에 의존하게 된다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/c6371886-7303-418d-9676-4ded17bb1775" alt="image" /></p><ul><li>위 이미지에서 하류 컴포넌트인 카탈로그 컨텍스트는 상류 컴포넌트인 추천 컨텍스트가 제공하는 데이터와 기능에 의존한다.<li>카탈로그는 추천 상품을 보여주기 위해 추천 바운디드 컨텍스트가 제공하는 REST API를 호출한다.<li>추천 시스템이 제공하는 REST API의 인터페이스가 바뀌면 카탈로그 시스템의 코드도 바뀌게 된다.<li>상류 컴포넌트는 일종의 서비스 공급자 역할을 하며 하류 컴포넌트는 그 서비스를 사용하는 고객 역할을 한다.<ul><li><b>고객과 공급자 관계에 있는 두 팀은 상호 협력이 필수적이다.</b><li>공급자를 하는 상류팀이 마음대로 API를 변경하면 하류 팀은 변경된 API에 맞추느라 우선수위가 높은 다른 기능을 개발 못할 수 도 있다.<li>반대로 상류 팀이 무언가를 변경할때마다 하류 팀으로부터 여러 절차를 거쳐 승낙을 받아야 한다면 상류팀은 새로운 개발 시도 자체를 하지 않을 수도 있다.<li><b>따라서 상류 팀과 하류 팀은 개발 계획을 서로 공유하고 일정을 합의해야 한다.</b></ul><li>상류팀의 고객인 하류 팀이 다수 존재하면 상류 팀은 여러 하류 팀의 요구사항을 수용할 수 있는 API를 만들고 이를 서비스 형태로 공개해서 서비스의 일관성을 유지할 수 있다.<li>이런 서비스를 가리켜 <code class="language-plaintext highlighter-rouge">공개 호스트 서비스(OPEN HOST SERVICE)</code> 라 한다.<li>공개 호스트 서비스의 대표적인 예가 검색이다.<ul><li>블로그, 카페, 게시판과 같은 서비스를 제공하는 포털은 각 서비스별로 검색 기능을 구현하기보단 검색을 위한 전용 시스템을 구축하고 검색 시스템과 각 서비스를 통합한다.<li>이때 검색 시스템은 상류 컴포넌트가 되고 블로그, 카페, 게시판은 하류 컴포넌트가 된다.<li>상류 팀은 각 하류 컴포넌트의 요구사항을 수용하는 단일 API를 만들어 이를 공개하고 각 하류 팀은 공개된 API를 사용해서 검색 기능을 구현한다.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/81f8ab15-1570-43a6-b112-97df5ff56fb0" alt="image" /></p><ul><li>상류 컴포넌트의 서비스는 상류 바운디드 컨텍스트의 도메인 모델을 따른다.<li>따라서 하류 컴포넌트는 상류 서비스의 모델이 자신의 도메인 모델에 영향을 주지 않도록 보호해주는 안충 지대를 만들어야 한다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/4ded8111-6896-4363-a9bd-5657dfba7492" alt="image" /></p><ul><li>위 이미지에서 RecSystemClient 는 외부 시스템과의 연동을 처리하는데 외부 시스템의 도메인 모델이 내 도메인 모델을 침범하지 않도록 막아주는 역할을 한다.<ul><li>즉, 내 모델이 깨지는 것을 막아주는 안티코럽션 계층이 된다.<li>이 계층에선 두 바운디드 컨텍스트 간의 모델 변환을 처리해주기 때문에 다른 바운디드 컨텍스트의 모델에 영향을 받지 않고 내 도메인 모델을 유지할 수 있다.</ul><li>두 바운디드 컨텍스트가 같은 모델을 공유하는 경우도 있다.<ul><li>예를 들어, 운영자를 위한 주문 관리 도구를 개발하는 팀과 고객을 위한 주문 서비스를 개발하는 팀..<li>두 팀이 공유하는 모델을 <code class="language-plaintext highlighter-rouge">공유 커널</code>이라 한다.<li>공유 커널의 장점은 중복을 줄여준다는 것이다.<li>공유 커널의 단점은 한 팀에서 임의로 모델을 변경시 다른 팀에 영향이 가기 때문에 두 팀이 밀접한 관계를 유지해야 한다.<li>두 팀이 밀접한 관계를 형성할 수 없다면 공유 커널을 사용할 때의 장점보다 공유 커널로 인해 개발이 지연되고 정체되는 문제가 더 커진다.</ul></ul><h3 id="2-독립-방식separate-way">2) 독립 방식(SEPARATE WAY)</h3><ul><li>그냥 서로 통합하지 않는 방식으로 서로 독립적으로 모델을 발전시킨다.<li>두 바운디드 컨텍스트 간의 통합은 수동으로 이루어진다.<ul><li>예를 들어 온라인 쇼핑몰 솔루션과 외부 ERP 서비스를 사용한다 했을때 이 둘은 연동을 지원하지 않으므로 온라인 쇼핑몰에서 판매가 발생하면 쇼핑몰 운영자는 쇼핑몰 시스템에서 판매 정보를 보고 ERP에 수동으로 입력해야 한다.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/e824517f-3c1e-4ac8-949a-7c95953eb649" alt="image" /></p><ul><li>수동으로 통합하는 방식이 나쁜 것은 아니지만 규모가 커질수록 한계가 있으므로 규모가 커지기 시작하면 두 바운디드 컨텍스트를 통합해야 한다.<li>이때 외부에서 구매한 솔루션과 ERP를 완전히 대체할 수 없다면 두 바운디드 컨텍스트를 통합해주는 별도의 시스템을 만들어야 할 수도 있다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/fedc889a-747b-43bd-83b3-ed7fed231e19" alt="image" /></p><h2 id="컨텍스트-맵">컨텍스트 맵</h2><ul><li>개별 바운디드 컨텍스트에 매몰되면 전체를 보지 못할 때가 있다.<li><b>전체 비즈니스를 조망할 수 있는 지도가 필요한데 그것이 바로 컨텍스트 맵이다.</b></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/a30d7a0d-d7fd-49d4-bafa-8919399bb8ba" alt="image" /></p><ul><li>그림만 봐도 한 눈에 각 바운디드 컨텍스트의 경계가 명확하게 드러나고 서로 어떤 관계를 맺고 있는지 알 수 있다.<li>바운디드 컨텍스트 영역에 주요 애그리거트를 함께 표시하면 모델에 대한 관계가 더 명확히 드러난다.<li><p>오픈 호스트 서비스(OHS)와 안티코럽션 계층(ACL)만 표시했는데 하위 도메인이나 조직 구조를 함께 표시하면 도메인을 포함한 전체 관계를 이해하는데 도움이 된다.</p><li>컨텍스트 맵은 시스템의 전체 구조를 보여준다.<li>이는 하위 도메인과 일치하지 않는 바운디드 컨텍스트를 찾아 도메인에 맞게 바운디드 컨텍스트를 조절하고 사업의 핵심 도메인을 위해 조직 역량을 어떤 바운디드 컨텍스트에 집중할지 파악하는데 도움을 준다.<li>컨텍스트 맵을 그리는 규칙은 따로 없다.<ul><li>위 예시 이미지와 같이 간단한 도형과 선을 이용해서 각 컨텍스트 간의 관계를 이해할 수 있는 수준에서 그리면 된다.<li>컨텍스트 맵은 단순하기 때문에 화이트보다 PPT 와 같은 도구를 이용해서 쉽게 그릴 수 있다.</ul></ul><blockquote><p><strong>Note</strong>: 컨텍스트 맵은 전체 시스템의 이해 수준을 보여준다. 즉, 시스템을 더 잘 이해하거나 시간이 지나면서 컨텍스트간 관계가 바뀌면 컨텍스트 맵도 함께 바뀐다.</p></blockquote><h2 id="reference-6">Reference</h2><ul><li>예제 코드 및 이미지<ul><li><a href="https://velog.io/@csh0034/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-09.-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EB%B0%94%EC%9A%B4%EB%94%94%EB%93%9C-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8">https://velog.io/@csh0034/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-09.-%EB%8F%84%EB%A9%94%EC%9D%B8-%EB%AA%A8%EB%8D%B8%EA%B3%BC-%EB%B0%94%EC%9A%B4%EB%94%94%EB%93%9C-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8</a><li><a href="https://kingds.tistory.com/113">https://kingds.tistory.com/113</a><li><a href="https://be-developer.tistory.com/78">https://be-developer.tistory.com/78</a><li><a href="https://sangjaeoh.github.io/books/%EB%8F%84%EB%A9%94%EC%9D%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/#94-%EB%B0%94%EC%9A%B4%EB%94%94%EB%93%9C-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EA%B0%84-%ED%86%B5%ED%95%A9">https://sangjaeoh.github.io/books/%EB%8F%84%EB%A9%94%EC%9D%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/#94-%EB%B0%94%EC%9A%B4%EB%94%94%EB%93%9C-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EA%B0%84-%ED%86%B5%ED%95%A9</a></ul></ul><h1 id="chapter10-이벤트">Chapter10-이벤트</h1><h2 id="101-시스템-간-강결합-문제">10.1 시스템 간 강결합 문제</h2><ul><li>쇼핑몰에서 구매를 취소하면 환불을 처리해야 한다.<li>이때 환불 기능을 실행하는 주체는 주문 도메인 엔티티가 될 수 있따.<li><b>도메인 객체에서 환불 기능을 실행하려면 다음 코드처럼 환불 기능을 제공하는 도메인 서비스를 파라미터로 전달바독 취소 도메인 기능에서 도메인 서비스를 실행하게 된다.</b></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="c1">// 외부 서비스를 실행하기 위해 도메인 서비스를 파라미터로 전달받음</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cancel</span><span class="o">(</span><span class="nc">RefundService</span> <span class="n">refundService</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">verifyNotYetShipped</span><span class="o">();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="nc">OrderState</span><span class="o">.</span><span class="na">CANCELED</span><span class="o">;</span>

    <span class="k">this</span><span class="o">.</span><span class="na">refundStatus</span> <span class="o">=</span> <span class="nc">State</span><span class="o">.</span><span class="na">REFUND_STARTED</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">refundService</span><span class="o">.</span><span class="na">refund</span><span class="o">(</span><span class="n">getPaymentId</span><span class="o">());</span>
      <span class="k">this</span><span class="o">.</span><span class="na">fefundStatus</span> <span class="o">=</span> <span class="nc">State</span><span class="o">&gt;</span><span class="no">REFUND_COMPLETED</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
      <span class="o">??</span>
    <span class="o">}</span>

  <span class="o">}</span>

  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>혹은 응용 서비스에서 환불 기능을 실행할 수도 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CancelOrderService</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">RefundService</span> <span class="n">refundService</span><span class="o">;</span>

  <span class="nd">@Transactional</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cancel</span><span class="o">(</span><span class="nc">OrderNo</span> <span class="n">orderNo</span><span class="o">)</span> <span class="o">{</span>
    <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">findOrder</span><span class="o">(</span><span class="n">orderNo</span><span class="o">);</span>
    <span class="n">order</span><span class="o">.</span><span class="na">cancel</span><span class="o">();</span>

    <span class="n">order</span><span class="o">.</span><span class="na">refundStarted</span><span class="o">();</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">refundService</span><span class="o">.</span><span class="na">refund</span><span class="o">(</span><span class="n">order</span><span class="o">.</span><span class="na">getPaymentId</span><span class="o">());</span>
      <span class="n">order</span><span class="o">.</span><span class="na">refundCompleted</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
      <span class="o">???</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>보통 결제 시스템은 외부에 존재하므로 RefundService는 외부 결제 시스템이 제공하는 환불 서비스를 호출한다.<li>이때 세 가지 문제가 발생할 수 있다.</ul><h3 id="1-트랜잭션-처리-범위-문제">1) 트랜잭션 처리 범위 문제</h3><ul><li>외부 서비스가 정상이 아닐 경우 트랜잭션 처리를 어떻게 해야할지 애매하다는 것이다.<ul><li>환불 기능을 실행하는 과정에서 익셉션이 발생하면 롤백해야 할까? 일단 커밋?<li>외부의 환불 서비스를 실행하는 과정에서 익셉션이 발생하면 환불에 실패했으므로 주문 취소 트랜잭션을 롤백하는 것이 맞아 보인다.<li>하지만 반드시 롤백 해야 하는 것은 아니다. 주문은 취소 상태로 변경하고 환불만 나중에 다시 시도하는 방식으로 처리할 수도 있다.</ul></ul><h3 id="2-성능-문제">2) 성능 문제</h3><ul><li>환불을 처리하는 외부 시스템의 응답 시간이 길어지면 그만큼 대기 시간도 길어진다.<ul><li>예를 들어, 환불 처리 기능이 30초 걸리면 주문 취소 기능은 30초만큼 대기시간이 증가한다.<li>즉, 외부 서비스 성능에 직접적인 영향을 받게 된다.</ul></ul><h3 id="3-도메인-객체에-서비스를-전달함으로써-추가적인-설계-문제">3) 도메인 객체에 서비스를 전달함으로써 추가적인 설계 문제</h3><ul><li>우선 주문 로직과 결제 로직이 섞이는 문제가 있을 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
  <span class="o">...</span>
  <span class="c1">// 외부 서비스를 실행하기 위해 도메인 서비스를 파라미터로 전달받음</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cancel</span><span class="o">(</span><span class="nc">RefundService</span> <span class="n">refundService</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">verifyNotYetShipped</span><span class="o">();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="nc">OrderState</span><span class="o">.</span><span class="na">CANCELED</span><span class="o">;</span>
    <span class="c1">// 여기까지 주문 로직</span>

    <span class="k">this</span><span class="o">.</span><span class="na">refundStatus</span> <span class="o">=</span> <span class="nc">State</span><span class="o">.</span><span class="na">REFUND_STARTED</span><span class="o">;</span>
    <span class="k">try</span> <span class="o">{</span>
      <span class="n">refundService</span><span class="o">.</span><span class="na">refund</span><span class="o">(</span><span class="n">getPaymentId</span><span class="o">());</span>
      <span class="k">this</span><span class="o">.</span><span class="na">fefundStatus</span> <span class="o">=</span> <span class="nc">State</span><span class="o">&gt;</span><span class="no">REFUND_COMPLETED</span><span class="o">;</span>
    <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
      <span class="o">??</span>
    <span class="o">}</span>
    <span class="c1">// 여기까지 결제 로직</span>

  <span class="o">}</span>

  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>그리고 기존 기능에 새로운 기능을 추가할 때 발생한다.<ul><li>만약 주문을 취소한 뒤 환불뿐만 아니라 취소했다는 내용을 통지해야 한다면?<li>환불 도메인 서비스와 동일하게 파라미터로 통지 서비스를 받도록 해야할 것이고 앞서 언급한 로직이 섞인는 문제가 더 커지고 트랜잭션 처리가 더 복잡해지게 될 것이다.<li>게다가 영향 주는 외부 서비스가 두개로 증가한다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
  <span class="c1">// 기능을 추가할 떄마다 파라미터가 함께 추가되면</span>
  <span class="c1">// 다른 로직이 더 많이 섞이고, 트랜잭션 처리가 더 복잡해진다.</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cancel</span><span class="o">(</span><span class="nc">RefundService</span> <span class="n">refundService</span><span class="o">,</span> <span class="nc">NotiService</span> <span class="n">notiSvc</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">verifyNotYetShipped</span><span class="o">();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="nc">OrderState</span><span class="o">.</span><span class="na">CANCELED</span><span class="o">;</span>
    
    <span class="o">...</span>
    <span class="c1">// 주문 + 결제 + 통지 로직이 섞임</span>
    <span class="c1">// refundService 는 성공하고, notiSvc는 실패하면?</span>
    <span class="c1">// refundService와 notiSvc 중 무엇을 먼저 처리하나?</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>위에서 언급된 문제들은 주문 바운디드 컨텍스트와 결제 바운디드 컨텍스트간의 강결합(high coupling) 때문이다.<li>주문이 결제와 강하게 결합되어 있어서 주문 바운디드 컨텍스트가 결제 바운디드 컨텍스트에 영향을 받게 되는 것이다.<li><b>이런 강결합을 없앨 수 있는 방법이 이벤트를 사용하는 것이다.</b><li>특히 비동기 이벤트를 사용하면 두 시스템 간의 결합도를 크게 낮출 수 있는데, 한 번 익숙해지면 모든 연동을 이벤트와 비동기로 처리하고 싶을 정도로 강력하고 매력적인 것이 이벤트다.</ul><h2 id="102-이벤트-개요">10.2 이벤트 개요</h2><ul><li>‘이벤트’ 는 ‘과거에 벌어진 어떤 것’을 의미한다.<ul><li>예를 들어, 사용자가 암호를 변경한 것은 ‘암호를 변경했음 이벤트’가 벌어졌다고 할 수 있다. 비슷하게 주문을 취소했다면 ‘주문을 취소했음 이벤트’가 발생했다고 할 수 있다.</ul><li>웹 브라우저에서 자바스크립트 코드를 작성해본 경험이 있는 개발자라면 이미 이벤트에 익숙할 것이다.<ul><li>UI개발에서 모든 UI컴포넌트는 관련 이벤트를 발생시킨다.<li>예를 들어, 버튼을 클릭시 ‘버튼 클릭됨 이벤트’, 스크롤시 ‘스크롤됨 이벤트’가 발생하게 된다.</ul><li>이벤트가 발생했다는 것은 상태가 변경됐다는 것을 의미한다.<li><p>‘암호 변경됨 이벤트’가 발생한 이유는 회원이 암호를 변경했기 때문이고, ‘주문 취소됨 이벤트’가 발생한 이유는 주문을 취소했기 떄문이다.</p><li>이벤트가 발생하면 그 이벤트 반응하여 우너하는 동작을 수행하는 기능을 구현한다.<ul><li>다음 자바스크립트는 jQuery를 이용해서 작성한 코드이다.<li>이 코드에서 click() 에 전달한 함수는 ‘myBtn’ 버튼에서 ‘클릭됨 이벤트’가 발생하면 그 이벤트에 반응하여 경고창을 출력한다.</ul></ul><div class="language-javascript highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nf">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">#myBtn</span><span class="dl">"</span><span class="p">).</span><span class="nf">click</span><span class="p">(</span><span class="nf">function </span><span class="p">(</span><span class="nx">evt</span><span class="p">)</span> <span class="p">{</span>
  <span class="nf">alert</span><span class="p">(</span><span class="dl">"</span><span class="s2">경고</span><span class="dl">"</span><span class="p">);</span>
<span class="p">});</span>
</pre></table></code></div></div><ul><li>도메인 모델에서도 UI 컴포넌트와 유사하게 도메인의 상태 변경을 이벤트로 표현할 수 있다.<li>보통 ‘~할 때’, ‘~가 발생하면’, ‘만약 ~하면’과 같은 요구사항은 도메인의 상태 변경과 관련된 경우가 많고 이런 요구사항을 이벤트를 이용해서 구현할 수 있다.<li>예를 들어 ‘주문을 취소할 때 이메일을 보낸다’ 라는 요구사항에서 주문을 취소할 때’ 는 주문이 취소 상태로 바뀌는 것을 의미하므로 ‘주문 취소됨 이벤트’를 활용해서 구현할 수 있다.</ul><h3 id="1021-이벤트-관련-구성-요소">10.2.1 이벤트 관련 구성 요소</h3><ul><li>도메인 모델에 이벤트를 도입하려면 아래 이미지와 같이 네 개의 구성요소인 <code class="language-plaintext highlighter-rouge">이벤트</code>, <code class="language-plaintext highlighter-rouge">이벤트 생성 주체</code>, <code class="language-plaintext highlighter-rouge">이벤트 디스패처(퍼블리셔)</code>, <code class="language-plaintext highlighter-rouge">이벤트 핸들러(구독자)</code>를 구현해야 한다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/cee6e932-fcb9-4310-82b9-263dd80acad7" alt="image" /></p><ul><li><b>이벤트 생성 주체</b><ul><li><b>도메인 모델에서 이벤트 생성 주체는 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체이다.</b><li><b>이들 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 발생시킨다.</b></ul><li><b>이벤트 핸들러</b><ul><li>이벤트 생성 주체가 발생한 이벤트에 반응한다.<li>생성 주체가 발생한 이벤트를 전달받아 이벤트에 담긴 데이터를 이용해서 원하는 기능을 실행한다.<li>예를 들어, ‘주문 취소됨 이벤트’를 받는 이벤트 핸들러는 해당 주문의 주문자에게 SMS로 주문 취소 사실을 통지할 수 있다.</ul><li><b>이벤트 디스패처</b><ul><li>이벤트 생성 주체와 이벤트 핸들러를 연결해준다.<li>이벤트 생성 주체는 이벤트를 생성해서 디스패처에 이벤트를 전달한다.<li>이벤트를 전달받은 디스패처는 해당 이벤트를 처리할 수 있는 핸들러에 이벤트를 전파한다.<li>이벤트 디스패처의 구현 방식에 따라 이벤트 생성과 처리를 동기나 비동기로 실행하게 된다.</ul></ul><h3 id="1022-이벤트의-구성">10.2.2 이벤트의 구성</h3><ul><li>이벤트는 발생한 이벤트에 대한 정보를 담는다.<li>이 정보는 다음을 포함한다.<ul><li>1)이벤트 종류: 클래스 이름으로 이벤트 종류를 표현<li>2)이벤트 발생시간<li>3)추가 데이터: 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보</ul><li>배송지를 변경시 발생하는 이벤트는 아래와 같이 작성할 수 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShippingInfoChangedEvent</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">orderNumber</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kt">long</span> <span class="n">timestamp</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">ShippingInfo</span> <span class="n">newShippingInfo</span><span class="o">;</span>

  <span class="c1">// 생성자, getter</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li><p><b>클래스 이름을 보면 ‘Changed’라는 과거 시제를 사용했다. 이벤트는 현재 기준으로 과거(바로 직전이라도)에 벌어진 것을 표현하기 때문에 이벤트 이름에는 과거 시제를 사용한다.</b></p><li>이 이벤트를 발생하는 주체는 Order 애그리거트다. Order 애그리거트의 배송지 변경 기능을 구현한 메서드는 다음 코드처럼 배송지 정보를 변경한 뒤에 이 이 벤트를 발생시킬 것이다.<li>이 코드에서 <code class="language-plaintext highlighter-rouge">Events.raise()</code> 는 디스패처를 통해 이벤트르 전파하는 기능을 제공하는데 이 기능의 구현과 관련된 내용은 뒤에서 살펴보도록 하자.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">changeShippingInfo</span><span class="o">(</span><span class="nc">ShippingInfo</span> <span class="n">newShippingInfo</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">verifyNotYetShipped</span><span class="o">();</span>
    <span class="n">setShippingInfo</span><span class="o">(</span><span class="n">newShippingInfo</span><span class="o">);</span>
    <span class="nc">Events</span><span class="o">.</span><span class="na">raise</span><span class="o">(</span><span class="k">new</span> <span class="nc">ShippingInfoChangedEvent</span><span class="o">(</span><span class="n">number</span><span class="o">,</span> <span class="n">newShippingInfo</span><span class="o">));</span>
  <span class="o">}</span>
  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>ShippingInfoChangedEvent 를 처리하는 핸들러는 디스패처로부터 이벤트를 전달받아 필요한 작업을 수행한다.<ul><li>예를 들어, 변경된 배송지 정보를 물류 서비스에 전송하는 핸들러는 다음과 같이 구현할 수 있다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShippingInfoChangedHandler</span> <span class="o">{</span>
  <span class="nd">@EventListener</span><span class="o">(</span><span class="nc">ShippingInfoChangedEvent</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">ShippingInfoChangedEvent</span> <span class="n">evt</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">shippingInfoSynchronizer</span><span class="o">.</span><span class="na">sync</span><span class="o">(</span>
      <span class="n">evt</span><span class="o">.</span><span class="na">getOrderNumber</span><span class="o">(),</span>
      <span class="n">evt</span><span class="o">.</span><span class="na">getNewShippingInfo</span><span class="o">()</span>
    <span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>이벤트는 이벤트 핸들러가 작업을 수행하는데 필요한 데이터를 담아야 한다.<li>이 데이터가 부족하면 핸들러는 필요한 데이터를 읽기 위해 관련 API를 호출하거나 DB에서 데이터를 직접 읽어와야 한다.<li>예를 들어, ShppingInfoChangedEvent 가 바뀐 배송지 정보를 포함하고 있지 않다고 가정해보자.<ul><li>이 핸들러가 같은 VM에서 동작하고 있따면 다음과 같이 주문 데이터를 로딩해서 배송지 정보를 추출해야 한다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShippingInfoChangedHandler</span> <span class="o">{</span>
  
  <span class="nd">@EventListener</span><span class="o">(</span><span class="nc">ShippingInfoChangedEvent</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">ShippingInfoChangedEvent</span> <span class="n">evt</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 이벤트가 필요한 데이터를 담고 있지 않으면,</span>
    <span class="c1">// 이벤트 핸들러는 리포지터리, 조회 API, 직접 DB 접근 등의</span>
    <span class="c1">// 방식을 통해 필요한 데이터를 조회해야 한다.</span>
    <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span>  <span class="n">orderRepository</span><span class="o">.</span><span class="na">findById</span><span class="o">(</span><span class="n">evt</span><span class="o">.</span><span class="na">getOrderNo</span><span class="o">());</span>
    <span class="n">shippingInfoSynchronizer</span><span class="o">.</span><span class="na">sync</span><span class="o">(</span>
      <span class="n">order</span><span class="o">.</span><span class="na">getOrderNumber</span><span class="o">(),</span>
      <span class="n">order</span><span class="o">.</span><span class="na">getNewShippingInfo</span><span class="o">()</span>
    <span class="o">);</span>
  <span class="o">}</span>

  <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li><b>이벤트는 데이터를 담아야 하지만 그렇다고 이벤트 자체와 관련 없는 데이터를 포함할 필요는 없다.</b><li>배송지 정보를 변경해서 발생시킨 ShippingInfoChangedEvent 가 이벤트 발생과 직접 관련된 바뀐 배송지 정보를 포함하는 것은 맞지만, 배송지 정보 변경과 전혀 관련 없는 주문 상품번호와 개수를 담을 필요는 없다.</ul><h3 id="1023-이벤트-용도">10.2.3 이벤트 용도</h3><p><b>1) 트리거</b></p><ul><li>도메인의 상태가 바뀔때 다른 후처리가 필요하면 후처리를 실행하기 위한 트리거로 이벤트를 사용할 수 있다.<li>주문에선 주문 취소 이벤트를 트리거로 사용할 수 있다.<li>주문을 취소하면 환불을 처리해야 하는데 이때 환불 처리를 위한 트리거로 주문 취소 이벤트를 사용할 수 있다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/5c6b8460-1eae-410f-8938-2b99b3cb94f7" alt="image" /></p><ul><li>예매 결과를 SMS로 통지할때도 이벤트를 트리거로 사용할 수도 있다. 예매 도메인은 ‘예매 완료’ 이벤트를 발생시키고 이 이벤트 핸들러에선 SMS를 발송하는 방식으로 구현할 수 있다.</ul><p><b>2) 서로 다른 시스템 간의 데이터 동기화</b></p><ul><li>배송지를 변경하면 외부 배송 서비스에 바뀐 배송지 정보를 전송해야 한다.<li>주문 도메인은 배송지 변경 이벤트를 발생시키고 이벤트 핸들러는 외부 배송 서비스와 배송지 정보를 동기화할 수 있다.</ul><h3 id="1024-이벤트-장점">10.2.4 이벤트 장점</h3><p><b>1) 서로 다른 도메인 로직이 섞이는 것을 방지</b></p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/2deb0cd8-c237-4684-8d4c-36e9090e8016" alt="image" /> <em>이미지 출처: https://velog.io/@csh0034/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-10.-%EC%9D%B4%EB%B2%A4%ED%8A%B8</em></p><ul><li>위 이미지를 보면 구매 취소 로직에 이벤트를 적용함으로써 환불 로직이 없어지고 환불 서비스를 실행하기 위한 파라미터도 없어진 것을 볼 수 있다.<li>환불 실행 로직은 주문 취소 이벤트를 받는 이벤트 핸들러로 이동하게 된다.<li>이벤트를 사용하여 주문 도메인에서 결제(환불) 도메인으로의 의존을 제거했다.</ul><p><b>2) 기능 확장이 용이</b></p><ul><li>구매 취소시 환불과 함께 이메일로 취소 내용을 보내고 싶다면 이메일 발송을 처리하는 핸들러를 구현하면 된다.<li>기능을 확장해도 구매 취소 로직은 수정할 필요가 없다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/db74a7c8-ae91-48fc-af57-c639e3bc232f" alt="image" /></p><h2 id="103-이벤트-핸들러-디스패처-구현">10.3 이벤트, 핸들러, 디스패처 구현</h2><ul><li>이벤트와 관련된 코드는 다음과 같다.<ul><li>이벤트 클래스: 이벤트를 표현한다.<li>디스패처: 스프링이 제공하는 ApplicationEventPublisher 를 이용한다.<li>Events: 이벤트를 발행한다. 이벤트 발행을 위해 ApplicationEventPublisher 를 사용한다.<li>이벤트 핸들러: 이벤트를 수신해서 처리한다. 스프링이 제공하는 기능을 사용한다.</ul></ul><blockquote><p><strong>Note</strong>: 이벤트 디스패처를 직접 구현할 수도 있지만 이 책에서는 스프링이 제공하는 이벤트 관련 기능을 사용해서 이벤트 발생과 처리를 구현한다.</p></blockquote><h3 id="1031-이벤트-클래스">10.3.1 이벤트 클래스</h3><ul><li>이벤트 자체를 위한 상위 타입은 존재하지 않는다. 원하는 클래스를 이벤트로 사용하면 된다.<li>OrderCanceledEvent 와 같이 클래스 이름 뒤에 접미사로 Event 를 사용해서 이벤트로 사용하는 클래스라는 것을 명시적으로 표현할 수도 있고 OrderCanceled 처럼 간결함을 위해 과거 시제만 사용 할수도 있다.<li>이벤트 클래스는 이벤트를 처리하는데 필요한 최소한의 데이터를 포함해야 한다.<ul><li>예를 들어 주문 취소됨 이벤트는 적어도 주문번호를 포함해야 관련 핸들러에서 후속처리를 할 수 있다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderCanceledEvent</span> <span class="o">{</span>
  <span class="c1">// 이벤트는 핸들러에서 이벤트를 처리하는데 필요한 데이터를 포함한다.</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">orderNumber</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">OrderCanceledEvent</span><span class="o">(</span><span class="nc">String</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">orderNumber</span> <span class="o">=</span> <span class="n">number</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="nc">String</span> <span class="nf">getOrderNumber</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">return</span> <span class="n">orderNumber</span><span class="o">;</span>
  <span class="o">}</span>
<span class="o">}</span> 
</pre></table></code></div></div><ul><li>모든 이벤트가 공통으로 갖는 프로퍼티가 존재한다면 관련 상위 클래스를 만들 수도 있다.<ul><li>예를 들어 모든 이벤트가 발생 시간을 갖도록 하려면 다음과 같은 상위클래스를 만들고 각 이벤트 클래스가 이를 상속받도록 하면 된다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// 공통 추상 클래스</span>
<span class="kn">package</span> <span class="nn">com.myshop.common.event</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">Event</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">timestamp</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Event</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">timestamp</span> <span class="o">=</span> <span class="nc">System</span><span class="o">.</span><span class="na">currentTimeMillis</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// 발생 시간이 필요한 각 이벤트 클래스는 Event 클래스를 상속받아 구현한다.</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderCanceledEvent</span> <span class="kd">extends</span> <span class="nc">Event</span> <span class="o">{</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="n">orderNumber</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">OrderCanceledEvent</span><span class="o">(</span><span class="nc">String</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
        <span class="kd">super</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">orderNumber</span> <span class="o">=</span> <span class="n">number</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h3 id="1032-events-클래스와-applicationeventpublisher">10.3.2 Events 클래스와 ApplicationEventPublisher</h3><ul><li>이벤트 발생과 출판을 위해 스프링이 제공하는 ApplicationEventPublisher 를 사용한다.<li>스프링 컨테이너는 ApplicationEventPublisher도 된다.<ul><li><b>스프링 컨테이너는 ApplicationEventPublisher 를 상속받는 구조로 되어 있기 때문이다.</b></ul><li>Events 클래스는 ApplicationEventPublisher 를 사용해서 이벤트를 발생시키도록 구현할 것이다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Events</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="nc">ApplicationEventPublisher</span> <span class="n">publisher</span><span class="o">;</span>

    <span class="kd">static</span> <span class="kt">void</span> <span class="nf">setPublisher</span><span class="o">(</span><span class="nc">ApplicationEventPublisher</span> <span class="n">publisher</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">Events</span><span class="o">.</span><span class="na">publisher</span> <span class="o">=</span> <span class="n">publisher</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">raise</span><span class="o">(</span><span class="nc">Object</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">publisher</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">publisher</span><span class="o">.</span><span class="na">publishEvent</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>Events 클래스의 raise() 메서드는 ApplicationEventPublisher 가 제공하는 publishEvent() 메서드를 이용해서 이벤트를 발생시킨다.<li>Events 클래스가 사용할 ApplicationEventPublisher 객체는 setPublisher() 메서드를 통해서 전달받는다.<li>Events#setPublisher() 메서드에 이벤트 퍼블리셔를 전달하기 위해 스프링 설정 클래스를 아래와 같이 작성한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="nd">@Configuration</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EventsConfiguration</span> <span class="o">{</span>
    <span class="nd">@Autowired</span>
    <span class="kd">private</span> <span class="nc">ApplicationContext</span> <span class="n">applicationContext</span><span class="o">;</span>

    <span class="nd">@Bean</span>
    <span class="kd">public</span> <span class="nc">InitializingBean</span> <span class="nf">eventsInitializer</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">()</span> <span class="o">-&gt;</span> <span class="nc">Events</span><span class="o">.</span><span class="na">setPublisher</span><span class="o">(</span><span class="n">applicationContext</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>eventsInitializer() 메서드는 InitializingBean 타입 객체를 빈으로 설정한다.<ul><li>이 타입은 스프링 빈 객체를 초기화할 때 사용하는 인터페이스로, 이 기능을 사용해서 Events 클래스를 초기화했다.<li>위에서 언급한것처럼 ApplicationContext 는 ApplicationEventPublisher 를 상속하고 있으므로 Events 클래스를 초기화할 때 ApplicationContext 를 전달했다.</ul></ul><h3 id="1033-이벤트-발생과-이벤트-핸들러">10.3.3 이벤트 발생과 이벤트 핸들러</h3><ul><li>이벤트를 발생시킬 코드는 Events.raise() 메서드를 사용한다.<ul><li>예를 들어 Order#cancel() 메서드는 다음과 같이 구매 취소 로직을 수행한뒤 Events.raise() 를 이용해서 관련 이벤트를 발생시킨다.</ul></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Order</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">cancel</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">verifyNotYetShipped</span><span class="o">();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">state</span> <span class="o">=</span> <span class="nc">OrderState</span><span class="o">.</span><span class="na">CANCELED</span><span class="o">;</span>
        <span class="nc">Events</span><span class="o">.</span><span class="na">raise</span><span class="o">(</span><span class="k">new</span> <span class="nc">OrderCanceledEvent</span><span class="o">(</span><span class="n">number</span><span class="o">.</span><span class="na">getNumber</span><span class="o">()));</span>
    <span class="o">}</span>
    <span class="o">...</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>이벤트를 처리할 핸들러는 스프링이 제공하는 <code class="language-plaintext highlighter-rouge">@EventListener</code> 어노테이션을 사용해서 구현한다.<li>다음은 OrderCanceldedEvent 를 처리하기 위한 핸들러를 구현한 코드의 예다</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderCanceledEventHandler</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">RefundService</span> <span class="n">refundService</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">OrderCanceledEventHandler</span><span class="o">(</span><span class="nc">RefundService</span> <span class="n">refundService</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">refundService</span> <span class="o">=</span> <span class="n">refundService</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@EventListener</span><span class="o">(</span><span class="nc">OrderCanceledEvent</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">OrderCanceledEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">refundService</span><span class="o">.</span><span class="na">refund</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getOrderNumber</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>ApplicationEventPublisher#publishEvent() 메서드를 실행할 때 OrderCanceledEvent 타입객체를 전달하면, OrderCanceledEvent.class 값을 갖는 @EventListener 어노테이션이 붙은 메서드를 찾아 실행한다.</ul><h3 id="1034-흐름-정리">10.3.4 흐름 정리</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/8261cba6-9daf-4e4f-a726-9d47b7aab711" alt="image" /></p><ul><li>아래와 같이 방식으로 처리된다.<ul><li>1)도메인 기능을 실행한다.<li>2)도메인 기능은 Events.raise() 메서들르 이용해서 이벤트를 발생시킨다.<li>3)Events.raise() 는 스프링이 제공하는 ApplicationEventPublisher 를 이용해서 이벤트를 출판한다.<li>4)ApplicationEventPublisher 는 @EventListener(이벤트타입.class) 어노테이션이 붙은 메서드를 찾아 실행한다.</ul><li>코드 흐름을 보면 응용 서비스와 동일한 트랜잭션 범위에서 이벤트 핸들러를 실행하고 있다.<ul><li>즉, 도메인 상태 변경과 이벤트 핸들러는 같은 트랜잭션 범위에서 실행된다.</ul></ul><h2 id="104-동기-이벤트-처리-문제">10.4 동기 이벤트 처리 문제</h2><ul><li>이벤트를 사용해서 강결합 문제는 해결했지만, 외부 서비스에 영향을 받는 문제가 남아있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="c1">// 1. 응용 서비스 코드</span>
<span class="nd">@Transactional</span> <span class="c1">// 외부 연동 과정에서 익셉션이 발생하면 트랜잭션 처리는?</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">cancel</span><span class="o">(</span><span class="nc">OrderNo</span> <span class="n">orderNo</span><span class="o">)</span> <span class="o">{</span>
  <span class="nc">Order</span> <span class="n">order</span> <span class="o">=</span> <span class="n">findOrder</span><span class="o">(</span><span class="n">orderNo</span><span class="o">);</span>
  <span class="n">order</span><span class="o">.</span><span class="na">cancel</span><span class="o">();</span> <span class="c1">// OrderCanceledEvent 발생</span>
<span class="o">}</span>

<span class="c1">// 2. 이벤트를 처리하는 코드</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderCanceledEventHandler</span> <span class="o">{</span>
  <span class="o">...</span>

  <span class="nd">@EventListener</span><span class="o">(</span><span class="nc">OrderCanceledEvent</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">OrderCanceledevent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// refundService.refund()가 느려지거나 익셉션이 발생하면?</span>
    <span class="n">refundService</span><span class="o">.</span><span class="na">refund</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getOrderNumber</span><span class="o">());</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>위 코드에서 refundService.refund() 가 외부 환불 서비스와 연동한다고 가정해 보자.<ul><li>만약 외부 환불 기능이 갑자기 느려지면 cancel() 메서드도 함께 느려진다.<li><b>이것은 외부 서비스의 성능 저하가 바로 내 시스템의 성능 저하로 연결된다는 것을 의미한다.</b></ul><li>성능 저하뿐만 아니라 트랜잭션도 문제가 된다.<ul><li>refundService.refund() 에서 익셉션이 발생하면 cancel() 메서드의 트랜잭션을 롤백해야 할까? 트랜잭션을 롤백하면 구매 취소 기능을 롤백하는 것이므로 구매 취소가 실패하는 것과 같다.<li>생각해볼만한 것은 외부 환불 서비스 실행에 실패했다고 반드시 트랜잭션을 롤백해야 하는지에 대한 문제다.<li>일단 구매 취소 자체는 처리하고 환불만 재처리하거나 수동으로 처리할 수도 있다.</ul><li><b>외부 시스템과의 연동을 동기로 처리할때 발생하는 성능과 트랜잭션 범위 문제를 해소하는 방법은 이벤트를 비동기로 처리하거나 이벤트 와 트랜잭션을 연계하는 것이다.</b><ul><li>두 방법중 먼저 비동기 이벤트 처리에 대해 알아보자.</ul></ul><h2 id="105-비동기-이벤트-처리">10.5 비동기 이벤트 처리</h2><ul><li>회원 가입 신청을 하면 검증을 위해 이메일을 보내는 서비스가 많다.<ul><li>회원 가입 신청을 하자마자 바로 내 메일함에 검증 이메일이 도착할 필요는 없다.<li>이메일이 몇 초뒤에 도착해도 문제 되지 않는다.<li>10초 ~ 20초 후에 이메일이 도착해도 되고, 심지어 이메일을 받지 못하면 다시 받을 수 있는 기능을 이용하면 된다.</ul><li>비슷하게 주문을 취소하자마자 바로 결제를 취소하지 않아도 된다.<ul><li>수십초 내에 결제 취소가 이루어지면 된다. 몇칠 뒤에 결제가 확실하게 취소되면 문제없을 때도 있다.</ul><li>이렇게 ‘A 하면 이어서 B하라’ 는 내용을 담고 있는 요구사항은 실제로 ‘A 하면 최대 언제까지 B 하라’ 인 경우가 많다.<ul><li>즉, 일정 시간 안에서만 후속 조치를 처리하면 되는 경우가 적지 않다.<li>게다가 ‘A 하면 이어서 B 하라’ 는 요구사항에서 B를 하는데 실패하면 일정 간격으로 재시도를 하거나 수동 처리를 해도 상관없는 경우가 있다.<li>앞의 이메일 인증 예가 이에 해당한다.<li>회원 가입 신청 시점에서 이메일 발송을 실패하더라도 사용자는 이메일 재전송 요청을 이용하여 수동으로 인증 이메일을 다시 받아볼 수 있다.</ul><li>‘A 하면 일정 시간 안에 B하라’ 는 요구사항에서 ‘A 하면은’ 이벤트로 볼 수도 있다.<ul><li>‘회원 가입 신청을 하면 인증 이메일을 보내라’ 는 요구사항에서 ‘회원 가입 신청을 하면’ 은 ‘회원 가입 신청함 이벤트로’ 볼 수 있다.<li>따라서 ‘인증 이메일을 보내라’ 기능은 ‘회원 가입 신청함 이벤트’를 처리하는 핸들러에서 보낼 수 있다.</ul><li>앞서 말했듯 ‘A 하면 이어서 B 하라’는 요구사항 중에서 ‘A 하면 최대 언제까지 B 하라’로 바꿀 수 있는 요구사항은 이벤트를 비동기로 처리하는 방식으로 구현할 수 있다.<ul><li>다시 말해서 ‘A 이벤트가 발생하면 별도 스레드로 B를 수행하는 핸들러를 실행하는 방식으로 요구사항을 구현할 수 있다.</ul><li>이벤트를 비동기로 구현하는 방법은 다양한데, 여기선 다음 네 가지 방식으로 비동기 이벤트 처리를 구현하는 방법에 대해 알아보자.<ul><li><b>1)로컬 핸드러를 비동기로 실행하기</b><li><b>2)메시지 큐를 사용하기</b><li><b>3)이벤트 저장소와 이벤트 포워더 사용하기</b><li><b>4)이벤트 저장소와 이벤트 제공 API 사용하기</b></ul><li>네 가지 방식은 각자 구현하는 방식도 다르고 그에 따른 장단점이 있다. 각 방식에 대해 차례대로 살펴보자.</ul><h3 id="1051-로컬-핸들러-비동기-실행">10.5.1 로컬 핸들러 비동기 실행</h3><ul><li>이벤트 핸들러를 별도 스레드로 실행시키는 방법이다.<li>스프링이 제공하는 <code class="language-plaintext highlighter-rouge">@Async</code> 어노테이션을 사용하면 손쉽게 구현 가능하다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="nd">@SpringBootApplication</span>
<span class="nd">@EnableAsync</span>  <span class="c1">// 기능 활성화</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ShopApplication</span> <span class="o">{</span>

    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">SpringApplication</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="nc">ShopApplication</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">args</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// 핸들러</span>
<span class="nd">@Service</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">OrderCanceledEventHandler</span> <span class="o">{</span>

    <span class="nd">@Async</span> <span class="c1">// @Async 에너테이션 사용</span>
    <span class="nd">@EventListener</span><span class="o">(</span><span class="nc">OrderCanceledEvent</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">OrderCanceledEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">refundService</span><span class="o">.</span><span class="na">refund</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getOrderNumber</span><span class="o">());</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><h2 id="1052-메시징-시스템을-이용한-비동기-구현">10.5.2 메시징 시스템을 이용한 비동기 구현</h2><ul><li>카프카나 래빗MQ 와 같은 메시징 시스템을 사용하는 것이다.<li>처리 프로세스는 다음과 같다.<ul><li>1)이벤트가 발생하면 이벤트 디스패처는 아래 이미지와 같이 이벤트를 메시지 큐에 저장한다.<li>2)메시지 큐는 이벤트를 메시지 리스너에 전달한다.<li>3)메시지 리스너는 알맞은 이벤트 핸들러를 통해 이벤트를 처리한다.</ul><li>이때 이벤트를 메시지 큐에 저장하는 과정과 메시지 큐에서 이벤트를 읽어와 처리하는 과정은 별도 스레드나 프로세스로 처리된다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/8f6c51d2-1b5d-4879-91bd-eb91c6a181b6" alt="image" /></p><ul><li>필요하다면 이벤트를 발생시키는 도메인 기능과 메시지 큐에 이벤트를 저장하는 절차를 한 트랜잭션으로 묶어야 한다.<ul><li><b>도메인 기능을 실행한 결과를 DB에 반영하고 이 과정에서 발생한 이벤트를 메시지 큐에 저장하는 것을 같은 트랜잭션 범위에서 실행하려면 글로벌 트랜잭션이 필요하다.</b></ul><li><code class="language-plaintext highlighter-rouge">글로벌 트랜잭션</code>을 사용하면 안전하게 이벤트를 메시지 큐에 전달할 수 있는 장점이 있지만 반대로 전체 성능이 떨어지는 단점도 있다.<li>글로벌 트랜잭션을 지원하지 않는 메시징 시스템도 있다.<li>메시지 큐를 사용하면 보통 이벤트를 발생하는 주체와 이벤트 핸들러가 별도 프로세스에서 동작한다.<ul><li>이것은 이벤트 발생 JVM과 이벤트 처리 JVM이 다르다는 것을 의미한다.<li>물론 한 JVM에서 이벤트 발생 주체와 이벤트 핸들러가 메시지 큐를 이용해서 이벤트를 주고받을 수 있지만, 이는 시스템을 복잡하게 만들 뿐이다.</ul><li>래빗MQ 처럼 많이 사용되는 메시징 시스템은 글로벌 트랜잭션 지원과 함께 클러스터와 고가용성을 지원하기 때문에 안정적으로 메시지를 전달할 수 있는 장점이 있다.<ul><li>또한 다양한 개발 언어와 통신 프로토콜을 지원하고 있다.</ul><li>메시지를 전달하기 위해 많이 사용되는 것 중 또 하나가 카프카인데 글로벌 트랜잭션을 지원하지 않지만 다른 메시징 시스템에 비해 높은 성능을 보여준다.<ul><li><a href="https://medium.com/@milo.felipe/spring-boot-kafka-transactions-97a2f653b60a">여기</a><b>를 참고하면 카프카에서 제공하는 ChainedKafkaTransactionManager 를 통해 DB 트랜잭션과 카프카 트랜잭션을 묶어서 관리할 수 있다.</b></ul></ul><h2 id="1053-이벤트-저장소를-이용한-비동기-처리">10.5.3 이벤트 저장소를 이용한 비동기 처리</h2><ul><li>이벤트를 일단 DB에 저장 후 별도 프로그램을 이용해서 이벤트 핸들러에 전달하는 방법이다.</ul><h3 id="1-이벤트-포워더를-이용한-방식">1) 이벤트 포워더를 이용한 방식</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/b6353999-023a-48ab-ba90-8b781c67916f" alt="image" /></p><ul><li>이벤트 발생시 핸들러는 스토리지에 이벤트를 저장한다.<li>포워더는 주기적으로 이벤트 저장소에서 이벤트를 가져와 이벤트 핸들러를 실행한다.<li><p>포워더는 별도 스레드를 이용하므로 이벤트 발행과 처리가 비동기로 처리된다.</p><li>이 방식은 도메인의 상태와 이벤트 저장소로 동일한 DB를 사용하기에 이 둘이 로컬 트랜잭션으로 처리된다.<li>이벤트를 물리적 젖아소에 보관하기 떄문에 핸들러가 이벤트 처리에 실패할 경우 포워더는 다시 이벤트 저장소에서 이벤트를 읽어와 핸들러를 실행하면 된다.</ul><h3 id="2-이벤트를-외부에-제공하는-api-를-사용하는-방식">2) 이벤트를 외부에 제공하는 API 를 사용하는 방식</h3><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/6e87d2e7-1185-45d9-abe8-81b894c41dfa" alt="image" /></p><ul><li>포워더 방식과의 차이점은 이벤트를 전달하는 방식에 있다.<ul><li>포워더 방식은 포워더를 이용해서 이벤트를 외부에 전달한다면,<li>API 방식은 외부 핸들러가 API 서버를 통해 이벤트 목록을 가져간다.<li>포워더 방식은 이벤트를 어디까지 처리했는지 추적하는 역할이 포워더에 있다면 API 방식에선 이벤트 목록을 요구하는 외부 핸들러가 자신이 어디까지 이벤트를 처리했는지 기억해야 한다.</ul></ul><h2 id="이벤트-저장소-구현">이벤트 저장소 구현</h2><ul><li>포워더 방식과 API 방식 모두 이벤트 저장소를 사용하므로 이벤트를 저장할 저장소가 필요하다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/1f0bb114-b94b-41f8-b2f6-381b536aeca8" alt="KakaoTalk_Photo_2023-06-17-17-27-57 001" /></p><ul><li>각 구성요소는 아래와 같다.<ul><li><code class="language-plaintext highlighter-rouge">EventEntry</code> : 이벤트 저장소에 보관할 데이터이다.<li><code class="language-plaintext highlighter-rouge">EventStore</code> : 이벤트를 저장하고 조회하는 인터페이스를 제공한다.<li><code class="language-plaintext highlighter-rouge">JdbcEventStore</code> : 이벤트를 저장하고 조회하는 인터페이스를 제공한다.<li><code class="language-plaintext highlighter-rouge">EventApi</code> : REST API를 이용해서 이벤트 목록을 제공하는 컨트롤러이다.</ul></ul><h3 id="실제-구현-코드">실제 구현 코드</h3><ul><li>EventEntry 클래스를 실제 구현한 코드는 아래와 같다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EventEntry</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">Long</span> <span class="n">id</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">type</span><span class="o">;</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">contentType</span><span class="o">;</span> <span class="c1">// application.json</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">payload</span><span class="o">;</span> <span class="c1">// 실제 이벤트 페이로드</span>
  <span class="kd">private</span> <span class="kt">long</span> <span class="n">timestampe</span><span class="o">;</span>

  <span class="c1">// constructor, getter</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>EventStore 는 이벤트 객체를 직렬화해서 payload 에 저장한다.<li>이때 JSON으로 직렬화했다면 contentType 값으로 ‘application/json’ 을 갖는다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">EventStore</span> <span class="o">{</span>
  <span class="kt">void</span> <span class="nf">save</span><span class="o">(</span><span class="nc">Object</span> <span class="n">event</span><span class="o">);</span>
  <span class="nc">List</span><span class="o">&lt;</span><span class="nc">EventEntry</span><span class="o">&gt;</span> <span class="nf">get</span><span class="o">(</span><span class="kt">long</span> <span class="n">offset</span><span class="o">,</span> <span class="kt">long</span> <span class="n">limit</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li><p>이벤트는 과거에 벌어진 사건이므로 데이터가 변경되지 않기에 새로운 이벤트를 추가하는 save 메서드와 조회하는 get 메서드만 제공한다.(기존 이벤트 수정 메서드는 존재하지 않는다.)</p><li><p>EventStore 인터페이스를 구현한 JdbcEventStore 클래스는 다음과 같다.</p></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
</pre><td class="rouge-code"><pre><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">JdbcEventStore</span> <span class="kd">implements</span> <span class="nc">EventStore</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="nc">ObjectMapper</span> <span class="n">objectMapper</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">JdbcTemplate</span> <span class="n">jdbcTemplate</span><span class="o">;</span>


    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setJdbcTemplate</span><span class="o">(</span><span class="nc">JdbcTemplate</span> <span class="n">jdbcTemplate</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">jdbcTemplate</span> <span class="o">=</span> <span class="n">jdbcTemplate</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Autowired</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setObjectMapper</span><span class="o">(</span><span class="nc">ObjectMapper</span> <span class="n">objectMapper</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">objectMapper</span> <span class="o">=</span> <span class="n">objectMapper</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">save</span><span class="o">(</span><span class="nc">Object</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="nc">EventEntry</span> <span class="n">entry</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">EventEntry</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getClass</span><span class="o">().</span><span class="na">getName</span><span class="o">(),</span>
                <span class="s">"application/json"</span><span class="o">,</span> <span class="n">toJson</span><span class="o">(</span><span class="n">event</span><span class="o">));</span>
        <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">update</span><span class="o">(</span>
                <span class="s">"insert into evententry (type, content_type, payload, timestamp) values (?, ?, ?, ?)"</span><span class="o">,</span>
                <span class="n">ps</span> <span class="o">-&gt;</span> <span class="o">{</span>
                    <span class="n">ps</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">entry</span><span class="o">.</span><span class="na">getType</span><span class="o">());</span>
                    <span class="n">ps</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">entry</span><span class="o">.</span><span class="na">getContentType</span><span class="o">());</span>
                    <span class="n">ps</span><span class="o">.</span><span class="na">setString</span><span class="o">(</span><span class="mi">3</span><span class="o">,</span> <span class="n">entry</span><span class="o">.</span><span class="na">getPayload</span><span class="o">());</span>
                    <span class="n">ps</span><span class="o">.</span><span class="na">setTimestamp</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Timestamp</span><span class="o">(</span><span class="n">entry</span><span class="o">.</span><span class="na">getTimestamp</span><span class="o">()));</span>
                <span class="o">});</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="nc">String</span> <span class="nf">toJson</span><span class="o">(</span><span class="nc">Object</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">return</span> <span class="n">objectMapper</span><span class="o">.</span><span class="na">writeValueAsString</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="nc">JsonProcessingException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">throw</span> <span class="k">new</span> <span class="nf">PayloadConvertException</span><span class="o">(</span><span class="n">e</span><span class="o">);</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">EventEntry</span><span class="o">&gt;</span> <span class="nf">get</span><span class="o">(</span><span class="kt">long</span> <span class="n">offset</span><span class="o">,</span> <span class="kt">long</span> <span class="n">limit</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">query</span><span class="o">(</span><span class="s">"select * from evententry order by id asc limit ?, ?"</span><span class="o">,</span>
                <span class="n">ps</span> <span class="o">-&gt;</span> <span class="o">{</span>
                    <span class="n">ps</span><span class="o">.</span><span class="na">setLong</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="n">offset</span><span class="o">);</span>
                    <span class="n">ps</span><span class="o">.</span><span class="na">setLong</span><span class="o">(</span><span class="mi">2</span><span class="o">,</span> <span class="n">limit</span><span class="o">);</span>
                <span class="o">},</span>
                <span class="o">(</span><span class="n">rs</span><span class="o">,</span> <span class="n">rowNum</span><span class="o">)</span> <span class="o">-&gt;</span> <span class="o">{</span>
                    <span class="k">return</span> <span class="k">new</span> <span class="nf">EventEntry</span><span class="o">(</span>
                            <span class="n">rs</span><span class="o">.</span><span class="na">getLong</span><span class="o">(</span><span class="s">"id"</span><span class="o">),</span> <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"type"</span><span class="o">),</span>
                            <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"content_type"</span><span class="o">),</span> <span class="n">rs</span><span class="o">.</span><span class="na">getString</span><span class="o">(</span><span class="s">"payload"</span><span class="o">),</span>
                            <span class="n">rs</span><span class="o">.</span><span class="na">getTimestamp</span><span class="o">(</span><span class="s">"timestamp"</span><span class="o">).</span><span class="na">getTime</span><span class="o">());</span>
                <span class="o">});</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>간단한 구현이므로 스프링이 제공하는 JdbcTemplate 을 사용했다.<li>save() 메서드는 EventEntry 객체를 생성하여 저장한다.<ul><li>mysql 을 사용하여 주요키를 auto_increment 컬럼으로 지정했기에 insert 쿼리 실행시 주요키를 설정하지 않았다.</ul><li><p>get() 메서드는 MySQL의 limit 를 이용해서 id 순으로 정렬했을때 offset 파라미터로 지정한 이벤트부터 limit 개수만큼 데이터를 조회한다.</p><li>EventEntry 를 저장할 event 테이블의 ddl은 아래와 같다.</ul><div class="language-sql highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">create</span> <span class="k">table</span> <span class="n">evententry</span> <span class="p">{</span>
  <span class="n">id</span> <span class="nb">int</span> <span class="k">not</span> <span class="k">null</span> <span class="n">AUTO_INCREMENT</span> <span class="k">PRIMARY</span> <span class="k">KEY</span><span class="p">,</span>
  <span class="nv">`type`</span> <span class="n">varchart</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
  <span class="nv">`content_type`</span> <span class="n">varchart</span><span class="p">(</span><span class="mi">255</span><span class="p">),</span>
  <span class="n">payload</span> <span class="nb">MEDIUMTEXT</span><span class="p">,</span>
  <span class="nv">`timestamp`</span> <span class="nb">datetime</span><span class="p">,</span>
<span class="p">}</span> <span class="nb">character</span> <span class="k">set</span> <span class="n">utf8mb4</span>
</pre></table></code></div></div><h2 id="이벤트-저장을-위한-이벤트-핸들러-구현">이벤트 저장을 위한 이벤트 핸들러 구현</h2><ul><li>이벤트 저장소를 위한 기반이 되는 클래스는 모든 구현했고 남은 것은 발생한 이벤트를 이벤트 저장소에 추가하는 이벤트 핸들러를 구현하는 것이다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EventStoreHandler</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">EventStore</span> <span class="n">eventStore</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">EventStoreHandler</span><span class="o">(</span><span class="nc">EventStore</span> <span class="n">eventStore</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">eventStore</span> <span class="o">=</span> <span class="n">eventStore</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@EventListener</span><span class="o">(</span><span class="nc">Event</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">Event</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">eventStore</span><span class="o">.</span><span class="na">save</span><span class="o">(</span><span class="n">event</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>Event 타입을 상속받은 이벤트 타입만 이벤트 저장소에 저장하는 핸들러이다.</ul><h2 id="rest-api-구현">REST API 구현</h2><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="nd">@RestController</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EventApi</span> <span class="o">{</span>
  <span class="kd">private</span> <span class="nc">EventStore</span> <span class="n">eventStore</span><span class="o">;</span>

  <span class="nd">@Autowired</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setEventStore</span><span class="o">(</span><span class="nc">EventStore</span> <span class="n">eventStore</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">eventStore</span> <span class="o">=</span> <span class="n">eventStore</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="nd">@RequestMapping</span><span class="o">(</span><span class="n">value</span> <span class="o">=</span> <span class="s">"/api/events"</span><span class="o">,</span> <span class="n">method</span> <span class="o">=</span> <span class="nc">RequestMethod</span><span class="o">.</span><span class="na">GET</span><span class="o">)</span>
  <span class="kd">public</span> <span class="nc">List</span><span class="o">&lt;</span><span class="nc">EventEntry</span><span class="o">&gt;</span> <span class="nf">list</span><span class="o">(</span>
          <span class="nd">@RequestParam</span><span class="o">(</span><span class="s">"offset"</span><span class="o">)</span> <span class="nc">Long</span> <span class="n">offset</span><span class="o">,</span>
          <span class="nd">@RequestParam</span><span class="o">(</span><span class="s">"limit"</span><span class="o">)</span> <span class="nc">Long</span> <span class="n">limit</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">eventStore</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">offset</span><span class="o">,</span> <span class="n">limit</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>EventApi 가 처리하는 URL에 연결하면 아래와 같이 JSON 형식의 EventEntry 목록을 구할 수 있다.</ul><div class="language-json highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="p">[</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
    </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"com.myshop.eventstore.infra.SampleEvent"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"contentType"</span><span class="p">:</span><span class="w"> </span><span class="s2">"application/json"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"payload"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{</span><span class="se">\"</span><span class="s2">name</span><span class="se">\"</span><span class="s2">: </span><span class="se">\"</span><span class="s2">name1</span><span class="se">\"</span><span class="s2">, </span><span class="se">\"</span><span class="s2">value</span><span class="se">\"</span><span class="s2">: 11}"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"timestamp"</span><span class="p">:</span><span class="w"> </span><span class="mi">1641684436000</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="p">{</span><span class="w">
    </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w">
    </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"com.myshop.eventstore.infra.SampleEvent"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"contentType"</span><span class="p">:</span><span class="w"> </span><span class="s2">"application/json"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"payload"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{</span><span class="se">\"</span><span class="s2">name</span><span class="se">\"</span><span class="s2">: </span><span class="se">\"</span><span class="s2">name2</span><span class="se">\"</span><span class="s2">, </span><span class="se">\"</span><span class="s2">value</span><span class="se">\"</span><span class="s2">: 12}"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"timestamp"</span><span class="p">:</span><span class="w"> </span><span class="mi">1641684436000</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></pre></table></code></div></div><ul><li>이벤트를 수정하는 기능이 없으므로 REST API도 단순 조회 기능만 존재한다.<li><b>API를 사용하는 클라이언트는 일정 간격으로 다음 과정을 실행한다.</b><ul><li>1)가장 마지막에 처리한 데이터의 offset 인 lastOffset을 구한다. 저장한 lastOffset이 없으면 0을 사용한다.<li>2)마지막에 처리한 lastOffset 을 offset 으로 사용해서 API를 실행한다.<li>3)API 결과로 받은 데이터를 처리한다.<li>4)offset + 데이터 개수를 lastOffset 으로 저장한다.</ul><li>마지막으로 처리한 lastOffset 을 저장하는 이유는 같은 이벤트를 중복해서 처리하지 않기 위해서이다.<li>API를 사용하는 과정을 그림으로 정리하면 다음과 같다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/03bbff74-dbd5-4f03-88f2-688ae0666814" alt="KakaoTalk_Photo_2023-06-17-17-27-57 002" /></p><ul><li>클라이언트가 1분 주기로 최대 5개의 이벤트를 조회하는 상황을 정리한 것이다.<li>최초로 이벤트를 1분 시점에 조회한 이벤트가 없으므로 off은 이다.<li>1분 시점에 5개의 이벤트를 조회해서 처리했으므로 2분 시점에 요청하는 offset 은 5가된다.<li>2분 시점에 offset 5 이후로 저장된 이벤트가 3개다보니 3분 시점의 offset은8이된다.<li><p>3분 시점에 0개이벤트만 제공되므로 4분 시점에도 동일하게 offset 8로 요청한다.</p><li><b>클라이언트 API 를 이용해서 언제든지 원하는 이벤트를 가져올 수 있기 떄문에 이벤트 처리에 실패하면 다시 실패한 이벤트부터 읽어와 이벤트를 재처리할 수 있다.</b><li><b>API 서버에 장애가 발생한 경우에도 주기적으로 재시도를 해서 API 서버가 살아나면 이벤트를 처리할 수 있다.</b></ul><h2 id="포워더-구현">포워더 구현</h2><ul><li>포워더는 일정 주기로 EventStore 에서 이벤트를 읽어와 이벤트 핸들러에 전달하면 된다.<li>API 방식 클라이언트와 마찬가지로 마지막으로 전달한 이벤트의 off을 기억해두었다가 다음 조회 시점에 마지막으로 처리한 offset 부터 이벤트를 가져오면 된다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="nd">@Component</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">EventForwarder</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="no">DEFAULT_LIMIT_SIZE</span> <span class="o">=</span> <span class="mi">100</span><span class="o">;</span>

    <span class="kd">private</span> <span class="nc">EventStore</span> <span class="n">eventStore</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">OffsetStore</span> <span class="n">offsetStore</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">EventSender</span> <span class="n">eventSender</span><span class="o">;</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="n">limitSize</span> <span class="o">=</span> <span class="no">DEFAULT_LIMIT_SIZE</span><span class="o">;</span>

    <span class="nd">@Scheduled</span><span class="o">(</span><span class="n">initialDelay</span> <span class="o">=</span> <span class="mi">1000L</span><span class="o">,</span> <span class="n">fixedDelay</span> <span class="o">=</span> <span class="mi">1000L</span><span class="o">)</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">getAndSend</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">long</span> <span class="n">nextOffset</span> <span class="o">=</span> <span class="n">getNextOffset</span><span class="o">();</span>
        <span class="nc">List</span><span class="o">&lt;</span><span class="nc">EventEntry</span><span class="o">&gt;</span> <span class="n">events</span> <span class="o">=</span> <span class="n">eventStore</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">nextOffset</span><span class="o">,</span> <span class="n">limitSize</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">events</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="kt">int</span> <span class="n">processedCount</span> <span class="o">=</span> <span class="n">sendEvent</span><span class="o">(</span><span class="n">events</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">processedCount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">saveNextOffset</span><span class="o">(</span><span class="n">nextOffset</span> <span class="o">+</span> <span class="n">processedCount</span><span class="o">);</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">long</span> <span class="nf">getNextOffset</span><span class="o">()</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">offsetStore</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">int</span> <span class="nf">sendEvent</span><span class="o">(</span><span class="nc">List</span><span class="o">&lt;</span><span class="nc">EventEntry</span><span class="o">&gt;</span> <span class="n">events</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">processedCount</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="k">try</span> <span class="o">{</span>
            <span class="k">for</span> <span class="o">(</span><span class="nc">EventEntry</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">events</span><span class="o">)</span> <span class="o">{</span>
                <span class="n">eventSender</span><span class="o">.</span><span class="na">send</span><span class="o">(</span><span class="n">entry</span><span class="o">);</span>
                <span class="n">processedCount</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span> <span class="k">catch</span><span class="o">(</span><span class="nc">Exception</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
            <span class="c1">// 로깅 처리</span>
        <span class="o">}</span>
        <span class="k">return</span> <span class="n">processedCount</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">saveNextOffset</span><span class="o">(</span><span class="kt">long</span> <span class="n">nextOffset</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">offsetStore</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">nextOffset</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li><code class="language-plaintext highlighter-rouge">getAndSend()</code> 메서드를 주기적으로 실행하기 위해 스프링의 <code class="language-plaintext highlighter-rouge">@Scheduled</code> 어노테이션을 사용했다.<ul><li>스프링을 사용하지 않으면 별도 스케줄링 프레임워크를 이용해서 getAndSend() 메서드를 원하는 주기로 실행하면 된다.</ul><li>getNextOffset() 메서드와 saveNextOffset() 메서드에선 사용한 OffsetStore 인터페이스는 다음 두 메서드를 정의하고 있다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">OffsetStore</span> <span class="o">{</span>
    <span class="kt">long</span> <span class="nf">get</span><span class="o">();</span>
    <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="kt">long</span> <span class="n">nextOffset</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li><p>OffsetStore 를 구현한 클래스는 offset 값을 DB 텡니블에 저장하거나 로컬 파일에 보관해서 마지막 offset 을 물리적 저장소에 보관해야 한다.</p><li><p>실제 이벤트 발송 로직에 따르면 getAndSend() 메서드를 실행하면 마지막으로 전송에 성공한 이벤트의 다음 이벤트 부터 읽어와 전송을 시도하게 된다.(익셉션이 발생하면 전송을 멈추고 전송에 성공한 이벤트 개수를 리턴하므로)</p><li><p>EventSender 인터페이스는 다음과 같이 단순하다.</p></ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">EventSender</span> <span class="o">{</span>
    <span class="kt">void</span> <span class="nf">send</span><span class="o">(</span><span class="nc">EventEntry</span> <span class="n">event</span><span class="o">);</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>이 인터페이스를 구현한 클래스는 send() 메서드에서 외부 메시징 시스템에 이벤트를 전송하거나 원하는 핸들러에 이벤트를 전달하면 된다.<li>이벤트 처리 중에 익셉션이 발생하면 그대로 전파해서 다음 주기에 getAndSend() 메서드를 실행할 때 재처리할 수 있도록 한다.</ul><blockquote><p><strong>자동 증가 칼럼 주의사항</strong>: primary key로 자동 증가 칼럼을 사용할 때는 주의할 점이 있다. insert 쿼리 실행하는 시점에 값이 증가하지만 실제 데이터는 트랜잭션 커밋 시점에 DB에 반영된다. 즉 insert 쿼리 실행해서 자동 증가 칼럼이 증가했더라도 트랜잭션 커밋 전에 조회하면 증가한 값을 가진 레코드는 조회되지 않는다. 또한 커밋 시점에 따라 DB에 반영되는 시점이 달라질 수도 있다. 예를 들어 마지막 자동 증가 칼럼 값이 10인 상태에서 A트랜잭션이 insert 쿼리를 실행 후 B 트랜잭션이 insert 쿼리를 실행하면 A는 11, B는 12를 사용하게 된다. 그런데 B 트랜잭션 커밋 후 A 가 커밋되면 12가 DB에 먼저 반영되고 그다음 11이 반영된다. 만약 두 트랜잭션 커밋 사이에 데이터 조회시 11은 조회되지 않고 12만 조회되는 상황이 발생한다. 이런 문제가 발생하지 않도록 하려면 ID를 기준으로 데이터를 지연 조회하는 방식을 사용해야 한다. 관련 내용은 <a href="https://javacan.tistory.com/entry/MYSQL-auto-inc-col-gotcha">여기</a>를 참고하면 된다.</p></blockquote><h2 id="106-이벤트-적용-시-추가-고려사항">10.6 이벤트 적용 시 추가 고려사항</h2><ul><li>이벤트 적용 시 다음 고려사항을 생각해본다.</ul><h3 id="1-이벤트-소스를-evententry에-추가할지">1) 이벤트 소스를 EventEntry에 추가할지?</h3><ul><li>EventEntry는 이벤트 발생 주체에 대한 정보를 갖지 않는다.<li>특정 주체가 발생시킨 이벤트만 조회하는 기능을 구현할 수 없다.<li>이 기능을 구현하려면 이벤트에 발생 주체 정보를 추가해야 한다.</ul><h3 id="2-포워더에서-전송-실패를-얼마나-허용할지">2) 포워더에서 전송 실패를 얼마나 허용할지?</h3><ul><li>포워더는 이벤트 전송에 실패하면 실패한 이벤트부터 다시 읽어와 전송을 시도한다.<ul><li><b>만약? 특정 이벤트가 계속 실패한다면?</b></ul><li>실패한 이벤트의 재전송 횟수 제한을 두어야 한다.<li>실패한 이벤트는 실패용 DB나 메시지 큐에 저장한다.</ul><h3 id="3-이벤트-손실이-된다면-어떻게-할지">3) 이벤트 손실이 된다면 어떻게 할지?</h3><ul><li>이벤트 저장소를 사용하면 이벤트 발생과 이벤트 저장을 한 트랜잭션으로 처리하기 때문에 트랜잭션에 성공하면 이벤트가 저장소에 보관된다는 것을 보장할 수 있다.<li>반면 로컬 핸들러를 이용해서 이벤트를 비동기로 처리할 경우 이벤트 처리에 실패하면 이벤트를 유실하게 된다.</ul><h3 id="4-이벤트-순서는">4) 이벤트 순서는?</h3><ul><li>이벤트 발생 순서대로 외부 시스템에 전달해야 할 경우는 이벤트 저장소를 사용하는 것이 좋다.<ul><li>이벤트 저장소는 젖아소에 이벤트를 발생 순서대로 저장하고 그 순서대로 이벤트 목록을 제공하기 떄문이다</ul><li>반면 메시징 시스템은 사용 기술에 따라 이벤트 발생 순서와 메시지 순서가 다를 수 있다.</ul><h3 id="5-이벤트-재처리는">5) 이벤트 재처리는?</h3><ul><li>동일한 이벤트를 다시 처리할 때 이벤트를 어떻게 할지 결정해야 한다.<li>가장 쉬운 방법은 마지막으로 처리한 이벤트의 순번을 기억해두었다가 이미 처리한 순번의 이벤트가 도착하면 해당 이벤트를 처리하지 않고 무시하는 것이다.<ul><li>예를 들어, 회원 가입 신청 이벤트가 처음 도착하면 이메일을 발송하는데, 동일한 순번의 이벤트가 다시 들어오면 이메일을 발송하지 않는 방식으로 구현하는 것이다.</ul><li>이 외에 이벤트를 멱등으로 처리하는 방법도 있다.</ul><blockquote><p><strong>멱등성이란?</strong>: 연산을 여러번 적용해도 결과가 달라지지 않는 성질을 멱등성이라 한다. 수학에서 절대값 함수인 abs()가 멱등성을 갖는 대표적인 예이다. 어떤 x에 대해 abs() 연산을 여러 번 적용해도 결과는 동일하다. 즉, abs(x), abs(abs(x)), abs(abs(abs(x))) 는 모두 결과가 같다. 비슷하게 이벤트 처리도 동일 이벤트를 한 번 적용하나 여러 번 적용하나 시스템이 같은 상태가 되도록 핸들러를 구현할 수 있다. 예를 들어 배송지 정보 변경 이벤트를 받아서 주소를 변경하는 핸들러는 그 이벤트를 한 번 처리하나 여러 번 처리하나 결과적으로 동일 주소를 값으로 갖는다. 같은 이벤트를 여러 번 적용해도 결과가 같으므로 이 이벤트 핸들러는 멱등성을 갖는다. 이벤트 핸들러가 멱등성을 가지면 시스템 장애로 인해 같은 이벤트가 중복해서 발생해도 결과적으로 동일 상태가 된다. 이는 이벤트 중복 발생이나 중복 처리에 대한 부담을 줄여준다.</p></blockquote><h2 id="1061-이벤트-처리와-db-트랜잭션-고려">10.6.1 이벤트 처리와 DB 트랜잭션 고려</h2><ul><li>이벤트를 처리할 땐 DB 트랜잭션을 함꼐 고려해야 한다.<li>예를 들어 주문 취소와 환불 기능을 다음과 같이 이벤트를 이용해서 구현했다고 하자.<ul><li>주문 취소 기능은 주문 취소 이벤트를 발생시킨다.<li>주문 취소 이벤트 핸들러는 환불 서비스에 환불 처리를 요청한다.<li>환불 서비스는 외부 API를 호출해서 결제를 취소한다.</ul><li>이벤트 발생과 처리를 모두 동기로 처리하면 실행 흐름은 다음과 같을 것이다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/38e20159-f9a2-4dec-ba27-63c4c88d9b72" alt="KakaoTalk_Photo_2023-06-17-18-06-44 002" /></p><ul><li><b>고민할 포인트는 12번 과정까지 다 성공하고 13번 과정에서 DB를 업데이트하는데 실패하는 상황이다.</b><li><p>다 성공하고 13번 과정에서 실패하면 결제는 취소됐는데 DB에는 주문이 취소되지 않은 상태로 남게 된다.</p><li>이벤트를 비동기로 처리할 때도 DB 트랜잭션을 고려해야 한다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/60e92899-bc68-4cb7-b661-fb8e839e1483" alt="KakaoTalk_Photo_2023-06-17-18-06-43 001" /></p><ul><li>주문 쉬초 이벤트를 비동기로 처리할 때의 실행흐름이다.<li>이벤트 핸들러를 호출하는 5번 과정은 비동기로 실행한다.<li>DB 업데이트와 트랜잭션을 다 커밋한 뒤에 환불 로직인 11~13번 과정을 실행했다고 하자.<li><b>만약 12번 과정에서 외부 API 호출에 실패하면 DB 에는 주문이 취소된 상태로 데이터가 바뀌었는데 결제는 취소되지 않은 상태로 남게 된다.</b></ul><h3 id="어떻게-하면-가장-효율적으로-해결할-수-있을까">어떻게 하면 가장 효율적으로 해결할 수 있을까?</h3><ul><li>이벤트 처리를 동기로 하든 비동기로 하든 이벤트 처리 실패와 트랜잭션 실패를 함께 고려해야 한다.<li><b>트랜잭션 실패와 이벤트 처리 실패를 모두 고려하면 복잡해지므로 경우의 수를 줄이면 도움이 된다.</b><ul><li><b>경우의 수를 줄이는 방법은 트랜잭션이 성공할 때만 이벤트 핸들러를 실행하는 것이다.</b></ul><li>스프링은 <code class="language-plaintext highlighter-rouge">@TransactionalEventListener</code> 어노테이션을 지원하여 스프링 트랜잭션 상태에 따라 이벤트 핸들러를 실행할 수 있게 한다.</ul><div class="language-java highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="nd">@TransactionalEventListener</span><span class="o">(</span>
  <span class="n">classes</span> <span class="o">=</span> <span class="nc">OrderCanceledEvent</span><span class="o">.</span><span class="na">class</span><span class="o">,</span>
  <span class="n">phase</span> <span class="o">=</span> <span class="nc">TransactionPhase</span><span class="o">.</span><span class="na">AFTER_COMMIT</span>
<span class="o">)</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">handle</span><span class="o">(</span><span class="nc">OrderCanceledEvent</span> <span class="n">event</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">refundService</span><span class="o">.</span><span class="na">refund</span><span class="o">(</span><span class="n">event</span><span class="o">.</span><span class="na">getOrderNumber</span><span class="o">());</span>
<span class="o">}</span>
</pre></table></code></div></div><ul><li>위 코드에서 phase 속성 값으로 <code class="language-plaintext highlighter-rouge">TransactionPhase.AFTER_COMMIT</code> 을 지정했는데 이는 스프링이 트랜잭션 커밋에 성공한 뒤에만 핸들러를 실행하도록 한다.<ul><li>중간에 에러가 발생해서 트랜잭션이 롤백 되면 핸들러 메서드를 실행하지 않는다.<li><b>이 기능을 사용하면 이벤트 핸들러를 실행했는데 트랜잭션이 롤백되는 상황은 발생하지 않는다.</b></ul><li>이벤트 저장소로 DB를 사용해도 동일한 효과를 볼 수 있다.<ul><li>이벤트 발생 코드와 저장 처리를 한 트랜잭션으로 처리하면 된다.<li>이렇게 하면 트랜잭션 성공시에만 이벤트가 DB에 저장되므로, 트랜잭션은 실패했는데 이벤트 핸들러가 실행되는 상황은 발생하지 않게 된다.</ul><li><b>트랜잭션 성공할 때만 이벤트 핸들러를 실행하게 되면 트랜잭션 실패에 대한 경우의 수가 줄어 이제 이벤트 처리 실패만 고민하면 된다. 이벤트 특성에 따라 재처리 방식을 결정하면 된다.</b></ul><h2 id="reference-7">Reference</h2><ul><li>예제 코드 및 이미지<ul><li><a href="https://sangjaeoh.github.io/books/%EB%8F%84%EB%A9%94%EC%9D%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/#10-%EC%9D%B4%EB%B2%A4%ED%8A%B8">https://sangjaeoh.github.io/books/%EB%8F%84%EB%A9%94%EC%9D%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/#10-%EC%9D%B4%EB%B2%A4%ED%8A%B8</a></ul></ul><h1 id="chapter11-cqrs">Chapter11-CQRS</h1><h2 id="11-1-단일-모델의-단점">11. 1 단일 모델의 단점</h2><ul><li>주문 내역 조회 기능을 구현하려면 여러 애그리거트에서 데이터를 가져와야 한다.<li>Order 에서 주문 정보를 가져와야 하고, Product 에서 상품 이름을 가져와야 하고, Member 에서 회원 이름과 ID를 가져와야 한다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/2fb1ad6e-689c-4c32-b677-4902dc9a7284" alt="KakaoTalk_Photo_2023-06-17-18-43-19" /></p><ul><li>조회 화면 특성상 조회 속도가 빠를수록 좋은데 여러 애그리거트의 데이터가 필요하면 구현 방법을 고민해야 한다.<li>3장에서 언급한 식별자를 이용해서 애그리거트를 참조하는 방식을 사용하면 즉시 로딩 방식과 같은 JPA의 쿼리 관련 최적화 기능을 사용할 수 없다.<ul><li>이는 한 번의 SELECT 쿼리로 조회 화면에 필요한 데이터를 읽어올 수 없어 조회 성능에 문제가 생길 수 있다.</ul><li>애그리거트 간 연관을 식별자가 아닌 직접 참조하는 방식으로 연결해도 고민거리가 생긴다.<li>조회 화면 특성에 따라 같은 연관도 즉시 로딩이나 지연 로딩으로 처리해야 하기 때문이다.<li><p>조회 기능을 구현할 때 DBMS 가 제공하는 전용 기능이 필요하면 JPA의 네이티브 쿼리를 사용해야 할 수도 있다.</p><li>이런 고민이 발생하는 이유는 시스템 상태를 변경할 때와 조회할 때 단일 도메인 모델을 사용하기 떄문이다.<li><p>객체 지향으로 도메인 모델을 구현할 때 주로 사용하는 ORM 기법은 Order#cancel() 이나 Order#changeShippingInfo() 기능처럼 도메인 상태 변경 기능을 구현하는데는 적합하지만 주문 상세 조회 화면처럼 여러 애그리거트에서 데이터를 가져와 출력하는 기능을 구현하기엔 고려할게 많아서 구현을 복잡하게 만드는 원인이 된다.</p><li>이런 구현 복잡도를 낮추는 간단한 방법은 상태 변경을 위한 모델과 조회를 위한 모델을 분리하는 것이다.</ul><blockquote><p><strong>Note</strong>: CQRS 에 대한 내용을 저자가 영상으로도 정리한 것이 있다. <a href="https://youtu.be/xf0kXMTFJm8">유튜브 영상</a>을 함께 보면 CQRS 를 이해하는데 도움이 될 것이다.</p></blockquote><h2 id="112-cqrs">11.2 CQRS</h2><ul><li>시스템이 제공하는 기능은 크게 두 가지로 나눌 수 있다.<ul><li>하나는 상태를 변경하는 기능이다. (ex. 주문 생성, 배송지 정보 변경, 회원 암호 변경)<li>하나는 사용자 입장에서 상태 정보를 조회하는 기능이다. (ex. 주문 상세 내역 보기, 게시글 목록 보기, 회원 정보 보기, 판매 통계 보기)</ul><li>도메인 모델 관점에선 상태 변경 기능은 주로 한 애그리거트의 상태를 변경한다.<ul><li>예를 들어 주문 취소 기능과 배송지 정보 변경 기능은 한 개의 Order 애그리거트를 변경한다.</ul><li><p>반면에 조회 기능에 필요한 데이터를 표시하려면 두 개 이상의 애그리거트가 필요할 때가 많다.(앞서 살펴본 주문 상세 조회 기능이 이에 해당)</p><li><b>상태를 변경하는 범위와 상태를 조회하는 범위가 정확하게 일치하지 않기 떄문에 단일 모델로 두 종류의 기능을 구현하면 모델이 불필요하게 복잡해진다.</b><li><p><b>단일 모델을 사용할 때 발생하는 복잡도를 해결하기 위해 사용하는 방법이 바로 CQRS다.</b></p><li>CQRS 는 Command Query Responsibility Segregation 의 약자로 아래 이미지와 같이 <code class="language-plaintext highlighter-rouge">상태를 변경하는 명령 모델</code>과 <code class="language-plaintext highlighter-rouge">상태를 제공하는 조회를 위한 모델</code>을 분리하는 패턴이다.</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/278b98f7-cec5-45d1-8ec5-6005bbc3bc55" alt="image" /></p><ul><li>CQRS 는 복잡한 도메인에 적합하다.<li>도메인이 복잡할수록 명령 기능과 조회 기능이 다루는 데이터 범위에 차이가 난다.<li><b>이 두 기능을 단일 모델로 처리하면 조회 기능의 로딩 속도를 위해 모델 구현이 필요 이상으로 복잡해진다.</b><li>예를 들어, 온라인 쇼핑에서 다양한 차원에서 주문/판매 통계를 조회해야 한다고 해보자.<li>JPA 기반 단일 도메인 모델을 사용하면 통계 값을 빠르게 조회하기 위해 JPA와 관련된 다양한 성능 관련 기능을 모델에 적용해야 한다.<li><p>이런 도메인에 CQRS를 적용하면 통계를 위한 조회 모델을 별도로 만들기 때문에 조회 기능 때문에 도메인 모델이 복잡해지는 것을 막을 수 있다.</p><li>CQRS 를 사용하면 각 모델에 맞는 구현 기술을 선택할 수 있다.<ul><li>예를 들어 명령 모델은 객체 지향에 기반해서 도메인 모델을 구현하기에 적당한 JPA를 사용해서 구현하고,<li>조회 모델은 DB 테이블에서 SQL 로 데이터를 조회할 때 좋은 마이바티스를 사용해서 구현하면 된다.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/2b3c823c-3e6a-4c7e-80e2-04f00354b550" alt="image" /></p><ul><li>위 이미지를 보면 조회 모델에는 응용 서비스가 존재하지 않는다.<li>단순히 데이터를 읽어와 조회하는 기능은 응용 로직이 복잡하지 않기 떄문에 컨트롤러에서 바로 DAO를 실행해도 무방하다.<li><p>물론 데이터를 표현 영역에 전달하는 과정에서 몇 가지 로직이 필요하다면 응용 서비스를 두고 로직을 구현하면 된다.</p><li><b>아래 이미지는 명령 모델과 조회 모델의 설계 예를 보여준다.</b></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/dadbbe1b-2517-43c6-a838-29da4ab6c02e" alt="image" /></p><ul><li>상태 변경을 위한 명령 모델은 객체를 기반으로 한 도메인 모델을 이용해서 구현했다.<li>반면 조회 모델은 주문 요약 목록을 제공할 때 필요한 정보를 담고 있는 데이터 타입을 이용한다.<li><p><b>두 모델 모두 주문과 관련되어 있지만 명령 모델은 상태를 변경하는 도메인 로직을 수행하는데 초점을 맞춰 설계했고, 조회 모델은 화면 보여줄 데이터를 조회하는데 초점을 맞춰 설계했다.</b></p><li>명령 모델과 조회 모델이 같은 구현 기술을 사용할 수도 있다. 이에 대한 내용은 이미 5장에서 다룬 바 있다.<ul><li>5장에서 JPQL을 이용한 <code class="language-plaintext highlighter-rouge">동적 인스턴스 생성</code>과 <code class="language-plaintext highlighter-rouge">하이버네이트의 @Subselect</code> 를 이용하는 방법을 설명했는데, <b>여기서 동적 인스턴스로 사용할 클래스와 @Subselect 를 적용한 클래스가 조회 모델에 해당한다.</b></ul><li><b>아래 이미지처럼 명령 모델과 조회 모델이 서로 다른 데이터 저장소를 사용할 수도 있다.</b><ul><li>명령 모델은 트랜잭션을 지원하는 RDBMS를 사용하고, 조회 모델은 조회 성능이 좋은 메모리 기반 NoSQL을 사용할 수 있을 것이다.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/c0be5ddc-2dad-43b0-866a-a37691f3c0b7" alt="image" /></p><ul><li><b>두 데이터 저장소 간 데이터 동기화는 10장에서 배운 이벤트를 활용해서 처리한다.</b><li><p><b>명령 모델에서 상태를 변경하면 이에 해당하는 이벤트가 발생하고, 그 이벤트를 조회 모델에 전달해서 변경 내역을 반영하면 된다.</b></p><li><b>명령 모델과 조회 모델이 서로 다른 데이터 저장소를 사용할 경우 데이터 동기화 시점에 따라 구현 방식이 달라질 수 있다.</b><ul><li><b>명령 모델에서 데이터가 바뀌자마자 변경 내역을 바로 조회 모델에 반영해야 한다면 동기 이벤트와 글로벌 트랜잭션을 사용해서 실시간으로 동기화할 수 있다.</b><li><b>하지만 10장에서 언급한 것처럼 동기 이벤트와 글로벌 트랜잭션을 사용하면 전반적인 성능(응답 속도와 처리량)이 떨어지는 단점이 있다.</b></ul><li><b>만약 서로 다른 저장소의 데이터를 특정 시간 안에만 동기화해도 된다면 비동기로 데이터를 전송하면 된다.</b><ul><li>예를 들어, 통계 처리 목적으로 조회 전용 저장소를 구축했다고 하자.<li>통계 데이터는 수초, 수분, 또는 1시간 단위로 최근 데이터를 반영해도 문제가 되지 않을 때가 많다.<li>이런 경우라면 비동기로 데이터를 보냄으로써 데이터 동기화로 인해 명령 모델의 성능이 나빠지지 않도록 할 수 있다.</ul></ul><blockquote><p><strong>Note</strong>: CQRS 패턴을 적용하기 위해 사용해야 할 필수 기술이 따로 존재하는 것은 아니다. 5장에서 언급한 것처럼 JPA만 사용해서 명령 모델과 조회 모델을 구현할 수도 있다. 명령 모델은 JPA로 구현하고 조회 모델은 직접 SQL을 사용해서 구현할 수도 있다.</p></blockquote><h2 id="1121-웹과-cqrs">11.2.1 웹과 CQRS</h2><ul><li>일반적인 웹 서비스는 상태를 변경하는 요청보다 상태를 조회하는 요청이 많다.<ul><li>온라인 쇼핑몰을 예로 들면 주문 요청보단 카탈로그를 조회하고 상품의 상세 정보를 조회하는 요청이 비교할 수 없을 정도로 많다.<li>게시판도 한 번 등록한 게시글을 수십에서 수천 내지 수백만 조회한다.</ul><li>포털이나 대형 온라인 쇼핑몰과 같이 조회 기능 요청 비율이 월등히 높은 서비스를 만드는 개발팀은 조회 성능을 높이기 위해 다양한 기법을 사용한다.<ul><li>기본적으로 쿼리를 최적화해서 쿼리 실행 속도 자체를 높이고, 메모리에 조회 데이터를 캐싱해서 응답 속도를 높이기도 한다.<li>그리고 조회 전용 저장소를 따로 사용하기도 한다.</ul><li><b>이렇게 조회 성능을 높이기 위해 다양한 기법을 사용하는 것은 결과적으로 CQRS 를 적용하는 것과 같은 효과를 만든다.</b><ul><li><b>메모리에 캐싱하는 데이터는 DB에 보관된 데이터를 그대로 저장하기보단 화면에 맞는 모양으로 변환한 데이터를 캐싱할 때 성능에 더 유리하다.</b><li>즉, 조회 전용 모델을 캐시하는 것이다.</ul><li><p>비슷하게 조회 속도를 높이기 위해 쿼리를 최적화한다는 것은 조회 화면에 보여줄 데이터를 빠르게 읽어올 수 있도록 쿼리를 작성하는 것이다.</p><li><b>대규모 트래픽이 발생하는 웹 서비스는 알게 모르게 CQRS를 적용하게 된다.</b><ul><li><b>단지 명시적으로 명령 모델과 조회 모델을 구분하지 않을 뿐이다.</b><li><b>조회 속도를 높이기 위해 별도 처리를 하고 있따면 명싱적으로 명령 모델과 조회 모델을 구분하자.</b><li><b>이를 통해 조회 기능 떄문에 명령 모델이 복잡해지는 것을 막을 수 있고, 명령 모델에 관계없이 조회 기능에 특화된 구현 기법을 보다 쉽게 적용할 수 있다.</b></ul></ul><h2 id="1122-cqrs-장단점">11.2.2 CQRS 장단점</h2><h3 id="장점">장점</h3><ul><li><b>1) 명령 모델을 구현할 떄 도메인 자체에 집중할 수 있다.</b><ul><li>복잡한 도메인은 주로 상태 변경 로직이 복잡한데 명령 모델과 조회 모델을 구분하면 조회 성능을 위한 코드가 명령 모델에 없으므로 도메인 로직을 구현하는데 집중할 수 있다.<li>또한 명령 모델에서 조회 관련 로직이 사라져 복잡도가 낮아진다.</ul><li><b>2) 조회 성능을 향상시키는데 유리하다.</b><ul><li>조회 단위로 캐시 기술을 적용할 수 있고, 조회에 특화된 쿼리를 마음대로 사용할 수도 있다.<li>캐시뿐만 아니라 조회 전용 저장소를 사용하면 조회 처리량을 대폭 늘릴 수도 있다.<li>조회 전용 모델을 사용하기 때문에 조회 성능을 높이기 위한 코드가 명령 모델에 영향을 주지 않는다.</ul></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/fc9ae318-a469-4d5d-8855-511e7f03f712" alt="KakaoTalk_Photo_2023-06-17-20-16-48" /></p><h3 id="단점">단점</h3><ul><li><b>2) 구현해야 할 코드가 더 많다.</b><ul><li>단일 모델을 사용할 때 발생하는 복잡함 때문에 발생하는 구현 비용과 조회 전용 모델을 만들 때 발생하는 구현 비용을 따져봐야 한다.<li>도메인이 복잡하거나 대규모 트래픽이 발생하는 서비스라면 조회 전용 모델을 만드는 것이 향후 유지 보수에 유리하다.<li>반면에 도메인이 단순하거나 트래픽이 많지 않은 서비스라면 조회 전용 모델을 따로 만들때 얻을 이점이 있는지 따져봐야 한다.</ul><li><b>1) 더 많은 구현 기술이 필요하다.</b><ul><li>명령 모델과 조회 모델을 다른 구현 기술을 사용해서 구현하기도 하고 경우에 따라 다른 저장소를 사용하기도 한다.<li>또한 데이터 동기화를 위해 메시징 시스템을 도입해야 할 수도 있다.</ul></ul><p><b>위와 같은 장단점을 고려해서 CQRS 패턴을 도입할지 여부를 결정해야 한다. 도메인이 복잡하지 않은데 CQRS를 도입하면 두 모델을 유지하는 비용만 높아지고 얻을 수 있는 이점은 없다. 반면에 트래픽이 높은 서비스인데 단일 모델을 고집하면 유지 보수 비용이 오히려 높아질 수 있으므로 CQRS 도입을 고려하자.</b></p><h2 id="reference-8">Reference</h2><ul><li>예제 코드 및 이미지<ul><li><a href="https://sangjaeoh.github.io/books/%EB%8F%84%EB%A9%94%EC%9D%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/#11-cqrs">https://sangjaeoh.github.io/books/%EB%8F%84%EB%A9%94%EC%9D%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/#11-cqrs</a></ul></ul></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/%EC%B1%85/'>책</a>, <a href='/categories/%E1%84%83%E1%85%A9%E1%84%86%E1%85%A6%E1%84%8B%E1%85%B5%E1%86%AB%E1%84%8C%E1%85%AE%E1%84%83%E1%85%A9%E1%84%80%E1%85%A2%E1%84%87%E1%85%A1%E1%86%AF%E1%84%89%E1%85%B5%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%92%E1%85%A1%E1%84%80%E1%85%B5/'>도메인주도개발시작하기</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/ddd/" class="post-tag no-text-decoration" >ddd</a> <a href="/tags/dddstart/" class="post-tag no-text-decoration" >dddstart</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=도메인 주도 개발 시작하기 내용 정리 - Youngho's Devlog&url=https://jeonyoungho.github.io/posts/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=도메인 주도 개발 시작하기 내용 정리 - Youngho's Devlog&u=https://jeonyoungho.github.io/posts/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=도메인 주도 개발 시작하기 내용 정리 - Youngho's Devlog&url=https://jeonyoungho.github.io/posts/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5958719204143086" data-ad-slot="1982371670" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <ins class="adsbygoogle" style="display:block" data-ad-format="autorelaxed" data-ad-client="ca-pub-5958719204143086" data-ad-slot="5918543412"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <script src="https://utteranc.es/client.js" repo="jeonyoungho/jeonyoungho.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async> </script></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Kafka-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%A0%84%EB%8B%AC-%EB%B3%B4%EC%9E%A5-%EB%B0%A9%EC%8B%9D/">Kafka 메시지 전달 보장 방식</a><li><a href="/posts/Transactional-Outbox-%ED%8C%A8%ED%84%B4/">Transactional Outbox 패턴</a><li><a href="/posts/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%A1%B0%EA%B0%81%ED%99%94/">데이터베이스 인덱스 조각화(Fragmentation)</a><li><a href="/posts/Kafka-DeadLetter-%EA%B4%80%EB%A6%AC/">Kafka DeadLetter 관리</a><li><a href="/posts/Redis-%ED%8A%B9%EC%A7%95/">Redis 특징</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/jpa/">jpa</a> <a class="post-tag" href="/tags/effectivejava/">effectivejava</a> <a class="post-tag" href="/tags/react/">react</a> <a class="post-tag" href="/tags/frontend/">frontend</a> <a class="post-tag" href="/tags/es6/">es6</a> <a class="post-tag" href="/tags/velopert/">velopert</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/poiemaweb/">poiemaweb</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C13-clone-%EC%9E%AC%EC%A0%95%EC%9D%98%EB%8A%94-%EC%A3%BC%EC%9D%98%ED%95%B4%EC%84%9C-%EC%A7%84%ED%96%89%ED%95%98%EB%9D%BC/"><div class="card-body"> <span class="timeago small" > Jun 14, 2022 <i class="unloaded">2022-06-14T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[이펙티브자바] 아이템13-clone 재정의는 주의해서 진행하라</h3><div class="text-muted small"><p> Cloneable 인터페이스를 구현하는 모든 클래스는 clone을 재정의해야 한다 이때 접근 제한자는 public으로, 반환 타입은 클래스 자신으로 변경한다. 이 메서드는 가장 먼저 super.clone을 호출한 후 필요한 필드를 전부 적절히 수정한다. 일반적으로 이 말은 그 객체의 내부 깊은 구조에 숨어 있는 모든 가변 객체를 복사하고,...</p></div></div></a></div><div class="card"> <a href="/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C14-Comparable%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%A0%EC%A7%80-%EA%B3%A0%EB%A0%A4%ED%95%98%EB%9D%BC/"><div class="card-body"> <span class="timeago small" > Jun 17, 2022 <i class="unloaded">2022-06-17T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[이펙티브자바] 아이템14-Comparable을 구현할지 고려하라</h3><div class="text-muted small"><p> Comparable 인터페이스란? Comparable 인터페이스는 객체를 정렬하는데 사용되는 메서드인 compareTo를 정의하고 있다. Comparable 인터페이스를 구현한 클래스는 반드시 compareTo를 정의해야 한다. Comparable 인터페이스 특징 자바에서 같은 타입의 인스턴스를 비교해야만 하는 클래스들은 모두 Com...</p></div></div></a></div><div class="card"> <a href="/posts/%EC%9D%B4%ED%8E%99%ED%8B%B0%EB%B8%8C%EC%9E%90%EB%B0%94-%EC%95%84%EC%9D%B4%ED%85%9C15-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%99%80-%EB%A9%A4%EB%B2%84%EC%9D%98-%EC%A0%91%EA%B7%BC-%EA%B6%8C%ED%95%9C%EC%9D%84-%EC%B5%9C%EC%86%8C%ED%99%94%ED%95%98%EB%9D%BC/"><div class="card-body"> <span class="timeago small" > Jul 11, 2022 <i class="unloaded">2022-07-11T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[이펙티브자바] 아이템15-클래스와 멤버의 접근 권한을 최소화하라</h3><div class="text-muted small"><p> 컴포넌트 설계 어설프게 설계된 컴포넌트와 잘 설계된 컴포넌트의 가장 큰 차이는 바로 클래스의 내부 데이터와 구현 정보를 외부 컴포넌트로부터 얼마나 잘 숨겼느냐이다. 잘 설계된 컴포넌트는 모든 내부 구현을 완벽히 숨겨, 구현과 API를 깔끔히 분리한다. 오직 API를 통해서만 다른 컴포넌트와 소통하며 서로의 내부 동작 방식에는 전혀 개의치 않는...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/%ED%81%B4%EB%A6%B0%EC%BD%94%EB%93%9C-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC/" class="btn btn-outline-primary" prompt="Older"><p>클린코드 내용 정리</p></a> <a href="/posts/%EC%9D%BD%EC%9C%BC%EB%A9%B4-%EC%9C%A0%EC%9A%A9%ED%95%9C-Architecture-%EC%B9%BC%EB%9F%BC-%EB%AA%A8%EC%9D%8C/" class="btn btn-outline-primary" prompt="Newer"><p>읽으면 유용한 Architecture 칼럼 모음</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/jeonyoungho_o">jeonyoungho</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/jpa/">jpa</a> <a class="post-tag" href="/tags/effectivejava/">effectivejava</a> <a class="post-tag" href="/tags/react/">react</a> <a class="post-tag" href="/tags/frontend/">frontend</a> <a class="post-tag" href="/tags/es6/">es6</a> <a class="post-tag" href="/tags/velopert/">velopert</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/poiemaweb/">poiemaweb</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://jeonyoungho.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
