<!DOCTYPE html><html lang="ko" mode="light" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="[자바 ORM 표준 JPA 프로그래밍-기본편] SQL 중심적인 개발의 문제점" /><meta name="author" content="jeonyoungho" /><meta property="og:locale" content="ko" /><meta name="description" content="본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다." /><meta property="og:description" content="본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다." /><link rel="canonical" href="https://jeonyoungho.github.io/posts/2SQL-%EC%A4%91%EC%8B%AC%EC%A0%81%EC%9D%B8-%EA%B0%9C%EB%B0%9C%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/" /><meta property="og:url" content="https://jeonyoungho.github.io/posts/2SQL-%EC%A4%91%EC%8B%AC%EC%A0%81%EC%9D%B8-%EA%B0%9C%EB%B0%9C%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/" /><meta property="og:site_name" content="Youngho’s Devlog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-10-22T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[자바 ORM 표준 JPA 프로그래밍-기본편] SQL 중심적인 개발의 문제점" /><meta name="twitter:site" content="@jeonyoungho_o" /><meta name="twitter:creator" content="@jeonyoungho" /><meta name="google-site-verification" content="eonGeSiIVfF48EnFoJqakC7h2hUzgqxFNJaxkfPiGr0" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"jeonyoungho"},"dateModified":"2021-10-22T00:00:00+09:00","datePublished":"2021-10-22T00:00:00+09:00","description":"본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다.","headline":"[자바 ORM 표준 JPA 프로그래밍-기본편] SQL 중심적인 개발의 문제점","mainEntityOfPage":{"@type":"WebPage","@id":"https://jeonyoungho.github.io/posts/2SQL-%EC%A4%91%EC%8B%AC%EC%A0%81%EC%9D%B8-%EA%B0%9C%EB%B0%9C%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/"},"url":"https://jeonyoungho.github.io/posts/2SQL-%EC%A4%91%EC%8B%AC%EC%A0%81%EC%9D%B8-%EA%B0%9C%EB%B0%9C%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/"}</script><title>[자바 ORM 표준 JPA 프로그래밍-기본편] SQL 중심적인 개발의 문제점 | Youngho's Devlog</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="Youngho's Devlog"><meta name="application-name" content="Youngho's Devlog"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script async src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=G-RF6ZGDWXV1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'G-RF6ZGDWXV1'); }); </script> <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5958719204143086" crossorigin="anonymous"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/youngho_employee_pic.jpg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Youngho's Devlog</a></div><div class="site-subtitle font-italic">curios developer</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/jeonyoungho" aria-label="github" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/jeonyoungho_o" aria-label="twitter" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['yhjun1000','gmail.com'].join('@')" aria-label="email" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" > <i class="fas fa-rss"></i> </a></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Posts </a> </span> <span>[자바 ORM 표준 JPA 프로그래밍-기본편] SQL 중심적인 개발의 문제점</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"> <ins class="adsbygoogle" style="display:block; margin-top: 30px;" data-ad-client="ca-pub-5958719204143086" data-ad-slot="1982371670" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[자바 ORM 표준 JPA 프로그래밍-기본편] SQL 중심적인 개발의 문제점</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> jeonyoungho </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Fri, Oct 22, 2021, 12:00 AM +0900" prep="on" > Oct 22, 2021 <i class="unloaded">2021-10-22T00:00:00+09:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2224 words">12 min</span></div></div><div class="post-content"><p>본 포스팅은 인프러의 <a href="https://www.inflearn.com/course/ORM-JPA-Basic#">JPA 기본편</a>을 수강하고 정리하는 내용입니다.</p><hr /><p>대부분의 기업들은 객체 지향 언어(java, scala)를 사용한다. 또한 DB로는 관계형 DB를 많이 사용하고 있다. 그래서 지금 시대는 객체를 관계형 DB에 관리하는 시대이다.</p><p>문제는 애플리케이션은 객체 지향 개발하면서 하는데 딱 코드를 까보면 SQL만 천지이다.</p><p>결국엔 SQL 중심적인 개발이 되게 많은 문제점을 야기한다.</p><h1 id="1-무한-반복-지루한-코드">1. 무한 반복, 지루한 코드</h1><ul><li>CRUD 쿼리 무한 반복해야됨, 테이블이 10개면 10개를 다해줘야해서 생산성이 저하되고 힘듬(객체에 필드가 추가되면 쿼리들에 하나씩 일일이 다 추가해줘야함)</ul><h1 id="2-패러다임의-불일치객체-지향-vs-관계형-데이터베이스">2. 패러다임의 불일치(객체 지향 vs 관계형 데이터베이스)</h1><ul><li>관계형 DB는 데이터를 정교화해서 저장하는게 목표이고, 객체는 필드나 메서드 같은게 묶여서 캡슐화해서 쓰는게 목표이다.<li>이처럼 이 둘의 패러다임이 안맞기에 여러 가지 문제가 생기게 된다.<li>RDB가 인식할 수 있는 것은 SQL뿐이기 때문에 결국, Object를 SQL로 짜야한다.<ul><li>객체 -&gt; <code class="language-plaintext highlighter-rouge">SQL 변환</code> -&gt; RDB에 저장<li><code class="language-plaintext highlighter-rouge">개발자 == SQL 매퍼</code> 라고 할만큼 SQL 작업을 너무 많이 하고 있다.</ul></ul><h1 id="3-객체와-관계형-데이터베이스의-차이">3. 객체와 관계형 데이터베이스의 차이</h1><h2 id="1-상속">1) 상속</h2><p>객체에는 상속 관계가 있지만, 관계형 DB에는 상속 관계가 없다. (유사한게 있긴 함)</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/138618495-15f34690-6c20-4c0a-a232-5f798a4d2a66.png" alt="image" /></p><p>객체의 상속 관계와 유사한 모델이 RDB의 슈퍼타입 서브타입 관계이다. Album을 DB에 저장한다하면 ITEM테이블 삽입 sql, ALBUM테이블 삽입 sql 총 2개를 작성해야 한다. 만약 Album을 조회한다하면 조인으로 Album 테이블과 ITEM테이블을 조회해서 나온 결과 값을 일일이 Album 객체와 Item 객체에 일일이 필드 값을 넣어줘야 한다. 이러한 문제로 개발자는 SQL 매핑 작업을 한땀 한땀 하다보면 생산성이 저하되게 되며 실수할 가능성도 높아지게 된다.</p><h3 id="자바-컬렉션에-저장한다면">자바 컬렉션에 저장한다면?</h3><p>조회시 단순하게</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>list.add(album);
</pre></table></code></div></div><h3 id="자바-컬렉션에-조회한다면">자바 컬렉션에 조회한다면?</h3><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Album album = list.get(albumId);
</pre></table></code></div></div><p>부모 타입으로 조회 후 다형성 활용</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>Item item = list.get(albumId);
</pre></table></code></div></div><h2 id="2-연관관계">2) 연관관계</h2><p>객체는 레퍼런스를 가질 수 있지만, RDB는 PK, FK를 사용하여 join을 사용해야한다.</p><ul><li>객체는 <code class="language-plaintext highlighter-rouge">참조</code> 를 사용: member.getTeam()<li>테이블은 <code class="language-plaintext highlighter-rouge">외래 키</code> 를 사용: JOIN ON M.TEAM_ID = T.TEAM_ID</ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/138618814-09c79783-34f1-482b-b518-9444f7d5e12d.png" alt="image" /></p><ul><li>Object<ul><li>참조(Reference)를 사용하여 연관 관계를 찾는다.<code class="language-plaintext highlighter-rouge">(Member.getTeam())</code><li>양뱡향 참조 할 수 없다. (Member에서 Team으로 참조가능하지만, Team에서 Member로는 불가능하다)</ul><li>RDB<ul><li>외래키(FK)를 사용하여 Join 쿼리를 통해 연관 관계를 찾는다.<code class="language-plaintext highlighter-rouge">(JOIN ON M.TEAM_ID = T.TEAM_ID)</code><li>양방향 참조 가능하다.(테이블은 Team에서 Member로도 fk로 join을 통해 참조가능하다)</ul></ul><h2 id="3-데이터-타입">3) 데이터 타입</h2><h2 id="4-데이터-식별-방법">4) 데이터 식별 방법</h2><h1 id="4-모델링-과정에서의-문제">4. 모델링 과정에서의 문제</h1><h2 id="객체를-테이블에-맞추어-모델링">객체를 테이블에 맞추어 모델링</h2><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>class Member { 
    String id;       // MEMBER_ID 컬럼 사용
    Long teamId;     // TEAM_ID FK 컬럼 사용 //**
    String username; // USERNAME 컬럼 사용
}
class Team { 
    Long id;         // TEAM_ID PK 사용
    String name;     // NAME 컬럼 사용
}
</pre></table></code></div></div><p>MEMBER.TEAM_ID에 해당하는 FK를 그대로 필드에 추가한다.<code class="language-plaintext highlighter-rouge">(Long teamId)</code> 이렇게 설계된 객체를 DB에 저장 하려면 아래와 같이 쿼리를 작성해야한다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>INSERT INTO MEMBER(MEMBER_ID, TEAM_ID, USERNAME) VALUES ...
</pre></table></code></div></div><p><b>하지만 이는 객체지향스럽지 않다는 문제가 존재한다.</b> Team 객체의 참조값 자체가 필드에 들어가는 것이 더 객체지향스럽다고 할 수 있다.</p><h2 id="객체지향스러운-모델링">객체지향스러운 모델링</h2><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre>class Member { 
    String id;        // MEMBER_ID 컬럼 사용 
    Team team;        // 참조로 연관관계를 맺는다. //** 
    String username;  // USERNAME 컬럼 사용 
                     
    Team getTeam() { 
        return team; 
    } 
}
class Team { 
    Long id;         // TEAM_ID PK 사용 
    String name;     // NAME 컬럼 사용 
}
</pre></table></code></div></div><p>Team 객체의 참조값 자체를 필드에 넣는다.<code class="language-plaintext highlighter-rouge">(Team team;)</code> 이렇게 설계된 객체를 DB에 저장하려면 아래의 insert 쿼리를 작성해야 한다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>INSERT INTO MEMBER(MEMBER_ID, TEAM_ID, USERNAME) VALUES ...
</pre></table></code></div></div><p>여기서 TEAM_ID를 얻으려면 member.getTeam().getId()로 값을 얻어와야 한다. <b>하지만 이렇게 객체지향적으로 설계하면 조회할 때 문제가 생긴다.</b></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>SELECT M.*, T.*
FROM MEMBER M
JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID

public Member find(String memberId) {
  //SQL 실행 ...
  Member member = new Member();
  //데이터베이스에서 조회한 회원 관련 정보를 모두 입력
  Team team = new Team();
  //데이터베이스에서 조회한 팀 관련 정보를 모두 입력
  //회원과 팀 관계 설정
  member.setTeam(team); //**
  return member;
}
</pre></table></code></div></div><p>Member랑 Team을 조인하여 조회한 다음에 값을 일일이 설정해주고나서 반환해 줘야한다. <code class="language-plaintext highlighter-rouge">이러한 과정들은 너무 번거롭다.</code> 만약 자바 컬렉션에서 관리한다면 과정들이 단순해진다.</p><h2 id="객체-모델링-자바-컬렉션에-관리">객체 모델링, 자바 컬렉션에 관리</h2><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>list.add(member);
Member member = list.get(memberId);
Team team = member.getTeam();
</pre></table></code></div></div><ul><li>단순하게 list에 add로 저장하고, get으로 조회하고 코드 한줄로 해결가능하다.</ul><h1 id="5-객체-그래프-탐색">5. 객체 그래프 탐색</h1><p>객체는 <code class="language-plaintext highlighter-rouge">자유롭게 객체 그래프를 탐색</code> 할 수 있어야 한다.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://user-images.githubusercontent.com/44339530/138619731-f9a63426-8eb9-4b80-bf5c-fc0082e96f82.png" alt="image" /></p><p><b>하지만 여기서 문제는 처음 실행하는 SQL에 따라 탐색 범위가 결정되는 문제가 발생한다.</b> 예를 들어, 아래 조회 쿼리를 작성 후 getTeam() 메서드를 통해 Team객체를 조회하는 것은 가능하지만 Order 객체를 조회하는 것은 불가능하다. (처음 SQL 실행 할 때 Member랑 Team만 조회해서 가져오기 때문에)</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>SELECT M.*, T.*
FROM MEMBER M
JOIN TEAM T ON M.TEAM_ID = T.TEAM_ID

member.getTeam(); //OK
member.getOrder(); //null
</pre></table></code></div></div><p>위와 같은 문제는 <code class="language-plaintext highlighter-rouge">엔티티 신뢰 문제</code> 를 야기한다.</p><h2 id="엔티티-신뢰-문제">엔티티 신뢰 문제</h2><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>class MemberService {
  ...
  public void process() {
    Member member = memberDAO.find(memberId);
    member.getTeam(); //???
    member.getOrder().getDelivery(); // ???
  }
}
</pre></table></code></div></div><p>memberDAO에서 어떤 쿼리를 날렸는지 알 수 없는 이상 자유롭게 getTeam(), getOrder()와 같은 메서드를 사용할 수 없다. 즉 신뢰성이 떨어진다.</p><p><b>그렇다고 해서 모든 객체를 미리 로딩할 수도 없다. 상황에 따라 동일한 회원 조회 메서드를 여러벌 생성해야한다.</b></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>memberDAO.getMember(); //Member만 조회
memberDAO.getMemberWithTeam();//Member와 Team 조회
memberDAO.getMemberWithOrderWithDelivery(); // //Member, Order, Delivery 전부 조회
</pre></table></code></div></div><p>이렇게 SQL을 직접 다루면 <b>계층형 아키텍처(Layered 아키텍처)에서 진정한 의미의 계층 분할이 어렵다.</b> 물리적으로는 계층이 나누어져 있지만, 논리적으로는 굉장히 강결합되어 있다.</p><h1 id="6-비교하기에서의-차이">6. 비교하기에서의 차이</h1><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>String memberId = "100";
Member member1 = memberDAO.getMember(memberId);
Member member2 = memberDAO.getMember(memberId);
member1 == member2; //다르다.
</pre></table></code></div></div><p>식별자가 똑같아도 getMember를 통해 조회한 두 member1과 member2는 다르다. 왜냐하면 아래 MemberDAO클래스의 getMember() 메소드에서 매번 new로 객체를 생성하기 때문이다.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre>class MemberDAO {
  public Member getMember(String memberId) {
    String sql = "SELECT * FROM MEMBER WHERE MEMBER_ID = ?";
    ...
    //JDBC API, SQL 실행
    return new Member(...);
  }
}
</pre></table></code></div></div><p>만약 <code class="language-plaintext highlighter-rouge">자바 컬렉션에서 조회</code> 한다고 해보자.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre>String memberId = "100";
Member member1 = list.get(memberId);
Member member2 = list.get(memberId);
member1 == member2; //같다.
</pre></table></code></div></div><p>식별자가 같을 때 컬렉션에서의 두 객체의 참조값은 같기 때문에 두 객체는 같다.</p><h1 id="정리">정리</h1><p>객체답게 모델링 할 수록 매핑 작업만 늘어나고 더 힘들어진다. 내가 객체지향적인 것을 배우고 이처럼 설계할 수록 훨씬 번잡해지게 된다.</p><p>그래서 객체를 자바 컬렉션에 저장 하듯이 DB에 저장하고 불러올 수 있는 방법이 없을까를 고민해왔고 그 고민의 결과가 <code class="language-plaintext highlighter-rouge">JPA</code> 이다.</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/backend/'>Backend</a>, <a href='/categories/jpa/'>JPA</a>, <a href='/categories/%EC%9D%B8%ED%94%84%EB%9F%B0jpa-%EA%B8%B0%EB%B3%B8%ED%8E%B8/'>인프런JPA-기본편</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/java/" class="post-tag no-text-decoration" >java</a> <a href="/tags/spring/" class="post-tag no-text-decoration" >spring</a> <a href="/tags/jpa/" class="post-tag no-text-decoration" >jpa</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[자바 ORM 표준 JPA 프로그래밍-기본편] SQL 중심적인 개발의 문제점 - Youngho's Devlog&url=https://jeonyoungho.github.io/posts/2SQL-%EC%A4%91%EC%8B%AC%EC%A0%81%EC%9D%B8-%EA%B0%9C%EB%B0%9C%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[자바 ORM 표준 JPA 프로그래밍-기본편] SQL 중심적인 개발의 문제점 - Youngho's Devlog&u=https://jeonyoungho.github.io/posts/2SQL-%EC%A4%91%EC%8B%AC%EC%A0%81%EC%9D%B8-%EA%B0%9C%EB%B0%9C%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[자바 ORM 표준 JPA 프로그래밍-기본편] SQL 중심적인 개발의 문제점 - Youngho's Devlog&url=https://jeonyoungho.github.io/posts/2SQL-%EC%A4%91%EC%8B%AC%EC%A0%81%EC%9D%B8-%EA%B0%9C%EB%B0%9C%EC%9D%98-%EB%AC%B8%EC%A0%9C%EC%A0%90/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-5958719204143086" data-ad-slot="1982371670" data-ad-format="auto" data-full-width-responsive="true"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <ins class="adsbygoogle" style="display:block" data-ad-format="autorelaxed" data-ad-client="ca-pub-5958719204143086" data-ad-slot="5918543412"></ins> <script> (adsbygoogle = window.adsbygoogle || []).push({}); </script> <script src="https://utteranc.es/client.js" repo="jeonyoungho/jeonyoungho.github.io" issue-term="pathname" theme="github-light" crossorigin="anonymous" async> </script></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Kafka-%EB%A9%94%EC%8B%9C%EC%A7%80-%EC%A0%84%EB%8B%AC-%EB%B3%B4%EC%9E%A5-%EB%B0%A9%EC%8B%9D/">Kafka 메시지 전달 보장 방식</a><li><a href="/posts/Transactional-Outbox-%ED%8C%A8%ED%84%B4/">Transactional Outbox 패턴</a><li><a href="/posts/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%A1%B0%EA%B0%81%ED%99%94/">데이터베이스 인덱스 조각화(Fragmentation)</a><li><a href="/posts/Kafka-DeadLetter-%EA%B4%80%EB%A6%AC/">Kafka DeadLetter 관리</a><li><a href="/posts/Redis-%ED%8A%B9%EC%A7%95/">Redis 특징</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/jpa/">jpa</a> <a class="post-tag" href="/tags/effectivejava/">effectivejava</a> <a class="post-tag" href="/tags/react/">react</a> <a class="post-tag" href="/tags/frontend/">frontend</a> <a class="post-tag" href="/tags/es6/">es6</a> <a class="post-tag" href="/tags/velopert/">velopert</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/poiemaweb/">poiemaweb</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/1%EA%B0%95%EC%A2%8C-%EC%86%8C%EA%B0%9C/"><div class="card-body"> <span class="timeago small" > Oct 22, 2021 <i class="unloaded">2021-10-22T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[자바 ORM 표준 JPA 프로그래밍-기본편] 강좌 소개</h3><div class="text-muted small"><p> 본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다. JPA? - Java Persistance API Jdbc -&gt; MyBatis, JdbcTemplate -&gt; JPA 과거에는 JdbcTemplate이나 MyBatis를 통해 sql을 한땀한땀 작성하여 개발을 했으나 이는 개발 생산성이 뒤떨어진다. JPA를 사용하면 ...</p></div></div></a></div><div class="card"> <a href="/posts/3JPA-%EC%86%8C%EA%B0%9C/"><div class="card-body"> <span class="timeago small" > Oct 25, 2021 <i class="unloaded">2021-10-25T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[자바 ORM 표준 JPA 프로그래밍-기본편] JPA 소개</h3><div class="text-muted small"><p> 본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다. JPA란? Java Persistence API의 준말 자바 진영의 ORM 기술 표준 ORM이란? Object-relational mapping(객체 관계 매핑) 객체는 객체대로 설계 관계형 데이터베이스는 관계형 데이터베이스대로 설...</p></div></div></a></div><div class="card"> <a href="/posts/4%EC%98%81%EC%86%8D%EC%84%9D-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8/"><div class="card-body"> <span class="timeago small" > Oct 25, 2021 <i class="unloaded">2021-10-25T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[자바 ORM 표준 JPA 프로그래밍-기본편] 영속성 컨텍스트</h3><div class="text-muted small"><p> 본 포스팅은 인프러의 JPA 기본편을 수강하고 정리하는 내용입니다. JPA에서 가장 중요한 2가지 객체와 관게형 데이터베이스 매핑하기(Object Relational mapping) DB를 어떻게 설계하고 객체를 어떻게 설계해서 중간에 어떻게 JPA로 매핑해서 쓸건지 영속성 컨텍스트 ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/1%EA%B0%95%EC%A2%8C-%EC%86%8C%EA%B0%9C/" class="btn btn-outline-primary" prompt="Older"><p>[자바 ORM 표준 JPA 프로그래밍-기본편] 강좌 소개</p></a> <a href="/posts/3JPA-%EC%86%8C%EA%B0%9C/" class="btn btn-outline-primary" prompt="Newer"><p>[자바 ORM 표준 JPA 프로그래밍-기본편] JPA 소개</p></a></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/jeonyoungho_o">jeonyoungho</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/java/">java</a> <a class="post-tag" href="/tags/spring/">spring</a> <a class="post-tag" href="/tags/jpa/">jpa</a> <a class="post-tag" href="/tags/effectivejava/">effectivejava</a> <a class="post-tag" href="/tags/react/">react</a> <a class="post-tag" href="/tags/frontend/">frontend</a> <a class="post-tag" href="/tags/es6/">es6</a> <a class="post-tag" href="/tags/velopert/">velopert</a> <a class="post-tag" href="/tags/javascript/">javascript</a> <a class="post-tag" href="/tags/poiemaweb/">poiemaweb</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://jeonyoungho.github.io{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
