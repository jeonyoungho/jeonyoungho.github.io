---
title: "인덱스 조각화"
date: 2025-05-31 +0800
categories: [Backend, Database]
tags: [database, index]
toc: true
comments: true
published: false
---

데이터가 많은 테이블에서 쿼리 성능을 높이기 위해 주로 인덱스를 활용한다.

인덱스를 활용한다해도 데이터가 계속 쌓이다보면 쿼리 속도가 느려질 수 있다.

이와 관련된 인덱스 조각화(Fragmentation) 문제와 그 해결방법 및 이를 지연시킬 수 있는 방법에 대해 정리해보자.

# 1. 인덱스 조각화(Fragmentation)란?
MySQL(MariaDB)에서 인덱스 페이지가 비효율적으로 배치되는 현상을 말한다.

인덱스 또한 물리적인 페이지로 관리되는데 인덱스로 관리되는 데이터의 양이 많아지다보면 여러 페이지로 나뉘어 관리되게 되고 이로 인해 옵티마이저가 여러 페이지를 찾다보니 속도가 저하되게 된다.

조각화가 발생하는 주요 원인은 다음과 같다.
- INSERT(삽입): 새로운 데이터를 삽입하며 기존 페이지 공간이 부족하면 새로운 페이지가 생성됨
- UPDATE(수정): 데이터 크기가 커지면 원래 있던 페이지에 공간이 부족해지고, 일부 데이터가 다른 페이지로 이동함
- DELETE(삭제): 일부 데이터가 삭제되며 페이지에 빈 공간이 생기게 됨

조각화가 심해지면 검색 속도가 느려지고, 쿼리 성능이 저하된다.

## 1-1. 인덱스 조각화(Fragmentation) 확인 방법
MySQL에서는 `information_schema.tables` 또는 `SHOW TABLE STATUS` 명령어를 사용하여 인덱스 조각화를 확인할 수 있다.

```sql
-- 1. SHOW TABLE STATUS 명령어를 통해 확인
SHOW TABLE STATUS LIKE 'orders';

-- 2. information_schema.tables 를 통해 확인
SELECT
    table_name,
    ROUND((data_free / (data_length + index_length + data_free)) * 100, 2) AS fragmentation_percentage,
    engine,
    data_length,
    index_length,
    data_free
FROM information_schema.tables
WHERE table_schema = DATABASE() AND table_name = 'orders';
```

information_schema.tables에서 인덱스 Fragmentation 퍼센티지를 확인할때 사용하는 각 컬럼들은 다음과 같다.
- data_length: 테이블의 실제 데이터가 차지하는 바이트 수, 즉 테이블에 저장된 모든 행(row)의 데이터 크기
- index_length: 테이블의 인덱스가 차지하는 바이트 수
- data_free: 할당되었지만 사용되지 않는 바이트 수, 삭제 또는 업데이트로 인해 생긴 빈 공간

즉, 분자(data_free)는 낭비되고 있는 공간의 크기를 나타내고 분모(data_length + index_length + data_free)는 테이블이 실제로 사용하고 있는 전체 물리적인 공간을 나타내게 된다.

간단하게, data_free 값이 크면 조각화가 많이 발생한 상태라고도 볼 수 있다.

## 1-2. 인덱스 조각화 확인 실습
아래 쿼리를 실행하여 orders 테이블을 생성후 20000개의 데이터를 프로시져를 통해 삽입해보자.

```sql
CREATE TABLE orders
(
    id             INT AUTO_INCREMENT PRIMARY KEY,
    user_id        INT            NOT NULL,
    user_name      VARCHAR(200)   NOT NULL,
    product_id     INT            NOT NULL,
    order_date     DATE           NOT NULL,
    order_status   ENUM ('pending', 'confirmed', 'shipped', 'delivered', 'cancelled') DEFAULT 'pending',
    amount         DECIMAL(10, 2) NOT NULL,
    payment_method VARCHAR(20)    NOT NULL,
    created_at     TIMESTAMP                                                          DEFAULT CURRENT_TIMESTAMP,
    updated_at     TIMESTAMP                                                          DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

DROP PROCEDURE IF EXISTS InsertOrders;

DELIMITER $$

CREATE PROCEDURE InsertOrders()
BEGIN
    DECLARE i INT DEFAULT 1;
    DECLARE random_user_id INT;
    DECLARE random_user_name VARCHAR(200);
    DECLARE random_product_id INT;
    DECLARE random_order_date DATE;
    DECLARE random_order_status ENUM('pending', 'confirmed', 'shipped', 'delivered', 'cancelled');
    DECLARE random_amount DECIMAL(10, 2);
    DECLARE random_payment_method VARCHAR(20);
    DECLARE status_rand INT;
    DECLARE payment_rand INT;

    WHILE i <= 20000 DO
            -- 랜덤 값 생성
            SET random_user_id = FLOOR(1 + RAND() * 1000);  -- 1~1000 사이 user_id
            SET random_user_name = concat('Name', random_user_id);
            SET random_product_id = FLOOR(1 + RAND() * 500); -- 1~500 사이 product_id
            SET random_order_date = DATE_SUB(CURDATE(), INTERVAL FLOOR(RAND() * 365) DAY); -- 최근 1년 이내
            SET random_amount = ROUND(10 + RAND() * 990, 2); -- 10.00 ~ 1000.00 사이 금액

            -- 주문 상태 랜덤 선택
            SET status_rand = FLOOR(1 + RAND() * 5);
            CASE status_rand
                WHEN 1 THEN SET random_order_status = 'pending';
                WHEN 2 THEN SET random_order_status = 'confirmed';
                WHEN 3 THEN SET random_order_status = 'shipped';
                WHEN 4 THEN SET random_order_status = 'delivered';
                WHEN 5 THEN SET random_order_status = 'cancelled';
                END CASE;

            -- 결제 방법 랜덤 선택
            SET payment_rand = FLOOR(1 + RAND() * 4);
            CASE payment_rand
                WHEN 1 THEN SET random_payment_method = 'credit_card';
                WHEN 2 THEN SET random_payment_method = 'debit_card';
                WHEN 3 THEN SET random_payment_method = 'paypal';
                WHEN 4 THEN SET random_payment_method = 'bank_transfer';
                END CASE;

            -- 데이터 삽입
            INSERT INTO orders (user_id, user_name, product_id, order_date, order_status, amount, payment_method)
            VALUES (random_user_id, random_user_name, random_product_id, random_order_date, random_order_status, random_amount, random_payment_method);

            SET i = i + 1;
        END WHILE;
END$$

DELIMITER ;

CALL InsertOrders();
```

인덱스 조각화 퍼센티지를 확인해보면 72% 조각화 현상이 발생한 것을 확인할 수 있다.

![Image](/assets/img/posts/Backend/Database/인덱스조각화_최적화전_조각화_확인_스크린샷.png)

## 1-3. 인덱스 조각화(Fragmentation) 해결 방법
조각화가 심한 경우 OPTIMIZE TABLE(테이블 최적화) 또는 ANALYZE TABLE(인덱스 분석)을 실행하여 해결할 수 있다.

두 SQL 명령어와 관련된 더 상세한 내용은 아래 포스팅에 잘 정리되어 있다😀
- OPTIMIZE TABLE: [https://monkeybusiness.tistory.com/806](https://monkeybusiness.tistory.com/806)
- ANALYZE TABLE: [https://monkeybusiness.tistory.com/804](https://monkeybusiness.tistory.com/804)

### 테이블 최적화(OPTIMIZE TABLE)
MySQL에서는 OPTIMIZE TABLE 명령어를 실행하면 조각화를 제거하고 공간을 재사용할 수 있다.

```sql
OPTIMIZE TABLE Customer;
```

## 인덱스 분석(ANALYZE TABLE)
MySQL에서는 ANALYZE TABLE 명령어를 실행하면 인덱스를 다시 정리하고, 통계를 최신 상태로 업데이트할 수 있다.

```sql
ANALYZE TABLE Customer;
```

인덱스를 분석후 정리 및 통계 정보를 갱신하여 MySQL 옵티마이저가 쿼리 최적화를 하는데 반영시킬 수 있다.

## 1-4. 인덱스 조각화 재확인
인덱스 페이지 최적화후 다시 인덱스 Fragmentation 퍼센티지를 확인해보면 44% 로 줄어든 것을 확인할 수 있다.

![Image](/assets/img/posts/Backend/Database/인덱스조각화_최적화후_조각화_확인_스크린샷1.png)

![Image](/assets/img/posts/Backend/Database/인덱스조각화_최적화후_조각화_확인_스크린샷2.png)

Fragmentation 퍼센티지뿐만 아니라 `data_free` 값이 줄어들었다면 조각화가 해결된 것으로 볼 수 있다.

## 1-5. 정리
- MySQL에서 INSERT, UPDATE, DELETE 작업이 반복되면 인덱스 조각화가 발생함
- 조각화가 심해지면 쿼리 성능이 저하됨
- 조각화 확인은 SHOW TABLE STATUS 또는 information_schema.tables을 사용하여 수행함
- 조각화가 심하면 OPTIMIZE TABLE을 실행하여 테이블을 최적화해야 함
- 인덱스 통계를 최신 상태로 유지하려면 ANALYZE TABLE을 실행해야 함

MySQL에서 인덱스 유지보수를 정기적으로 수행하면 데이터베이스 성능을 최적화할 수 있다.

참고: [https://dev.mysql.com/doc/refman/8.4/en/sorted-index-builds.html](https://dev.mysql.com/doc/refman/8.4/en/sorted-index-builds.html)

# 2. Fill Factor란?



### Reference
- [https://osumaniaddict527.tistory.com/42#1.%20인덱스%20조각화(Fragmentation)란%3F-1](https://osumaniaddict527.tistory.com/42#1.%20인덱스%20조각화(Fragmentation)란%3F-1)
- [https://monkeybusiness.tistory.com/804](https://monkeybusiness.tistory.com/804)