---
title: "[자바 ORM 표준 JPA 프로그래밍-기본편] 값 타입 컬렉션" # post의 layout이 기본적으로 post로 설정되어있어서 Front Matter에 따로 layout변수를 만들어 주지 않아도 됨
date: 2021-10-27 +0800
categories: [JPA, Basic] # categories는 최대 2개까지 가능
tags: [java, spring, jpa] # TAG는 반드시 소문자로 이루어져야함, 0~무한개까지 지정 가능
toc: true # Table Of Content(TOC) 옵션, 기본적으로 포스트의 오른쪽 패널에 위치
comments: true # 댓글 유무 지정
# image: /assets/img/test.png # Preview image
# pin: true # 홈페이지 메인화면에 특정 게시물 고정
---

본 포스팅은 인프러의 [JPA 기본편](https://www.inflearn.com/course/ORM-JPA-Basic#)을 수강하고 정리하는 내용입니다.

<hr>

`값 타입 컬렉션`은 값 타입을 컬렉션에 담아서 쓰는 것을 말한다. 문제는 DB에 넣을때가 문제가 된다. 기본적으로 값 타입 컬렉션을 DB에 넣는 구조를 지원하지 않는다. 결론적으로 이러한 컬렉션들을 별도의 테이블로 뽑아야한다. (FAVORITE_FOOD 테이블, ADDRESS 테이블)

![image](https://user-images.githubusercontent.com/44339530/139053463-06c8bf50-bc21-4de7-830a-94cdaf35012e.png)

- <b>값 타입을 하나 이상 저장할 때 사용</b>
- `@ElementCollection`, `@CollectionTable` 사용
- 데이터베이스는 컬렉션을 같은 테이블에 저장할 수 없다.
  - DB안에 한 테이블에 컬렉션을 넣을 수 있는 방법은 없다.
- 일대다로 풀어서 컬렉션을 저장하기 위한 별도의 테이블이 필요함

~~~
@Entity
public class Member {

    @Id
    @GeneratedValue
    @Column(name = "MEMBER_ID")
    private Long id;

    @Column(name = "USERNAME")
    private String username;

    // 기간 Period
    @Embedded
    private Period workPeriod;

    // 주소
    @Embedded
    private Address homeAddress;

    @ElementCollection
    @CollectionTable(name = "FAVORITE_FOOD", joinColumns =
        @JoinColumn(name = "MEMBER_ID")
    )
    @Column(name = "FOOD_NAME")
    private Set<String> favoriteFoods = new HashSet<>();

    @ElementCollection
    @CollectionTable(name = "ADDRESS", joinColumns =
        @JoinColumn(name = "MEMBER_ID")
    )
    private List<Address> addressHistory = new ArrayList<>();

    ...
}
~~~

# 값 타입 컬렉션 사용

1) 값 타입 저장 예제

~~~
Member member = new Member();
member.setUsername("member1");
member.setHomeAddress(new Address("homeCity", "street", "1000"));
member.getFavoriteFoods().add("치킨");
member.getFavoriteFoods().add("피자");
member.getFavoriteFoods().add("족발");

member.getAddressHistory().add(new Address("old1", "street", "1000"));
member.getAddressHistory().add(new Address("old2", "street", "1000"));

em.persist(member);

tx.commit();
~~~

2) 값 타입 조회 예제
- <b>값 타입 컬렉션도 지연 로딩 전략 사용</b>
- <b>엔티티 테이블만 가져오고 값 타입 컬렉션은 프록시로 가져온다.</b>
- 나중에 실제 값 타입 객체(FAVORITE_FOOD 테이블, ADDRESS 가 호출될때 select 쿼리를 호출한다)

~~~
Member member = new Member();
member.setUsername("member1");
member.setHomeAddress(new Address("homeCity", "street", "1000"));
member.getFavoriteFoods().add("치킨");
member.getFavoriteFoods().add("피자");
member.getFavoriteFoods().add("족발");

member.getAddressHistory().add(new Address("old1", "street", "1000"));
member.getAddressHistory().add(new Address("old2", "street", "1000"));

em.persist(member);

em.flush();
em.clear();

System.out.println("===== START =====");
Member findMember = em.find(Member.class, member.getId());
List<Address> addressHistory = findMember.getAddressHistory();
for(Address address : addressHistory) {
   System.out.println("address = " + address.getCity());
}

Set<String> favoriteFoods = findMember.getFavoriteFoods();
for (String favoriteFood : favoriteFoods) {
   System.out.println("favoriteFood = " + favoriteFood);
}

tx.commit();
~~~

3) 값 타입 수정 예제


- <b>참고: 값 타입 컬렉션은 영속성 전에(Cascade) + 고아 객체 제거 기능을 필수로 가진다고 볼 수 있다.</b>
- 값 타입은 별도의 라이프 사이클을 가지지 않고 엔티티에 의존한다. 엔티티의 값을 바뀌거나 하면 자동으로 업데이트 된다. (일대다 연관관계에서 cascade all 넣고 orphan true로 넣은것이랑 같다고 보면 된다)
  
