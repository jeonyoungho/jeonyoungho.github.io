---
title: "[DDDSTART] Chatper2 아키텍처 개요 정리" # post의 layout이 기본적으로 post로 설정되어있어서 Front Matter에 따로 layout변수를 만들어 주지 않아도 됨
date: 2023-04-25 15:10:00 +0800
categories: [DDD, DDDSTART] # categories는 최대 2개까지 가능
tags: [ddd, architecture] # TAG는 반드시 소문자로 이루어져야함, 0~무한개까지 지정 가능
toc: true # Table Of Content(TOC) 옵션, 기본적으로 포스트의 오른쪽 패널에 위치
comments: true # 댓글 유무 지정
# image: /assets/img/test.png # Preview image
# pin: true # 홈페이지 메인화면에 특정 게시물 고정
---

### 네 개의 영역

![image](https://user-images.githubusercontent.com/44339530/234268594-9c085f5e-5bb9-4a05-8a34-b9948eb0ecb6.png)

#### 표현 영역
- 표현 영역(UI영역)은 사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할을 한다.
  - 표현 영역의 사용자는 웹 브라우저를 사용하는 사람일 수 도 있고, REST API 를 호출하는 외부 시스템일 수도 있다.
- 표현 영역을 통해 사용자의 요청을 전달받는 응용 영역은 시스템이 사용자에게 제공해야 할 기능을 제공한다.
  - 예를 들어, '주문 등록', '주문 취소', '상품 상세조회' 와 같은 기능을 구현한다.

#### 응용 영역
- 응용 영역은 기능을 구현하기 위해 도메인 영역의 도메인 도메인 모델을 사용한다.
- <b>응용 서비스는 로직을 직접 수행하기보단 도메인 모델에 로직 수행을 위임한다. 마치 아래 예제 코드처럼 Order 도메인 모델에 취소 처리를 위임하는 것처럼.</b>

```java
@Service
public class CancelOrderService {
    ...

    @Transactional
    public void cancel(String orderId) {
        Order order = findOrderById(orderId);
        if (order == null) {
            throw new OrderNotFoundException(orderId);
        }
        order.cancel();
    }

	...
}
```

![image](https://user-images.githubusercontent.com/44339530/234268635-6cf25196-3a46-48f5-828f-f741086b1b8e.png)

#### 도메인 영역
- 도메인 영역은 도메인 모델을 구현한다.
  - 도메인 모델은 도메인의 핵심 로직을 구현한다. (ex. 주문 도메인의 배송지 변경, 결제 완료, 주문 총액 계산과 같은)

#### 인프라스트럭처 영역
- 구현 기술에 대한 것을 다룬다.
- 예를 들어, RDBMS, MessageQueue, 몽고 DB, HBase 와의 연동을 처리한다.
- 추가적으로 SMTP를 이용한 메일 발송 기능을 구현하거나 HTTP 클라이언트를 이용해서 REST API 를 호출하는 것도 처리한다.

![image](https://user-images.githubusercontent.com/44339530/234268698-ff2e4ceb-8b22-4fe7-800e-f0c4487a6aff.png)

> 도메인, 응용, 표현 영역은 실제 구현 기술을 사용한 코드를 직접 만들지 않는다. 대신 인프라스트럭처 영역에서 제공하는 기능을 ㅅ용해서 필요한 기능을 개발한다. 예를 들어, 응용 영역에서 DB에 보관된 데이터가 필요하면 인프라스트럭처 영역의 DB 모듈을 사용해서 데이터를 읽어온다. 비슷하게 외부에 메일을 발송하려면 인프라스트럭처가 제공하는 SMTP 연동 모듈을 이용해 메일을 발송한다.

### 계층 구조 아키텍처

- 네 영역을 구성할 때 많이 사용하는 아키텍처가 [그림2.4]와 같은 계층 구조이다.
  - 도메인의 복잡도에 따라 응용과 도메인을 분리하기도 하고 합치기도 한다.

![image](https://user-images.githubusercontent.com/44339530/234274426-7259e107-79eb-40ba-a940-41d3edcf2b3e.png)

- 계층 구조는 단방향(하위 계층)으로만 의존하게 한다.
- 계층 구조를 엄격하게 적용하면 상위 계층은 바로 아래 계층에만 의존을 가져야 하지만, 구현의 편리함을 위해 계층 구조를 유옇나게 적용한다.
  - 예를 들어, 응용 계층에서 외부 시스템과의 연동을 위해 더 아래 계층인 인프라 계층에 의존하기도 한다.
- 계층 구조에 따르면 도메인과 응용 계층은 룰 엔진과 DB 연동을 위해 아래 이밎와 같이 인프라 모듈에 의존하게 된다.

![image](https://user-images.githubusercontent.com/44339530/234274386-d00a1aa5-e365-47c0-bf4d-198bb69db6b4.png)

- 여기서 짚고 넘어가야 할 것은 표현, 응용, 도메인 계층이 상세한 구현 기술을 다루는 인프라 계층에 종속된다는 점이다.
- 이때 문제가 생길 수 있는 부분이 있다.
- 도메인의 가격 계산 규칙을 정할 때 할인 금액 계산 로직이 복잡해지면 객체 지향으로 로직을 구현하는 것 보단 룰 엔진을 사용하는 것이 더 알맞을 때가 있다.
- `Drools`라는 룰 엔진을 사용해서 로직을 수행할 수 있는 인프라 스트럭처 코드이다. (Drools는 무시해도 된다.)
- 핵심은 evalute() 메서드에 값을 주면 별도 파일로 작성한 규칙을 이용해서 연산을 수행하는 코드라는 것 정도로만 이해하면 된다.

```java
// 인프라스트럭처 영역
public class DroolsRuleEngine {
 ...
 public void evalute(String sessionName, List<?> facts) {
  ...
 }
}
```

응용 영역은 가격 계산을 위해 인프라스트럭처 영역의 DroolsRuleEngine을 사용한다.

```java
// 응용 영역
public class CalculateDiscountService {
 
 private DroolsRuleEngine ruleEngine;

 public CalculateDiscountService() {
	ruleEngine = new DroolsRuleEngine();
 }

 public Money calculateDiscount(OrderLine orderLines, String customerId) {
  Customer customer = findCusotmer(customerId);

  MutableMoney money = new MutableMoney(0);
  List<?> facts = Arrays.asList(customer, money);
  facts.addAll(orderLines);
  ruleEngine.evalute("discountCalculation", facts);
  return money.toImmutableMoney();
 }
 ...
}
```

- 위 응용 영역에 위치한 서비스 코드는 두 가지 문제가 존재한다.
  - 1)CalculateDiscountService 만 테스트하기 어렵다. RuleEnigne이 완벽하게 동작해야만 하며 이에 대한 설정 파일도 필요하게 된다.
  - 2)구현 방식을 변경하기 어렵다는 점이다. `discountCalculation` 문자열은 `Drools`의 세션 이름이다. Drools의 세션 이름을 변경시 CalculateDiscountService의 코드도 같이 변경되어야한다.
- <b>이처럼 인프라스트럭처 계층에 의존하면 테스트의 어려움과 기능 확장의 어려움 이라는 두 가지 문제가 생긴다. 이를 해결하기 위해 SOLID 원칙 중 하나인 DIP 를 적용하면 된다.</b>

### DIP
