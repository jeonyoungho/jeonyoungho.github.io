---
title: "[DDDSTART] Chatper2 아키텍처 개요 정리" # post의 layout이 기본적으로 post로 설정되어있어서 Front Matter에 따로 layout변수를 만들어 주지 않아도 됨
date: 2023-04-25 15:10:00 +0800
categories: [DDD, DDDSTART] # categories는 최대 2개까지 가능
tags: [ddd, architecture] # TAG는 반드시 소문자로 이루어져야함, 0~무한개까지 지정 가능
toc: true # Table Of Content(TOC) 옵션, 기본적으로 포스트의 오른쪽 패널에 위치
comments: true # 댓글 유무 지정
# image: /assets/img/test.png # Preview image
# pin: true # 홈페이지 메인화면에 특정 게시물 고정
---

### 네 개의 영역

![image](https://user-images.githubusercontent.com/44339530/234268594-9c085f5e-5bb9-4a05-8a34-b9948eb0ecb6.png)

#### 표현 영역
- 표현 영역(UI영역)은 사용자의 요청을 받아 응용 영역에 전달하고 응용 영역의 처리 결과를 다시 사용자에게 보여주는 역할을 한다.
  - 표현 영역의 사용자는 웹 브라우저를 사용하는 사람일 수 도 있고, REST API 를 호출하는 외부 시스템일 수도 있다.
- 표현 영역을 통해 사용자의 요청을 전달받는 응용 영역은 시스템이 사용자에게 제공해야 할 기능을 제공한다.
  - 예를 들어, '주문 등록', '주문 취소', '상품 상세조회' 와 같은 기능을 구현한다.

#### 응용 영역
- 응용 영역은 기능을 구현하기 위해 도메인 영역의 도메인 도메인 모델을 사용한다.
- <b>응용 서비스는 로직을 직접 수행하기보단 도메인 모델에 로직 수행을 위임한다. 마치 아래 예제 코드처럼 Order 도메인 모델에 취소 처리를 위임하는 것처럼.</b>

```java
@Service
public class CancelOrderService {
    ...

    @Transactional
    public void cancel(String orderId) {
        Order order = findOrderById(orderId);
        if (order == null) {
            throw new OrderNotFoundException(orderId);
        }
        order.cancel();
    }

	...
}
```

![image](https://user-images.githubusercontent.com/44339530/234268635-6cf25196-3a46-48f5-828f-f741086b1b8e.png)

#### 도메인 영역
- 도메인 영역은 도메인 모델을 구현한다.
  - 도메인 모델은 도메인의 핵심 로직을 구현한다. (ex. 주문 도메인의 배송지 변경, 결제 완료, 주문 총액 계산과 같은)

#### 인프라스트럭처 영역
- 구현 기술에 대한 것을 다룬다.
- 예를 들어, RDBMS, MessageQueue, 몽고 DB, HBase 와의 연동을 처리한다.
- 추가적으로 SMTP를 이용한 메일 발송 기능을 구현하거나 HTTP 클라이언트를 이용해서 REST API 를 호출하는 것도 처리한다.

![image](https://user-images.githubusercontent.com/44339530/234268698-ff2e4ceb-8b22-4fe7-800e-f0c4487a6aff.png)

> 도메인, 응용, 표현 영역은 실제 구현 기술을 사용한 코드를 직접 만들지 않는다. 대신 인프라스트럭처 영역에서 제공하는 기능을 ㅅ용해서 필요한 기능을 개발한다. 예를 들어, 응용 영역에서 DB에 보관된 데이터가 필요하면 인프라스트럭처 영역의 DB 모듈을 사용해서 데이터를 읽어온다. 비슷하게 외부에 메일을 발송하려면 인프라스트럭처가 제공하는 SMTP 연동 모듈을 이용해 메일을 발송한다.

### 계층 구조 아키텍처

- 네 영역을 구성할 때 많이 사용하는 아키텍처가 [그림2.4]와 같은 계층 구조이다.
  - 도메인의 복잡도에 따라 응용과 도메인을 분리하기도 하고 합치기도 한다.

![image](https://user-images.githubusercontent.com/44339530/234274426-7259e107-79eb-40ba-a940-41d3edcf2b3e.png)

- 계층 구조는 단방향(하위 계층)으로만 의존하게 한다.
- 계층 구조를 엄격하게 적용하면 상위 계층은 바로 아래 계층에만 의존을 가져야 하지만, 구현의 편리함을 위해 계층 구조를 유옇나게 적용한다.
  - 예를 들어, 응용 계층에서 외부 시스템과의 연동을 위해 더 아래 계층인 인프라 계층에 의존하기도 한다.
- 계층 구조에 따르면 도메인과 응용 계층은 룰 엔진과 DB 연동을 위해 아래 이밎와 같이 인프라 모듈에 의존하게 된다.

![image](https://user-images.githubusercontent.com/44339530/234274386-d00a1aa5-e365-47c0-bf4d-198bb69db6b4.png)

- 여기서 짚고 넘어가야 할 것은 표현, 응용, 도메인 계층이 상세한 구현 기술을 다루는 인프라 계층에 종속된다는 점이다.
- 이때 문제가 생길 수 있는 부분이 있다.
- 도메인의 가격 계산 규칙을 정할 때 할인 금액 계산 로직이 복잡해지면 객체 지향으로 로직을 구현하는 것 보단 룰 엔진을 사용하는 것이 더 알맞을 때가 있다.
- `Drools`라는 룰 엔진을 사용해서 로직을 수행할 수 있는 인프라 스트럭처 코드이다. (Drools는 무시해도 된다.)
- 핵심은 evalute() 메서드에 값을 주면 별도 파일로 작성한 규칙을 이용해서 연산을 수행하는 코드라는 것 정도로만 이해하면 된다.

```java
// 인프라스트럭처 영역
public class DroolsRuleEngine {
 ...
 public void evalute(String sessionName, List<?> facts) {
  ...
 }
}
```

응용 영역은 가격 계산을 위해 인프라스트럭처 영역의 DroolsRuleEngine을 사용한다.

```java
// 응용 영역
public class CalculateDiscountService {
 
 private DroolsRuleEngine ruleEngine;

 public CalculateDiscountService() {
	ruleEngine = new DroolsRuleEngine();
 }

 public Money calculateDiscount(OrderLine orderLines, String customerId) {
  Customer customer = findCusotmer(customerId);

  MutableMoney money = new MutableMoney(0);
  List<?> facts = Arrays.asList(customer, money);
  facts.addAll(orderLines);
  ruleEngine.evalute("discountCalculation", facts);
  return money.toImmutableMoney();
 }
 ...
}
```

- 위 응용 영역에 위치한 서비스 코드는 두 가지 문제가 존재한다.
  - 1)CalculateDiscountService 만 테스트하기 어렵다. RuleEnigne이 완벽하게 동작해야만 하며 이에 대한 설정 파일도 필요하게 된다.
  - 2)구현 방식을 변경하기 어렵다는 점이다. `discountCalculation` 문자열은 `Drools`의 세션 이름이다. Drools의 세션 이름을 변경시 CalculateDiscountService의 코드도 같이 변경되어야한다.
- <b>이처럼 인프라스트럭처 계층에 의존하면 테스트의 어려움과 기능 확장의 어려움 이라는 두 가지 문제가 생긴다. 이를 해결하기 위해 SOLID 원칙 중 하나인 DIP 를 적용하면 된다.</b>

### DIP

- 가격 할인 계산을 하려면 아래 이미지의 왼쪽과 같이 고객 정보를 구해야 하고, 구현할 고객 정보와 주문 정보를 이용해서 룰을 실행해야 한다.

![image](https://user-images.githubusercontent.com/44339530/235098336-7c953ac9-34ee-4c44-973d-fa68bafde52d.png)

- 위 이미지에서 `CalculateDicountService` 는 고수준 모듈이다.
- <b>고수준 모듈이란 의미 있는 단일 기능을 제공하는 모듈이다.</b>
- `CalculateDicountService`는 '가격 할인 계산' 이라는 기능을 구현한다.
- <b>고수준 모듈의 기능을 구현하려면 여러 하위 기능이 필요하다.</b>
- 가격 할인 계산 기능을 구현하려면 고객 정보를 구해야 하고 룰을 실힝해야 하는데 이 두 기능이 하위 기능이다.
- <b>저수준 모듈은 하위 기능을 실제로 구현한 것이다.</b>
- [그림 2.7] 에서 JPA를 이용해서 고객 정보를 읽어오는 모듈과 Drools로 룰을 실행하는 모듈이 저수준 모듈이다.

- 고수준 모듈이 제대로 동작하려면 저수준 모듈을 사용해야 한다. 그런데, 고수준 모듈이 저수준 모듈을 사용하면 앞서 계층 구조 아키텍처에서 언급했던 두 가지 문제(구현 변경과 테스트가 어려움)가 발생한다.
- <b>DIP 는 이 문제를 해결하기 위해 저수준 모듈이 고수준 모듈에 의존하도록 바꾼다.</b>
  - <b>이렇게 하기 위해서 추상화한 인터페이스가 필요하게 된다.</b>
- CalculateDiscountService 입장에서 봤을 땐 룰 적용을 Drools 로 구현했는지, 자바로 직접 구현했는지 중요치 않다.
  - 단지, '고객 정보와 구매 정보에 룰을 적용해서 할인 금액을 구한다' 는 것이 중요할 뿐이다.
- 이를 추상화한 인터페이스는 다음과 같다.

```java
public interface RuleDiscounter {
  publis Money applyRules(Customer customer, List<OrderLine> orderLines);
}
```

이제 CalCulateDiscountService 가 RuleDiscounter 를 이용하도록 바꿔보자.

```java
public class CalculateDiscountService {
 private RuleDiscounter ruleDiscounter;
 private CustomerRepository customerRepository;

 public CalculateDiscountService(RuleDiscounter ruleDiscounter, CustomerRepository customerRepository) {
  this.ruleDiscounter = ruleDiscounter;
  this.customerRepository = customerRepository
 }

 public Money calculateDiscount(OrderLine orderLines, String customerId) {
  Customer customer = customerRepository.findCusotmer(customerId);
  return ruleDiscounter.applyRules(customer, orderLines);
 }

 private Customer findCustomer(String customerId) {
  Customer customer = customerRepository.findById(customerId);
  if (customer == null) throw new NoCustomerException();
  return customer;
 }
 ...
}
```

- CalculateDiscountService 는 Drools 에 의존하는 코드를 포함하고 있지 않다.
  - 단지 RuleDiscounter가 룰을 적용한다는 것만 알 뿐이다.
- 룰 적용을 구현한 클래스는 RuleDiscounter 인터페이스를 상속받아 구현하다.

```java
public class DroolsRuleDiscounter implements RuleDiscounter {
  ...

  @Override
  public Money applyRule(Customer customer, List<OrderLine> orderLines) {
    // 실제 구현 코드 생략
    return money;
  }
}
```

- 아래 이미지는 RuleDiscounter가 출현하면서 바뀐 구조를 보여주고 있다.

![image](https://user-images.githubusercontent.com/44339530/235101642-f9ab4ffe-4411-4023-902b-ded94fdd6206.png)

- 위 이미지 [그림 2.8]의 구조를 보면 CalculateDiscountService는 더 이상 구현 기술인 Drools에 의존하지 않는다.
- '룰을 이용한 할인 금액 계산'을 추상화한 RuleDiscounter 인터페이스에 의존할 뿐이다.
- '룰을 이용한 할인 금액 계산'은 고수준 모듈의 개념이므로  RuleDiscounter 인터페이스는 고수준 모듈에 속한다.
- DroolsRuleDiscounter는 고수준의 하위 기능인 RuleDiscounter를 구현한 것이므로 저수준 모듈에 속한다.

![image](https://user-images.githubusercontent.com/44339530/235102240-ebd13e68-3163-4c29-a71f-7189309af376.png)

- DIP를 적용하면 위 이미지와 같이 저수준 모듈이 고수준 모듈에 의존하게 된다.
  - 고수준 모듈이 저수준 모듈을 사용하려면 고수준 모듈이 저수준 모듈에 의존해야 하는데, 반대로 저수준 모듈이 고수준 모듈에 의존한다고 해서 이를 DIP(Dependency Inversion Principle, 의존 역전 원칙) 라고 부른다.
- 이처럼 DIP를 적용하면 앞서 다른 영역이 인프라스트럭처 영역에 의존할 때 발생했떤 두 가지 문제인 구현 교체가 어렵다는 문제와 테스트가 어려운 문제를 해소할 수 있다.

#### 1) 구현체 교체의 어려움 해결 
- 고수준 모듈은 더 이상 저수준 모듈에 의존하지 않고 구현을 추상화한 인터페이스에 의존한다.
- 실제 사용할 저수준 구현 객체는 아래 코드처럼 의존 주입을 이용해 전달받을 수 있다.

```java
// 사용할 저수준 객체 생성
RuleDiscounter ruleDiscounter = new DroolsRuleDiscounter();

// 생성자 방식으로 주입
CalculateDiscountService calculateDiscountService = new CalculateDiscountService(ruleDiscounter);
```
- 만약 구현 기술을 변경하더라도 CalculateDicountService를 수정할 필요가 없다.
- 아래 코드처럼 사용할 저수준 구현 객체를 생성하는 부분의 코드만 변경하면 되기 때문이다.

```java
// 사용할 저수준 구현 객체 변경
RuleDiscounter ruleDiscounter = new SimpleRuleDiscounter();

// 사용할 저수준 모듈을 변경해도 고수준 모듈을 수정할 필요가 없다.
CalculateDiscountService calculateDiscountService = new CalculateDiscountService(ruleDiscounter);
```

- 의존 주입을 지원하는 스프링과 같은 프레임워크를 사용하면 설정 코드를 수정해서 쉽게 구현체를 변경할 수 있다.

#### 1) 테스트 어려움 해결 
- CalculateDiscountService가 제대로 동작하는지 테스트하려면 CustomerRepository와 RuleDiscounter를 구현한 객체가 필요하다.
- 하지만 둘 다 인터페이스로 추상화 했기 때문에 대용 객체를 사용해서 테스트를 진행할 수 있다.
- 다음은 대용 객체를 사용해서 Customer가 존재하지 않는 경우 익셉션이 발생하는지 검증하는 테스트 코드인데, 실제 구현 클래스 없이 테스트 가능함을 보여준다.

```java
public class CalculateDiscountServiceTest {

  @Test(expected = NoCustomerException.class);
  public void noCustomer_thenExceptionShouldBeThrown() {
    // 테스트 목적의 대용 객체
    CustomerRepository stubRepo = mock(CustomerRepository.class);
    when(stubRepo.findById("noCustId")).thenReturn(null);

    RuleDiscounter stubRule = (cust, lines) -> null;

    // 대용 객체를 주입받아 테스트 진행
    CalculateDiscountService calcDisSvc = new CalculateDiscountService(stubRepo, stubRule);
    calcDisSvc.calculateDiscount(someLines, "noCustId");
  }
}
```

- 이렇게 실제 구현 없이 테스트 할 수 있는 이유는 DIP를 적용해서 고수준 모듈이이 저수준 모듈에 의존하지 않도록 했기 때문이다. 
  - 고수준 모듈인 CalculateDiscountService는 저수준 모듈에 직접 의존하지 않기 때문에 실제 저수준 구현 클래스 없이도 테스트 대용 객체를 이용해서 거의 모든 기능을 테스트할 수 있는 것이다.

### DIP 주의사항
- <b>DIP의 핵심은 고수준 모듈이 저수준 모듈에 의존하지 않도록 하기 위함이다.</b>
- 하지만 아래 이미지와 같이 저수준 모듈에서 인터페이스를 추출하는 경우가 있다.

![image](https://user-images.githubusercontent.com/44339530/235111140-fd0ce401-ae16-49b2-924e-fbb77a393c1b.png)

- 위 이미지는 잘못된 구조이다.
- 이 구조에서 도메인 영역은 이프라 스트러거 영역에 의존하고 있다.
  - 즉, 여전히 고수준 모듈이 저수준 모듈에 의존하고 있는 것이다.
- RuleEngine 인터페이스는 고수준 모듈인 도메인 관점이 아니라 룰 엔진이라는 저수준 모듈 관점에서 도출한 것이다.
- <b>DIP를 적용할 때 하위 기능을 추상화한 인터페이스는 고수준 모듈 관점(도메인 영역)에서 도출한다.</b>
  - CalculateDiscountService 입장에서 봤을 때 할인 금액을 구하기 위해 룰 엔진을 사용하는지, 직접 연산하는지 여부는 중요치 않다.
  - 단지 규칙에 따라 할인 금액을 계산한다는 것이 중요할 뿐이다.
  - 즉, '할인 금액 계산'을 추상화한 인터페이스는 저수준 모듈이 아닌 고수준 모듈에 위치한다.(아래 이미지 참고)

![image](https://user-images.githubusercontent.com/44339530/235112160-2a49ff3a-a307-4af8-ae11-bf811e22fb2e.png)

### DIP와 아키텍처
- <b>인프라스트럭처 영역은 구현 기술을 다루는 저수준 모듈이고 응용 영여과 도메인 영역은 고수준 모듈이다.</b>
- 인프라스트럭처 계층의 가장 하단에 위치하는 계층형 구조와 달리 아키텍처에 DIP를 적용하면 [그림 2.12]와 같이 인프라스트럭처 영역이 응용 영역과 도메인 영역에 의존(상속)하는 구조가 된다.

![image](https://user-images.githubusercontent.com/44339530/235112627-ff9a15d9-a9a4-4250-bf37-9a4c796cdff1.png)

- 인프라스트럭처에 위치한 클래스가 도메인이나 응용 영역에 정의한 인터페이스를 상속받아 구현하는 구조가 되므로 도메인과 응용 영역에 대한 영향을 주지 않거나 최소화하면서 구현 기술을 변경하는 것이 가능하다.

![image](https://user-images.githubusercontent.com/44339530/235113218-9f1eb69f-5cb0-4e85-99b9-279c57838556.png)

- 위 이미지에서 인프라스트럭처 영역의 EmailNotifier 클래스는 응용 영역의 Notifier 인터페이스를 상속 받고 있다.
  - 주문 시 통지 방식에 SMS를 추가해야 한다는 요구사항이 들어왔을땐 응용 영역의 OrderService를 변경할 필요가 없다.
  - [그림 2.14]와 같이 두 통지 방식을 함께 제공하는 Notifier 구현 클래스를 인프라 스트럭처 영역에 추가하면 된다.
  - 비슷하게 MyBatis 대신 JPA를 구현 기술로 사용하고 싶다면 JPA를 이용한 OrderRepository 구현 클래스를 인프라스트럭처 영역에 추가하면 된다.

![image](https://user-images.githubusercontent.com/44339530/235114051-49e32776-a87d-4374-8b6c-a251e309c411.png)

