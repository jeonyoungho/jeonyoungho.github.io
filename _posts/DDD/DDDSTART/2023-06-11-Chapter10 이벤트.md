---
title: "[DDDSTART] Chapter10-이벤트" # post의 layout이 기본적으로 post로 설정되어있어서 Front Matter에 따로 layout변수를 만들어 주지 않아도 됨
date: 2023-06-11 15:10:00 +0800
categories: [DDD, DDDSTART] # categories는 최대 2개까지 가능
tags: [ddd, dddstart] # TAG는 반드시 소문자로 이루어져야함, 0~무한개까지 지정 가능
toc: true # Table Of Content(TOC) 옵션, 기본적으로 포스트의 오른쪽 패널에 위치
comments: true # 댓글 유무 지정
# image: /assets/img/test.png # Preview image
# pin: true # 홈페이지 메인화면에 특정 게시물 고정
---

### 10.1 시스템 간 강결합 문제
- 쇼핑몰에서 구매를 취소하면 환불을 처리해야 한다.
- 이때 환불 기능을 실행하는 주체는 주문 도메인 엔티티가 될 수 있따.
- <b>도메인 객체에서 환불 기능을 실행하려면 다음 코드처럼 환불 기능을 제공하는 도메인 서비스를 파라미터로 전달바독 취소 도메인 기능에서 도메인 서비스를 실행하게 된다.</b>

```java
public class Order {
  ...
  // 외부 서비스를 실행하기 위해 도메인 서비스를 파라미터로 전달받음
  public void cancel(RefundService refundService) {
    verifyNotYetShipped();
    this.state = OrderState.CANCELED;

    this.refundStatus = State.REFUND_STARTED;
    try {
      refundService.refund(getPaymentId());
      this.fefundStatus = State>REFUND_COMPLETED;
    } catch (Exception ex) {
      ??
    }

  }

  ...
}
```

- 혹은 응용 서비스에서 환불 기능을 실행할 수도 있다.

```java
public class CancelOrderService {
  private RefundService refundService;

  @Transactional
  public void cancel(OrderNo orderNo) {
    Order order = findOrder(orderNo);
    order.cancel();

    order.refundStarted();
    try {
      refundService.refund(order.getPaymentId());
      order.refundCompleted();
    } catch (Exception ex) {
      ???
    }
  }

  ...
}
```

- 보통 결제 시스템은 외부에 존재하므로 RefundService는 외부 결제 시스템이 제공하는 환불 서비스를 호출한다.
- 이때 세 가지 문제가 발생할 수 있다.

#### 1) 트랜잭션 처리 범위 문제
- 외부 서비스가 정상이 아닐 경우 트랜잭션 처리를 어떻게 해야할지 애매하다는 것이다.
  - 환불 기능을 실행하는 과정에서 익셉션이 발생하면 롤백해야 할까? 일단 커밋?
  - 외부의 환불 서비스를 실행하는 과정에서 익셉션이 발생하면 환불에 실패했으므로 주문 취소 트랜잭션을 롤백하는 것이 맞아 보인다.
  - 하지만 반드시 롤백 해야 하는 것은 아니다. 주문은 취소 상태로 변경하고 환불만 나중에 다시 시도하는 방식으로 처리할 수도 있다.

#### 2) 성능 문제
- 환불을 처리하는 외부 시스템의 응답 시간이 길어지면 그만큼 대기 시간도 길어진다.
  - 예를 들어, 환불 처리 기능이 30초 걸리면 주문 취소 기능은 30초만큼 대기시간이 증가한다.
  - 즉, 외부 서비스 성능에 직접적인 영향을 받게 된다.

#### 3) 도메인 객체에 서비스를 전달함으로써 추가적인 설계 문제
- 우선 주문 로직과 결제 로직이 섞이는 문제가 있을 수 있다.

```java
public class Order {
  ...
  // 외부 서비스를 실행하기 위해 도메인 서비스를 파라미터로 전달받음
  public void cancel(RefundService refundService) {
    verifyNotYetShipped();
    this.state = OrderState.CANCELED;
    // 여기까지 주문 로직

    this.refundStatus = State.REFUND_STARTED;
    try {
      refundService.refund(getPaymentId());
      this.fefundStatus = State>REFUND_COMPLETED;
    } catch (Exception ex) {
      ??
    }
    // 여기까지 결제 로직

  }

  ...
}
```

- 그리고 기존 기능에 새로운 기능을 추가할 때 발생한다. 
  - 만약 주문을 취소한 뒤 환불뿐만 아니라 취소했다는 내용을 통지해야 한다면?
  - 환불 도메인 서비스와 동일하게 파라미터로 통지 서비스를 받도록 해야할 것이고 앞서 언급한 로직이 섞인는 문제가 더 커지고 트랜잭션 처리가 더 복잡해지게 될 것이다.
  - 게다가 영향 주는 외부 서비스가 두개로 증가한다.

```java
public class Order {
  // 기능을 추가할 떄마다 파라미터가 함께 추가되면
  // 다른 로직이 더 많이 섞이고, 트랜잭션 처리가 더 복잡해진다.
  public void cancel(RefundService refundService, NotiService notiSvc) {
    verifyNotYetShipped();
    this.state = OrderState.CANCELED;
    
    ...
    // 주문 + 결제 + 통지 로직이 섞임
    // refundService 는 성공하고, notiSvc는 실패하면?
    // refundService와 notiSvc 중 무엇을 먼저 처리하나?
  }
}
```

- 위에서 언급된 문제들은 주문 바운디드 컨텍스트와 결제 바운디드 컨텍스트간의 강결합(high coupling) 때문이다.
- 주문이 결제와 강하게 결합되어 있어서 주문 바운디드 컨텍스트가 결제 바운디드 컨텍스트에 영향을 받게 되는 것이다.
- <b>이런 강결합을 없앨 수 있는 방법이 이벤트를 사용하는 것이다.</b>
- 특히 비동기 이벤트를 사용하면 두 시스템 간의 결합도를 크게 낮출 수 있는데, 한 번 익숙해지면 모든 연동을 이벤트와 비동기로 처리하고 싶을 정도로 강력하고 매력적인 것이 이벤트다.

### 10.2 이벤트 개요
- '이벤트' 는 '과거에 벌어진 어떤 것'을 의미한다.
  - 예를 들어, 사용자가 암호를 변경한 것은 '암호를 변경했음 이벤트'가 벌어졌다고 할 수 있다. 비슷하게 주문을 취소했다면 '주문을 취소했음 이벤트'가 발생했다고 할 수 있다.

- 웹 브라우저에서 자바스크립트 코드를 작성해본 경험이 있는 개발자라면 이미 이벤트에 익숙할 것이다.
  - UI개발에서 모든 UI컴포넌트는 관련 이벤트를 발생시킨다.
  - 예를 들어, 버튼을 클릭시 '버튼 클릭됨 이벤트', 스크롤시 '스크롤됨 이벤트'가 발생하게 된다.

- 이벤트가 발생했다는 것은 상태가 변경됐다는 것을 의미한다.
- '암호 변경됨 이벤트'가 발생한 이유는 회원이 암호를 변경했기 때문이고, '주문 취소됨 이벤트'가 발생한 이유는 주문을 취소했기 떄문이다.

- 이벤트가 발생하면 그 이벤트 반응하여 우너하는 동작을 수행하는 기능을 구현한다.
  - 다음 자바스크립트는 jQuery를 이용해서 작성한 코드이다.
  - 이 코드에서 click() 에 전달한 함수는 'myBtn' 버튼에서 '클릭됨 이벤트'가 발생하면 그 이벤트에 반응하여 경고창을 출력한다.

```javascript
$("#myBtn").click(function (evt) {
  alert("경고");
});
```

- 도메인 모델에서도 UI 컴포넌트와 유사하게 도메인의 상태 변경을 이벤트로 표현할 수 있다.
- 보통 '~할 때', '~가 발생하면', '만약 ~하면'과 같은 요구사항은 도메인의 상태 변경과 관련된 경우가 많고 이런 요구사항을 이벤트를 이용해서 구현할 수 있다.
- 예를 들어 '주문을 취소할 때 이메일을 보낸다' 라는 요구사항에서 주문을 취소할 때' 는 주문이 취소 상태로 바뀌는 것을 의미하므로 '주문 취소됨 이벤트'를 활용해서 구현할 수 있다.

#### 10.2.1 이벤트 관련 구성 요소
- 도메인 모델에 이벤트를 도입하려면 아래 이미지와 같이 네 개의 구성요소인 `이벤트`, `이벤트 생성 주체`, `이벤트 디스패처(퍼블리셔)`, `이벤트 핸들러(구독자)`를 구현해야 한다.

![image](https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/cee6e932-fcb9-4310-82b9-263dd80acad7)


- <b>이벤트 생성 주체</b>
  - <b>도메인 모델에서 이벤트 생성 주체는 엔티티, 밸류, 도메인 서비스와 같은 도메인 객체이다.</b>
  - <b>이들 도메인 객체는 도메인 로직을 실행해서 상태가 바뀌면 관련 이벤트를 발생시킨다.</b>
- <b>이벤트 핸들러</b>
  - 이벤트 생성 주체가 발생한 이벤트에 반응한다.
  - 생성 주체가 발생한 이벤트를 전달받아 이벤트에 담긴 데이터를 이용해서 원하는 기능을 실행한다.
  - 예를 들어, '주문 취소됨 이벤트'를 받는 이벤트 핸들러는 해당 주문의 주문자에게 SMS로 주문 취소 사실을 통지할 수 있다.
- <b>이벤트 디스패처</b>
  - 이벤트 생성 주체와 이벤트 핸들러를 연결해준다.
  - 이벤트 생성 주체는 이벤트를 생성해서 디스패처에 이벤트를 전달한다.
  - 이벤트를 전달받은 디스패처는 해당 이벤트를 처리할 수 있는 핸들러에 이벤트를 전파한다.
  - 이벤트 디스패처의 구현 방식에 따라 이벤트 생성과 처리를 동기나 비동기로 실행하게 된다.

#### 10.2.2 이벤트의 구성
- 이벤트는 발생한 이벤트에 대한 정보를 담는다.
- 이 정보는 다음을 포함한다.
  - 1)이벤트 종류: 클래스 이름으로 이벤트 종류를 표현
  - 2)이벤트 발생시간
  - 3)추가 데이터: 주문번호, 신규 배송지 정보 등 이벤트와 관련된 정보

- 배송지를 변경시 발생하는 이벤트는 아래와 같이 작성할 수 있다.

```java
public class ShippingInfoChangedEvent {
  private String orderNumber;
  private long timestamp;
  private ShippingInfo newShippingInfo;

  // 생성자, getter
}
```

- <b>클래스 이름을 보면 'Changed'라는 과거 시제를 사용했다. 이벤트는 현재 기준으로 과거(바로 직전이라도)에 벌어진 것을 표현하기 때문에 이벤트 이름에는 과거 시제를 사용한다.</b>

- 이 이벤트를 발생하는 주체는 Order 애그리거트다. Order 애그리거트의 배송지 변경 기능을 구현한 메서드는 다음 코드처럼 배송지 정보를 변경한 뒤에 이 이 벤트를 발생시킬 것이다.
- 이 코드에서 `Events.raise()` 는 디스패처를 통해 이벤트르 전파하는 기능을 제공하는데 이 기능의 구현과 관련된 내용은 뒤에서 살펴보도록 하자.

```java
public class Order {
  public void changeShippingInfo(ShippingInfo newShippingInfo) {
    verifyNotYetShipped();
    setShippingInfo(newShippingInfo);
    Events.raise(new ShippingInfoChangedEvent(number, newShippingInfo));
  }
  ...
}
```

- ShippingInfoChangedEvent 를 처리하는 핸들러는 디스패처로부터 이벤트를 전달받아 필요한 작업을 수행한다.
  - 예를 들어, 변경된 배송지 정보를 물류 서비스에 전송하는 핸들러는 다음과 같이 구현할 수 있다.

```java
public class ShippingInfoChangedHandler {
  @EventListener(ShippingInfoChangedEvent.class)
  public void handle(ShippingInfoChangedEvent evt) {
    shippingInfoSynchronizer.sync(
      evt.getOrderNumber(),
      evt.getNewShippingInfo()
    );
  }
}
```

- 이벤트는 이벤트 핸들러가 작업을 수행하는데 필요한 데이터를 담아야 한다.
- 이 데이터가 부족하면 핸들러는 필요한 데이터를 읽기 위해 관련 API를 호출하거나 DB에서 데이터를 직접 읽어와야 한다.
- 예를 들어, ShppingInfoChangedEvent 가 바뀐 배송지 정보를 포함하고 있지 않다고 가정해보자.
  - 이 핸들러가 같은 VM에서 동작하고 있따면 다음과 같이 주문 데이터를 로딩해서 배송지 정보를 추출해야 한다.

```java
public class ShippingInfoChangedHandler {
  
  @EventListener(ShippingInfoChangedEvent.class)
  public void handle(ShippingInfoChangedEvent evt) {
    // 이벤트가 필요한 데이터를 담고 있지 않으면,
    // 이벤트 핸들러는 리포지터리, 조회 API, 직접 DB 접근 등의
    // 방식을 통해 필요한 데이터를 조회해야 한다.
    Order order =  orderRepository.findById(evt.getOrderNo());
    shippingInfoSynchronizer.sync(
      order.getOrderNumber(),
      order.getNewShippingInfo()
    );
  }

  ...
}
```

- <b>이벤트는 데이터를 담아야 하지만 그렇다고 이벤트 자체와 관련 없는 데이터를 포함할 필요는 없다.</b>
- 배송지 정보를 변경해서 발생시킨 ShippingInfoChangedEvent 가 이벤트 발생과 직접 관련된 바뀐 배송지 정보를 포함하는 것은 맞지만, 배송지 정보 변경과 전혀 관련 없는 주문 상품번호와 개수를 담을 필요는 없다.

#### 10.2.3 이벤트 용도

<b>1) 트리거</b>

- 도메인의 상태가 바뀔때 다른 후처리가 필요하면 후처리를 실행하기 위한 트리거로 이벤트를 사용할 수 있다.
- 주문에선 주문 취소 이벤트를 트리거로 사용할 수 있다.
- 주문을 취소하면 환불을 처리해야 하는데 이때 환불 처리를 위한 트리거로 주문 취소 이벤트를 사용할 수 있다.

![image](https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/5c6b8460-1eae-410f-8938-2b99b3cb94f7)

- 예매 결과를 SMS로 통지할때도 이벤트를 트리거로 사용할 수도 있다. 예매 도메인은 '예매 완료' 이벤트를 발생시키고 이 이벤트 핸들러에선 SMS를 발송하는 방식으로 구현할 수 있다.

<b>2) 서로 다른 시스템 간의 데이터 동기화</b>

- 배송지를 변경하면 외부 배송 서비스에 바뀐 배송지 정보를 전송해야 한다.
- 주문 도메인은 배송지 변경 이벤트를 발생시키고 이벤트 핸들러는 외부 배송 서비스와 배송지 정보를 동기화할 수 있다.

#### 10.2.4 이벤트 장점

<b>1) 서로 다른 도메인 로직이 섞이는 것을 방지</b>

![image](https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/2deb0cd8-c237-4684-8d4c-36e9090e8016)
_이미지 출처: https://velog.io/@csh0034/%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%A3%BC%EB%8F%84-%EA%B0%9C%EB%B0%9C-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0-10.-%EC%9D%B4%EB%B2%A4%ED%8A%B8_

- 위 이미지를 보면 구매 취소 로직에 이벤트를 적용함으로써 환불 로직이 없어지고 환불 서비스를 실행하기 위한 파라미터도 없어진 것을 볼 수 있다.
- 환불 실행 로직은 주문 취소 이벤트를 받는 이벤트 핸들러로 이동하게 된다.
- 이벤트를 사용하여 주문 도메인에서 결제(환불) 도메인으로의 의존을 제거했다.

<b>2) 기능 확장이 용이</b>

- 구매 취소시 환불과 함께 이메일로 취소 내용을 보내고 싶다면 이메일 발송을 처리하는 핸들러를 구현하면 된다.
- 기능을 확장해도 구매 취소 로직은 수정할 필요가 없다.

![image](https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/db74a7c8-ae91-48fc-af57-c639e3bc232f)

### 10.3 이벤트, 핸들러, 디스패처 구현
- 이벤트와 관련된 코드는 다음과 같다.
  - 이벤트 클래스: 이벤트를 표현한다.
  - 디스패처: 스프링이 제공하는 ApplicationEventPublisher 를 이용한다.
  - Events: 이벤트를 발행한다. 이벤트 발행을 위해 ApplicationEventPublisher 를 사용한다.
  - 이벤트 핸들러: 이벤트를 수신해서 처리한다. 스프링이 제공하는 기능을 사용한다.

> **Note**: 이벤트 디스패처를 직접 구현할 수도 있지만 이 책에서는 스프링이 제공하는 이벤트 관련 기능을 사용해서 이벤트 발생과 처리를 구현한다.

#### 10.3.1 이벤트 클래스
- 이벤트 자체를 위한 상위 타입은 존재하지 않는다. 원하는 클래스를 이벤트로 사용하면 된다.
- OrderCanceledEvent 와 같이 클래스 이름 뒤에 접미사로 Event 를 사용해서 이벤트로 사용하는 클래스라는 것을 명시적으로 표현할 수도 있고 OrderCanceled 처럼 간결함을 위해 과거 시제만 사용 할수도 있다.
- 이벤트 클래스는 이벤트를 처리하는데 필요한 최소한의 데이터를 포함해야 한다.
  - 예를 들어 주문 취소됨 이벤트는 적어도 주문번호를 포함해야 관련 핸들러에서 후속처리를 할 수 있다.

```java
public class OrderCanceledEvent {
  // 이벤트는 핸들러에서 이벤트를 처리하는데 필요한 데이터를 포함한다.
  private String orderNumber;

  public OrderCanceledEvent(String number) {
    this.orderNumber = number;
  }

  public String getOrderNumber() {
    return orderNumber;
  }
} 
```

- 모든 이벤트가 공통으로 갖는 프로퍼티가 존재한다면 관련 상위 클래스를 만들 수도 있다.
  - 예를 들어 모든 이벤트가 발생 시간을 갖도록 하려면 다음과 같은 상위클래스를 만들고 각 이벤트 클래스가 이를 상속받도록 하면 된다.

```java
// 공통 추상 클래스
package com.myshop.common.event;

public abstract class Event {
    private long timestamp;

    public Event() {
        this.timestamp = System.currentTimeMillis();
    }
}
```

```java
// 발생 시간이 필요한 각 이벤트 클래스는 Event 클래스를 상속받아 구현한다.
public class OrderCanceledEvent extends Event {

    private String orderNumber;

    public OrderCanceledEvent(String number) {
        super();
        this.orderNumber = number;
    }
}
```

#### 10.3.2 Events 클래스와 ApplicationEventPublisher
- 이벤트 발생과 출판을 위해 스프링이 제공하는 ApplicationEventPublisher 를 사용한다.
- 스프링 컨테이너는 ApplicationEventPublisher도 된다.
  - <b>스프링 컨테이너는 ApplicationEventPublisher 를 상속받는 구조로 되어 있기 때문이다.</b>
- Events 클래스는 ApplicationEventPublisher 를 사용해서 이벤트를 발생시키도록 구현할 것이다.

```java
public class Events {
    private static ApplicationEventPublisher publisher;

    static void setPublisher(ApplicationEventPublisher publisher) {
        Events.publisher = publisher;
    }

    public static void raise(Object event) {
        if (publisher != null) {
            publisher.publishEvent(event);
        }
    }
}
```

- Events 클래스의 raise() 메서드는 ApplicationEventPublisher 가 제공하는 publishEvent() 메서드를 이용해서 이벤트를 발생시킨다.
- Events 클래스가 사용할 ApplicationEventPublisher 객체는 setPublisher() 메서드를 통해서 전달받는다.
- Events#setPublisher() 메서드에 이벤트 퍼블리셔를 전달하기 위해 스프링 설정 클래스를 아래와 같이 작성한다.

```java
@Configuration
public class EventsConfiguration {
    @Autowired
    private ApplicationContext applicationContext;

    @Bean
    public InitializingBean eventsInitializer() {
        return () -> Events.setPublisher(applicationContext);
    }
}
```

- eventsInitializer() 메서드는 InitializingBean 타입 객체를 빈으로 설정한다.
  - 이 타입은 스프링 빈 객체를 초기화할 때 사용하는 인터페이스로, 이 기능을 사용해서 Events 클래스를 초기화했다.
  - 위에서 언급한것처럼 ApplicationContext 는 ApplicationEventPublisher 를 상속하고 있으므로 Events 클래스를 초기화할 때 ApplicationContext 를 전달했다.

#### 10.3.3 이벤트 발생과 이벤트 핸들러
- 이벤트를 발생시킬 코드는 Events.raise() 메서드를 사용한다.
  - 예를 들어 Order#cancel() 메서드는 다음과 같이 구매 취소 로직을 수행한뒤 Events.raise() 를 이용해서 관련 이벤트를 발생시킨다.

```java
public class Order {
    public void cancel() {
        verifyNotYetShipped();
        this.state = OrderState.CANCELED;
        Events.raise(new OrderCanceledEvent(number.getNumber()));
    }
    ...
}
```

- 이벤트를 처리할 핸들러는 스프링이 제공하는 `@EventListener` 어노테이션을 사용해서 구현한다.
- 다음은 OrderCanceldedEvent 를 처리하기 위한 핸들러를 구현한 코드의 예다

```java
@Service
public class OrderCanceledEventHandler {
    private RefundService refundService;

    public OrderCanceledEventHandler(RefundService refundService) {
        this.refundService = refundService;
    }

    @EventListener(OrderCanceledEvent.class)
    public void handle(OrderCanceledEvent event) {
        refundService.refund(event.getOrderNumber());
    }
}
```

- ApplicationEventPublisher#publishEvent() 메서드를 실행할 때 OrderCanceledEvent 타입객체를 전달하면, OrderCanceledEvent.class 값을 갖는 @EventListener 어노테이션이 붙은 메서드를 찾아 실행한다.
  
#### 10.3.4 흐름 정리

![image](https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/8261cba6-9daf-4e4f-a726-9d47b7aab711)

- 아래와 같이 방식으로 처리된다.
  - 1)도메인 기능을 실행한다.
  - 2)도메인 기능은 Events.raise() 메서들르 이용해서 이벤트를 발생시킨다.
  - 3)Events.raise() 는 스프링이 제공하는 ApplicationEventPublisher 를 이용해서 이벤트를 출판한다.
  - 4)ApplicationEventPublisher 는 @EventListener(이벤트타입.class) 어노테이션이 붙은 메서드를 찾아 실행한다.

 - 코드 흐름을 보면 응용 서비스와 동일한 트랜잭션 범위에서 이벤트 핸들러를 실행하고 있다.
   - 즉, 도메인 상태 변경과 이벤트 핸들러는 같은 트랜잭션 범위에서 실행된다.

### 10.4 동기 이벤트 처리 문제
- 이벤트를 사용해서 강결합 문제는 해결했지만, 외부 서비스에 영향을 받는 문제가 남아있다.

```java
// 1. 응용 서비스 코드
@Transactional // 외부 연동 과정에서 익셉션이 발생하면 트랜잭션 처리는?
public void cancel(OrderNo orderNo) {
  Order order = findOrder(orderNo);
  order.cancel(); // OrderCanceledEvent 발생
}

// 2. 이벤트를 처리하는 코드
@Service
public class OrderCanceledEventHandler {
  ...

  @EventListener(OrderCanceledEvent.class)
  public void handle(OrderCanceledevent event) {
    // refundService.refund()가 느려지거나 익셉션이 발생하면?
    refundService.refund(event.getOrderNumber());
  }
}
```

- 위 코드에서 refundService.refund() 가 외부 환불 서비스와 연동한다고 가정해 보자.
  - 만약 외부 환불 기능이 갑자기 느려지면 cancel() 메서드도 함께 느려진다.
  - <b>이것은 외부 서비스의 성능 저하가 바로 내 시스템의 성능 저하로 연결된다는 것을 의미한다.</b>
- 성능 저하뿐만 아니라 트랜잭션도 문제가 된다.
  - refundService.refund() 에서 익셉션이 발생하면 cancel() 메서드의 트랜잭션을 롤백해야 할까? 트랜잭션을 롤백하면 구매 취소 기능을 롤백하는 것이므로 구매 취소가 실패하는 것과 같다.
  - 생각해볼만한 것은 외부 환불 서비스 실행에 실패했다고 반드시 트랜잭션을 롤백해야 하는지에 대한 문제다.
  - 일단 구매 취소 자체는 처리하고 환불만 재처리하거나 수동으로 처리할 수도 있다.
- <b>외부 시스템과의 연동을 동기로 처리할때 발생하는 성능과 트랜잭션 범위 문제를 해소하는 방법은 이벤트를 비동기로 처리하거나 이벤트 와 트랜잭션을 연계하는 것이다.</b>
  - 두 방법중 먼저 비동기 이벤트 처리에 대해 알아보자.

### 10.5 비동기 이벤트 처리
- 회원 가입 신청을 하면 검증을 위해 이메일을 보내는 서비스가 많다.
  - 회원 가입 신청을 하자마자 바로 내 메일함에 검증 이메일이 도착할 필요는 없다.
  - 이메일이 몇 초뒤에 도착해도 문제 되지 않는다.
  - 10초 ~ 20초 후에 이메일이 도착해도 되고, 심지어 이메일을 받지 못하면 다시 받을 수 있는 기능을 이용하면 된다.
- 비슷하게 주문을 취소하자마자 바로 결제를 취소하지 않아도 된다.
  - 수십초 내에 결제 취소가 이루어지면 된다. 몇칠 뒤에 결제가 확실하게 취소되면 문제없을 때도 있다.
- 이렇게 'A 하면 이어서 B하라' 는 내용을 담고 있는 요구사항은 실제로 'A 하면 최대 언제까지 B 하라' 인 경우가 많다.
  - 즉, 일정 시간 안에서만 후속 조치를 처리하면 되는 경우가 적지 않다.
  - 게다가 'A 하면 이어서 B 하라' 는 요구사항에서 B를 하는데 실패하면 일정 간격으로 재시도를 하거나 수동 처리를 해도 상관없는 경우가 있다.
  - 앞의 이메일 인증 예가 이에 해당한다.
  - 회원 가입 신청 시점에서 이메일 발송을 실패하더라도 사용자는 이메일 재전송 요청을 이용하여 수동으로 인증 이메일을 다시 받아볼 수 있다.
- 'A 하면 일정 시간 안에 B하라' 는 요구사항에서 'A 하면은' 이벤트로 볼 수도 있다.
  - '회원 가입 신청을 하면 인증 이메일을 보내라' 는 요구사항에서 '회원 가입 신청을 하면' 은 '회원 가입 신청함 이벤트로' 볼 수 있다.
  - 따라서 '인증 이메일을 보내라' 기능은 '회원 가입 신청함 이벤트'를 처리하는 핸들러에서 보낼 수 있다.
- 앞서 말했듯 'A 하면 이어서 B 하라'는 요구사항 중에서 'A 하면 최대 언제까지 B 하라'로 바꿀 수 있는 요구사항은 이벤트를 비동기로 처리하는 방식으로 구현할 수 있다.
  - 다시 말해서 'A 이벤트가 발생하면 별도 스레드로 B를 수행하는 핸들러를 실행하는 방식으로 요구사항을 구현할 수 있다.
- 이벤트를 비동기로 구현하는 방법은 다양한데, 여기선 다음 네 가지 방식으로 비동기 이벤트 처리를 구현하는 방법에 대해 알아보자.
  - <b>1)로컬 핸드러를 비동기로 실행하기</b>
  - <b>2)메시지 큐를 사용하기</b>
  - <b>3)이벤트 저장소와 이벤트 포워더 사용하기</b>
  - <b>4)이벤트 저장소와 이벤트 제공 API 사용하기</b>
- 네 가지 방식은 각자 구현하는 방식도 다르고 그에 따른 장단점이 있다. 각 방식에 대해 차례대로 살펴보자.




### Reference
- 예제 코드 및 이미지
  - [https://sangjaeoh.github.io/books/%EB%8F%84%EB%A9%94%EC%9D%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/#10-%EC%9D%B4%EB%B2%A4%ED%8A%B8](https://sangjaeoh.github.io/books/%EB%8F%84%EB%A9%94%EC%9D%B8%EC%A3%BC%EB%8F%84%EA%B0%9C%EB%B0%9C%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0/#10-%EC%9D%B4%EB%B2%A4%ED%8A%B8)