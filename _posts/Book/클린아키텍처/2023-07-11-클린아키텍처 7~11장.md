---
title: "[클린아키텍처] 7 ~ 11장"
date: 2023-07-11 +0800
categories: [책, 클린아키텍처]
tags: [cleanarchitecture]
toc: true
comments: true
# image: /assets/img/test.png
# pin: true
---

![clean-architecture-book](https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/5d90a988-4e1c-4f9c-b36b-28755aef9fff)

> '클린 아키텍처' 기술 서적에 대해 학습했던 내용을 정리하기 위한 목적의 TIL 포스팅입니다.🙆‍♂️

# 3부 설계 원칙
- SOLID 원칙은 함수와 데이터 구조를 클래스로 배치하는 방법, 그리고 이들 클래스를 서로 결합하는 방법을 설명해준다.
  - '클래스' 라는 단어를 사용했다고 해서 SOLID 원칙이 객체 지향 소프트웨어에만 적용된다는 뜻은 아니다.
  - 여기서 클래스는 단순히 함수와 데이터를 결합한 집합을 가리킨다.
  - 소프트웨어 시스템은 모두 이러한 집합을 포함하는데, SOLID 원칙은 이러한 집합에 적용된다.
- SOLID 원칙의 목적은 다음과 같다.
  - 변경에 유연하도록
  - 이해하기 쉽도록
  - 많은 소프트웨어 시스템에 사용될 수 있는 컴포넌트의 기반이 될 수 있도록
- SOLID 원칙은 코드 수준보단 조금 상위(모듈 수준)에서 적용되며 모듈과 컴포넌트 내부에서 사용되는 소프트웨어 구조를 정의하는데 도움을 준다.
- 아래 세부 쳅터에선 SOLID 원칙을 다 설명 후 컴포넌트 세계에서 SOLID 원칙에 대응하는 원칙들을 설명하고, 이어서 고수준의 아키텍처 원칙까지 설명할 것이다.
- SOLID 원칙을 간략하게 요약하면 다음과 같다.
  - `SRP(단일 책임 원칙)`: 각 소프트웨어 모듈은 변경의 이유가 단 하나여야 한다.
  - `OCP(개방 폐쇄 원칙)`: 기존 코드를 수정하기 보단 반드시 새로운 코드를 추가하는 방식으로 시스템의 행위를 변경할 수 있도록 설계해야만 소프트웨어 시스템을 쉽게 변경할 수 있다.
  - `LSP(리스코프 치환 원칙)`: 상호 대체 가능한 구성요소를 이용해 소프트웨어 시스템을 만들 수 있으려면, 이들 구성요소는 반드시 서로 치환 가능해야 한다는 계약을 지켜야 한다.
  - `ISP(인터페이스 분리 원칙)`: 사용하지 않는 것에 의존하지 않아야 한다.
  - `DIP(의존성 역전 원칙)`: 고수준 정책을 구현하는 코드는 저수준 세부사항을 구현하는 코드에 절대 의존해선 안된다. 대신 세부사항이 고수준 정책에 의존해야 한다.
- 아래 내용에선 이들 원칙이 아키텍처 관점에서 지닌 의미에 집중하여 논의하고자 한다.

## 7장 - SRP: 단일 책임 원칙
- 의미가 가장 잘 전달되지 못한 원칙
- 함수는 반드시 단 하나의 일만 해야 한다는 원칙이 아니다.
  - 이 원칙은 커다란 함수를 작은 함수들로 리팩터링하는 더 저수준에서 사용된다.
  - SOLID 원칙도 SRP도 아니다.
- 역사적으론 아래와 같이 기술되어 있다.

> 단일 모듈은 변경의 이유가 하나, 오직 하나뿐이어야 한다.

- 소프트웨어 시스템은 사용자와 이해관계자를 만족시키기 위해 변경된다.
- SRP가 말하는 '변경의 이유'란 바로 이들 사용자와 이해관계자를 가리키는데 사용자는 여럿이 될 수 있다.
- 여기에서의 '사용자'는 해당 변경을 요청하는 한 명 이상의 사람들을 가리키는데 이러한 집단을 '액터'라 부른다.
- 그랬을 경우 다음과 같이 최종 정리할 수 있다.

> 하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임져야 한다.

- 모듈'이란 무엇인가? 가장 단순한 정의는 소스 파일이다.
- 하지만 일부 언어와 개발 환경에서는 코드를 소스 파일에 저장하지 않는다.
- 이러한 경우 모듈은 단순히 함수와 데이터 구조로 구성된 응집된 집합이다.
- '응집된(cohesive)' 라는 단어가 SRP를 암시한다. 단일 액터를 책임지는 코드를 함께 묶어주는 힘이 바로 응집성(cohesion)이다.
- 이 원칙을 위반하는 다음 징후들을 살펴보자.

### 징후1: 우발적 중복

![image](https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/108d9cd6-fb90-4af5-99af-292b7415d382)

- 위 Employee 클래스는 세 가지 메서드 `calulatePay()`, `reportHours()`, `save()`를 가진다.
- 이 클래스는 SRP를 위반하는데, 이들 세 가지 메서드가 서로 매우 다른 세 명의 액터를 책임지기 때문이다.
  - `calculatePay()` 메서드는 회계팀에서 기능을 정의하며, CFO 보고를 위해 사용한다.
  - `reportHours()` 메서드는 인사팀에서 기능을 정의하고 사용하며, COO 보고를 위해 사용한다.
  - `save()` 메서드는 데이터베이스 관리자(DBA)가 기능을 정의하고, CTO 보고를 위해 사용한다.

- 개발자가 이 세 메서드를 Employee라는 단일 클래스에 배치하여 세 액터가 서로 결합되어 버렸다.
- 이로 인해 예를 들어 CFO 팀에서 결정한 조치가 COO팀이 의존하는 무언가에 영향을 줄 수 있다.

![image](https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/9604e639-28fe-4d1d-b156-47fa80ed71ba)

- 예를 들어, CFO 팀에서 초과 근무를 제외한 업무 시간을 계산하는 방식(regularHours 함수)을 약간 수정하기로 결정했다고 해보자.
- 반면, 인사를 담당하는 COO 팀에선 이러한 변경사항을 원치 않는다고 할때 개발자는 다른 곳에서도 (reportHours 함수) 이를 참조하고 있다는 것을 눈치채지 못할 것이다. 이때 COO 팀에서 의도치 않은 큰 문제가 발생할 것이다. (잘못된 계산으로 수백만 달러 예산이 지출되는...)

- <b>서로 다른 액터가 의존하는 코드를 너무 가까이 배치했기 때문에 발생한 문제고 SRP 는 서로 다른 액터가 의존하는 코드를 서로 분리하라고 말한다.</b>

### 징후2: 병합
- 소스파일에 다양하고 많은 메서드를 포함하면 병합이 자주 발생할 수 있다.
- 특히 이들 메서드가 서로 다른 액터를 책임진다면 병합이 발생할 가능성은 높아진다.
- 예를 들어, DBA가 속한 CTO 팀에서 데이터베이스의 Employee 테이블 스키마를 수정하기로 결정했고, 동시에 인사 담당자가 속한 COO 팀에서는 reportHours() 메서드의 보고서 포맷을 변경하기로 결정했다고 해보자.
- 두 명의 서로 다른 개발자가 Employee 클래스를 체크아웃받은 후 변경사항을 적용한다.
- 이들 변경사항은 서로 충돌할 수 밖에 없다. 결과적으로 병합이 발생한 것이다.
- <b>이러한 문제를 벗어나는 방법은 서로 다른 액터를 뒷받침하는 코드를 서로 분리하는 것이다.</b>

### 해결책
- 해결책은 다양하지만, 그 모두가 메서드를 가기 다른 클래스로 이동시키는 방식이다.
- <b>아마 가장 확실한 해결책은 데이터와 메서드를 분리하는 방식일 것이다.</b>
- 즉, 아무런 메서드가 없는 간단한 데이터 구조인 EmployeeData 클래스를 만들어, 세 개의 클래스가 공유하도록 한다.

![image](https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/6d40cfaa-39fb-4456-9bcd-d5f4bed02c1e)

- 각 클래스는 자신의 메서드에 반드시 필요한 소스 코드만을 포함한다.
- 세 클래스는 서로의 존재를 몰라야 한다. 따라서 '우연한 중복'을 피할 수 있다.


- 반면 이 해결책은 개발자가 세 가지 클래스를 인스턴스화하고 추적해야 한다는 단점이 있다.
- 이럴때 흔히 쓰는 기법으론 퍼사드 패턴이 있다.

![image](https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/675407e3-ce22-4c0f-8b8e-a45b8fd33b33)

- EmployeeFacade에 코드는 거의 없다. 
- 이 클래스는 세 클래스의 객체를 생성하고, 요청된 메서드를 가지는 객체로 위임하는 일을 책임진다.

- 또한, 어떤 개발자는 아래와 같이 가장 중요한 업무 규칙을 데이터와 가깝게 배치하는 방식을 선호한다.
- 이 경우라면 가장 중요한 메서드는 기존의 Employee 클래스에 그대로 유지하되, Employee 클래스를 덜 중요한 나머지 메서드들에 대한 퍼사드로 사용할 수도 있다.

![image](https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/aa2ddac4-0e40-413e-8a43-48ce20ee024f)

- 모든 클래스는 반드시 단 하나의 메서드를 가져야 한다는 주장에 근거하면 앞의 해결책에 반대할 수도 있다.
- 하지만 실제로 각 클래스에서는 다수의 private 메서드를 포함할 것이다. (현실적으로)
- 여러 메서드가 하나의 가족을 이루고, 메서드의 가족을 포함하는 각 클래스는 하나의 유효범위가 된다.
- 해당 유효범위 바깥에서는 이 가족에게 감춰진 식구(private 멤버)가 있는지를 전혀 알 수 없다.

### 결론
- SRP 는 메서드와 클래스 수준의 원칙이다.
- 하지만 이보다 상위의 두 수준에서도 다른 형태로 다시 등장한다.
  - '컴포넌트 수준'에서는 공통 폐쇄 원칙(Common Closure Principle)이 된다.
  - '아키텍처 수준'에서는 아키텍처 경계(Architectural Boundary)의 생성을 책임지는 변경의 축이 된다.
- 이러한 개념들은 이후 장에서 살펴본다.

## 8장 - OCP: 개방 폐쇄 원칙



#### Reference
- [https://wedonttalknemore.tistory.com/13](https://wedonttalknemore.tistory.com/13)