---
title: "[클린아키텍처] 1 ~ 6장"
date: 2023-07-05 +0800
categories: [책, 클린아키텍처]
tags: [cleanarchitecture]
toc: true
comments: true
# image: /assets/img/test.png
# pin: true
---

# 1부 - 소개

## 1장 - 설계와 아키텍처란?

### 목표는?
- 소프트웨어 아키텍처의 목표는 필요한 시스템을 만들고 유지보수하는데 투입되는 인력을 최소화하는데 있다.
- 새로운 기능을 출시할 때 마다 비용이 증가한다면 나쁜 설계라 볼수 있다.

### 사례 연구 ~ 무엇이 잘못되었나?
- 한 소프트웨어 개발 회사 몇년 동안 계속 개발 인력을 기하급수적으로 늘려가는데, 그에 비해 생산성 및 비용 그리고 매출이 현저하게 떨어진 사례가 있다.
- 위 사례의 근본적 원인은 개발자들이 두 가지 거짓말에 속기 때문이다.
  - "코드는 나중에 정리하면 돼. 당장은 시장에 출시하는게 먼저야" 
  - "지저분한 코드를 작성하면 단기간에는 빠르게 갈 수 있고, 장기적으로 볼때만 생산성이 낮아진다."(더 중요한)
- <b>여기서 핵심은 엉망으로 개발하면 깔끔하게 유지할 때보다 항상 더 느리다는 것이다.</b>

### 결론
- 소프트웨어 아키텍처를 심각하게 고려할 수 있으려면 좋은 소프트웨어 아키텍처가 무엇인지 이해해야 한다.
- 비용은 최소화하고 생산성은 최대화할 수 있는 설계와 아키텍처를 가진 시스템을 만들려면, 이러한 결과로 이끌어 줄 시스템 아키텍처가 지닌 속성을 알고 있어야 한다.

## 2장 - 두 가지 가치에 대한 이야기
- 소프트웨어 시스템은 이해관계자에게 서로 다른 두 가지 가치(`행위와 구조`)를 제공한다.

### 행위
- 단순하게 동작하는 기능을 개발하는 것을 뜻한다.

### 아키텍처
- '소프트웨어' 라는 단어는 '부드러운(soft)'과 '제품(ware)'라는 단어의 합성어이다.
- 이처럼 소프트웨어는 '부드러움을 지니도록' 만들어졌다.
- 소프트웨어를 만든 이유는 기계의 행위를 쉽게 변경할 수 있도록 하기 위해서다.
  - 만약 기계의 행위를 변경하는게 어렵게 만들었다면 하드웨어라 불렀을 것이다...
- <b>즉, 핵심은 소프트웨어는 변경하기 쉬워야 한다.</b>
  - <b>변경사항을 적용하는데 드느 어려움은 변경되는 범위(scope)에 비레해야 하며, 변경사항의 형태와는 관련 없어야 한다.</b>
- 이러한 변경하기 쉬운 소프트웨어를 만드려면 '시스템 아키텍처' 가 중요하다.
  - 아키텍처가 특정 형태를 다른 형태보다 선호하면 할수록, 새로운 기능을 이 구조에 맞추는게 더 힘들어진다.
  - 따라서 아키텍처는 형태에 독립적이어야 하고, 그럴수록 더 실용적이다.

### 더 높은 가치
- 필자는 위에서 언급한 '행위'와 '아키텍처' 중에 '아키텍처' 라고 주장하는데 그 이유는 다음과 같다.
  - 완벽하게 동작하지만 수정이 아예 불가능한 프로그램은 요구사항 변경시 동작하지 않을 것이고 결국 프로그램이 돌아가도록 만들수 없게 된다.
  - 동작은 하지만 변경이 쉬운 프로그램은 돌아가도록 만들면되고, 변경사항이 발생해도 유지보수 가능하다. 앞으로도 계속 유용할 것이다.
- <b>수정이 현실적으로 불가능한 시스템은 존재하기 마련인데, 변경에 드는 비용이 변경으로 창출되는 수익을 초과하는 경우다..</b>

### 아이젠하워 매트리스

![image](https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/8ab42a73-2904-4996-a179-82f6601efba3)
_https://velog.io/@joosing/2-%EB%91%90-%EA%B0%80%EC%A7%80-%EA%B0%80%EC%B9%98%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%EC%95%BC%EA%B8%B0-Clean-Architecture-u45rjz6p_

- 긴급한 문제는 중요하지 않으며, 중요한 문제는 절대 긴급하지 않다는게 핵심이다.
- 소프트웨어의 첫 번째 가치인 행위는 긴급하지만 매번 높은 중요도를 가지는 것은 아니다.
- 소프트웨어의 두 번째 가치인 아키텍처는 중요하지만 즉각적인 긴급성을 필요로 하는 경우는 절대 없다.
- 위 네 가지중 우선순위는 다음과 같다.
  - 1)긴급하고 중요한(아키텍처, 동작)
  - 2)긴급하지는 않지만 중요한(아키텍처)
  - 3)긴급하지만 중요치 않은(동작)
  - 4)긴급하지도 않고 중요치도 않은

- 아키텍처, 즉 중요한 일은 가장 높은 두 순위를 차지하는 반면, 행위는 첫번째와 세번째에 위치한다는 점을 주목해야 한다.
- 업무 관리자와 개발자가 흔히 저지르는 실수는 세번째 위치한 항목을 첫 번째로 격상시키는 것이다. 그러다 실패로 이어지게 된다..
  - 소프트웨어 개발자를 고용하는 이유는 바로 중요도가 높은 아키텍처를 업무 관리자에게 설득시키기 책임지기 위해서다. 
  - 따라서 기능의 긴급성이 아닌 아키텍처의 중요성을 설득하는 일은 소프트웨어 개발팀이 마땅히 책임져야 한다.

### 아키텍처를 위해 투쟁하라
- 효율적인 소프트웨어 개발팀은 투쟁에서 정면으로 맞서 싸운다.
  - 개발자는 소프트웨어를 안전하게 보호해야 할 책임이 있으며, 아키텍처를 위해 적극적으로 투쟁해야 한다.
- 아키텍트는 기능을 개발하기 쉽고, 간편하게 수정 가능하며, 확장이 쉬운 아키텍처를 만들어야 한다.

## 2부 - 벽돌부터 시작하기: 프로그래밍 패러다임

### 3장 - 프로그래밍 패러다임 개요

### 구조적 프로그래밍
- 간략히 요약하면 제어흐름의 직접적인 전환에 대해 `규칙을 부과`한다.

### 객체 지향 프로그래밍
- 간략히 요약하면 제어흐름의 간접적인 전화에 대해 `규칙을 부과`한다.

### 함수형 프로그래밍
- 간략히 요약하면 할당문에 대해 `규칙을 부과`한다.

### 생각할 거리
- 각 패러다임은 프로그래머에게 권한을 박탈한다.
  - <b>즉, 패러다임은 무엇을 해야 할지 말하기보단 무엇을 해선 안되는지를 말해준다.</b
- 세 가지 패러다임 각각은 우리에게서 goto문, 함수 포인터, 할당문을 앗아간다.
- 우리에게 더 가져갈 수 있는 건 없을 것이다. 따라서 프로그래밍 패러다임은 아프오롣 딱 세가지 밖에 없을 것이다.
  - 중요한건 아니지만 이들 패러다임은 1958~1968년 총 10 년 동안 모두 만들어졌다. 이후 수십년이 지났지만 새롭게 등장한 패러다임은 없다..

### 결론
- 세 가지 패러다임과 아키텍처의 세 가지 큰 관심사(함수, 컴포넌트 분리, 데이터 관리)가 어떻게 서로 연관되는지에 주목하자.

## 4장 - 구조적 프로그래밍
- 1930년에 태어난 데이스크라는 1957년 결혼을 하는데, 그 당시 네덜란드에선 결혼 의식의 하나로 자신의 직업을 기입해야 했다.
- 하지만 네덜란드에선 그의 직업인 '프로그래머' 를 인정하지 않으려했고, 프로그래밍의 원리나 과학을 증명해내고자 했다.

### 증명
- 데이스크라는 goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견했다.
- 반면 goto 문장을 사용하더라도 모듈을 분해할 때 문제 되지 않는 경우도 있었다.
- <b>데이스크라는 이런 goto 문의 '좋은' 사용 방식은 if/then/sle 와 do/while 과 같은 분기와 반복이라는 단순한 제어구조에 해당한다는 사실을 발견했다.</b>
  - 모듈이 이러한 종류의 제어 구조만을 사용한다면 증명 가능한 단위로까지 모듈을 재귀적으로 세분화하는 것이 가능해 보였다.
- 그는 이러한 제어 구조는 순차 실행과 결합했을 때 특별하다는 사실을 깨달았다.
- <b>즉 모든 프로그램을 순차, 분기, 반복 이라는 세 가지 구조만으로 표현할 수 있다는 사실을 알게 되었다. (사실 2년 앞서 뵘과 야코피니가 발견했다)</b>

### 해로운 성명서
- 1968 년 데이스크라는 CACM 편집자에게 증명해낸 사실을 편지로 보냈고 같은해 3월호에 실렸다.
- 하지만 비판하는자와 지지하는자들 사이에서 논란이 많았다.
- 이러한 10년 이상의 논란을 데이스크라는 마침내 이겨냈다.
  - 컴퓨터 언어가 진화하면서 goto 문장은 계속 뒤편으로 밀려났고, 마침내 거의 사라졌다.
  - 대다수 현대적 언어는 goto 문장을 포함하지 않으며, 당연히 LISP 에선 첨부터 없었다.
- 현재 우리 모두는 구조적 프로그래머이며, 여기엔 선택의 여지가 없다.
  - 제어 흐름을 제약 없이 직접 전화할 수 없는 선택권 자체를 언어에서 제공하지 않기 떄문이다.
  - 자바의 경우 break 문이나 예외가 goto 문과 유사하다볼 수 있찌만, 그래도 이들 구조는 제한적인 부분이 있다.
  - goto 키워드를 지원하는 언어에서도 goto 문의 목적지 범위를 현재 함수 안으로 한정시키는 편이다.

### 기능적 분해
- 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고, 이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻했다.
- 즉, 거대한 문제 기술서를 받더라도 문제를 고수준의 기능들로 분해할 수 있다.
- 그리고 이들 각 기능은 다시 저수준의 함수들로 분해 가능하고, 이러한 분해 과정을 끝없이 반복할 수 있다.
- 게다가 이렇게 분해한 기능들은 구조적 프로그래밍의 제한된 제어구조를 이용하여 표현할 수 있다.
- 1970~80년대 몇몇 사람들이 구조적 분석이나 구조적 설계와 같은 기법을 더 디벨롭하여 널리알렸다.
- 이들 기법을 사용하면 프로그래머는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있고, 더 나아가 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화할 수 있다.

### 엄밀한 증명은 없다.
- 하지만 끝내 유클리드 계층 구조는 만들어지지 않았고 증명해내지 못했다.
- 하지만 수학적인 증명만이 있는 것은 아니고 과학적 방법도 있었다.

### 과학이 구출하다.
- 과학은 서술된 내용이 사실임을 증명하는 방식이 아니라 `서술이 틀렸음을` 증명하는 방식으로 동작한다.
- 각고의 노력으로도 반례를 들 수 없는 서술이 있다면 목표에 부합할만큼은 참이라고 본다.
- <b>결론적으로 수학은 증명 가능한 서술이 참임을 입증하는 원리라 볼 수 있는데, 과학은 증명 가능한 서술이 거짓임을 입증하는 원리라 볼 수 있다.</b>

### 테스트
- 데이크스트라는 "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 순 없다" 고 말한 적 있다.
  - 다시 말해 프로그램이 잘못되었음을 테스트를 통해 증명 가능하지만, 맞다고는 증명할 수 없다.
  - 테스트에 충분한 노력을 들였따면 테스트가 보장하는 것은 프로그램이 목표에 부합할만큼은 충분히 참이라고 여길 수 있게 해주는 것이 전부다.
- 이 같은 사실은 소프트웨어는 수학적인 시도가 아니라 과학임을 알려준다. 최선을 다하더라도 올바르지 않음을 증명하는데 실패함으로써 올바름을 보여주기 때문이다.
- `구조적 프로그래밍`은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한다.
- 그러고 나서 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려 시도한다.
- 이처럼 거짓임을 증명하려는 테스트가 실패한다면, 이 기능들은 목표에 부합할 만큼은 충분히 참이라 여기게 된다.

### 결론
- 구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위를 만들어 낼 수 있는 바로 이 능력 때문이다.
- 또한 흔히 현대적 언어가 아무런 제약 없는 goto 문을 지원하지 않는 이유이기도 하다.
- <b>뿐만 아니라 아키텍처 관점에서 기능적 분해를 최고의 실천법 중 하나로 여기는 이유기도 하다.</b>
- 가장 작은 기능에서부터 가장 큰 컴포넌트에 이르기까지 모든 수준에서 소프트웨어는 과학과 같고, 따라서 반증 가능성에 의해 주도된다.
- 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트하기 쉽도록) 만들기 위해 분주히 노력해야 한다.
- 이를 위해 구조적 프로그래밍과 유사한 제한적인 규칙들을 받아들여 활용해야 한다.




#### Reference
- [https://velog.io/@joosing/2-%EB%91%90-%EA%B0%80%EC%A7%80-%EA%B0%80%EC%B9%98%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%EC%95%BC%EA%B8%B0-Clean-Architecture-u45rjz6p](https://velog.io/@joosing/2-%EB%91%90-%EA%B0%80%EC%A7%80-%EA%B0%80%EC%B9%98%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%B4%EC%95%BC%EA%B8%B0-Clean-Architecture-u45rjz6p)
