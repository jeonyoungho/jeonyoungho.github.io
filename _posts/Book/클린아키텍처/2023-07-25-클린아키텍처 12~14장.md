---
title: "[클린아키텍처] 12 ~ 14장"
date: 2023-07-25 +0800
categories: [책, 클린아키텍처]
tags: [cleanarchitecture]
toc: true
comments: true
# image: /assets/img/test.png
# pin: true
---

![clean-architecture-book](https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/5d90a988-4e1c-4f9c-b36b-28755aef9fff)

> '클린 아키텍처' 기술 서적에 대해 학습했던 내용을 정리하기 위한 목적의 TIL 포스팅입니다.🙆‍♂️

# 4부 컴포넌트 원칙
- SOLID 원칙이 벽과 방에 벽돌을 배치하는 방법을 알려준다면, 컴포넌트 원칙은 빌딩에 방을 배치하는 방법을 설명해준다.
- 큰 빌딩과 마찬가지로 대규모 소프트웨어 시스템은 작은 컴포넌트들로 만들어진다.

## 12장 컴포넌트

> 컴포넌트가 무엇인지 컴포넌트의 역사에 대해 설명하는 내용이다. 크게 중요한 내용은 많지 않아서 컴포넌트가 무엇인지 그리고 어떻게 소프트웨어가 발전하게 되었는지를 가볍게 보면 좋다.

- 컴포넌트는 시스템의 구성요소로 배포할 수 있는 가장 작은 단위다.
  - 자바 - jar
  - 루비 - gem 파일
  - 닷넷 - DLL
- 컴파일형 언어에서 컴포넌트는 바이너리 파일의 결합체다. 인터프리형 언어의 경우 소스 파일의 결합체이다.
- 모든 언어에서 컴포넌트는 배포할 수 있는 단위 입자다.
- 여러 컴포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성 가능하다.
- 또는 여러 컴포넌트를 서로 묶어서 war 파일과 같은 단일 아카이브로 만들 수도 있다.
- 또는 컴포넌트 각각을 jar 나 dll 같이 동적으로 로드할 수있는 플러그링닝나 exe 파일로 만들어서 독립적으로 배포할 수도 있따.
- 잘 설계된 컴포넌트라면 반드시 독립적으로 배포 간으한, 따라서 독립적으로 개발 가느한 능력을 갖춰야 한다.

### 컴포넌트의 간략한 역사
- 프로그래밍 초창기에는 프로그램을 로드할 메모리의 위치를 정하는 일이 프로그래머가 가장 먼저 결정해야 하는 사항 중 하나였다.
  - 이 시절엔 프로그램 위치가 한 번 결정되면, 재배치가 불가능했다.
- 이러한 구시대에는 프로그래머가 라이브러리 함수의 소스 코드를 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일하여 해당 라이브러리에 접근했다.
  - 라이브러리는 바이너리가 아닌 소스 코드 형태로 유지되었다.
- 이 시대엔 장치는 느리고 메모리는 너무 비싸서 자원이 한정적이었기에, 이러한 접근법은 문제가 있었다.
  - 이 시대엔 메모리가 너무 작아서 소스 코드 전체를 메모리에 상주시킬 수 없었고, 컴파일러는 소스 코드 전체를 여러번에 걸쳐서 읽어야했다.
  - 이 과정은 엄청오래 걸렸다.
- 따라서 함수 라이브러리의 소스 코드를 애플리케이션 코드로부터 분리하고, 함수 라이브러리를 개별적으로 컴파일해, 컴파일된 바이너리를 메모리의 특정 위치에 로드했다. (102p-그림12.1 초기의 메모리 배치 이미지 참고)
- 하지만, 이 방식도 초기에 할당된 메모리보다 애플리케이션이 더 커지게 되자, 애플리케이션을 두 개의 세그먼트로 분리하여 함수 라이브러리 공간을 사이에 두고 오가며 동작하게 배치해야 했다.
- 하지만 이것은 분명 지속 가능한 방법이 아니었다.

![image](https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/6184a102-f2bd-4504-8ecf-5c50e0454345)

### 재배치성
- 해결책은 재배치가 가능한 바이너리였다.
- 바로 로더를 이용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정하자는 것이었다.
- 프로그래머는 함수 라이브러리를 로드할 위치와 애플리케이션을 로드할 위치를 로더에게 지시할 수 있게 되었다.
- 로더는 바이너리르 입력받은 후, 단순히 하나씩 차례로 메모리로 로드하면서 재배치하는 작업을 처리하였고, 프로그래머는 필요한 함수만을 로드할 수 있게 되었다

- 컴파일러는 재배치 가능한 바이너리 안의 함수 이름을 메타데이터 형태로 생성하도록 수정되었다.
  - 프로그램이 라이브러리 함수를 호출한다면 외부 참조(external reference)로 생성했다.
  - 프로그램이 라이브러리 함수를 정의한다면 외부 정의(external definition)로 생성했다.
- 이렇게 함으로써 외부 정의를 로드할 위치가 정해지기만 하면 로더가 외부 참조를 외부 정의에 링크시킬 수 있게 된다. 이를 `링킹 로더`라고 한다.


### 링커
- 1970년대 초가 되자 프로그램이 커지게 되고, 링킹 로더는 프로그램을 로드하는데 매우 긴 시간이 걸렸다.
- 이를 해결하고자 `로드`와 `링크`가 분리되었다.
- 프로그래머가 느린 부분, 즉 링크 과정을 맡았는데, 링커라는 별도의 애플리케이션으로 이 작업을 처리하도록 만들었다.
  - 링커는 링크가 완료된 재배치 코드를 만들어 주었고, 그 덕분에 로더의 로딩 과정이 아주 빨라졌다. 그리고 한 번 만들어준 실행 파일은 언제라도 빠르게 로드할 수 있게 되었다.
- 하지만 또 1980년대가 되어 프로그래머는 C나 또 다른 고수준 언어를 사용하기 시작했고 프로그램도 더 커지게 되었다.
  - 그러다보니 `컴파일-링크` 시간이 병목 구간이되어 또 다시 전체 모듈을 컴파일하는데 엄청난 시간이 들게 되었다... (끊이지 않는 반복..) 
- 이후 기술이 발전하여 디스크 속도가 증가하고 액티브X와 공유 라이브러리, jar 파일이 등장했으며, 다수의 .jar 또는 공유 라이브러리를 순식간에 서로 링크한 후, 링크가 끝난 프로그램을 실행할 수 있게 되었다.
- 이렇게 컴포넌트 플러그인 아키텍처가 탄생했다.

### 결론
- 런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 이 책에서 말하는 소프트웨어 컴포넌트에 해당한다.

## 13장 컴포넌트 응집도
- 어떤 클래스를 어느 컴포넌트에 포함시켜야 할 지는 중요한 결정이다.
- 이 장에선 컴포넌트 응집도와 관련된 세 가지 원칙을 논의한다.
  - `REP(Reuse/Release Equivalence Principle)` - 재사용/릴리스 등가 원칙
  - `CCP(Common Closure Principle)` - 공통 폐쇄 원칙
  - `CRP(Common Reuse Principle)` - 공통 재사용 원칙

### REP: 재사용/릴리스 등가 원칙

> 재사용 단위는 릴리스 단위와 같다.

- 소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나 릴리스 번호가 부여되지 않는다면 해당 컴포넌트를 재사용하고 싶어도 할 수도 없고, 하지도 않을 것이다.
- 릴리스 번호가 없다면 재사용 컴포넌트들이 서로 호환되는지 알 수가 없다.
- 개발자들은 릴리스 변경사항을 통해 기존 버전을 쓸지 아니면 새로운 릴리스 변경사항을 적용할지를 결정 가능하다.
- <b>이 원칙을 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈로 구성되어야 함을 뜻한다.</b>
  - 단순히 뒤죽박죽 임의로 선택된 클래스와 모듈로 구성되선 안된다.
- 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 한다.
- <b>하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스 할 수 있어야 한다.</b>
- 이 원칙의 약점은 다음에 다룰 두 원칙이 지닌 강점을 통해 충분히 보완할 수 있다.
  - 실제로 CCP와 CRP 는 REP를 엄격하게, 하지만 제약을 가하는 측면에서 정의한다.

### CCP: 공통 폐쇄 원칙

> 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.

- 이 원칙은 단일 책임 원칙(SRP)을 컴포넌트 관점에서 다시 쓴 것이다.
  - <b>공통 폐쇄 원칙 CCP 에서도 마찬가지로 단일 컴포넌트는 변경의 이유가 여러 개 있어선 안된다고 말한다.</b>
- 유지보수성은 재상용성보다 훨씬 중요하다.
  - 애플리케이션 코드가 반드시 변경되어야 한다면, 변경 지점들이 여러 컴포넌트에 분산되어 있는 것보단 한 컴포넌트에 존재하는 것이 낫다.
  - 만약 변경 지점을 단일 컴포넌트로 제한할 수 있다면, 해당 컴포넌트만 재배포하면 되고, 변경된 컴포넌트에 의존하지 않는 다른 컴포넌트는 다시 검증하거나 배포할 필요가 없다.
- CCP는 위와 같은 이유로 변경될 가능성이 존재하는 클래스는 모두 한 곳으로 묶을 것을 권한다.
  - 물리적 또는 개념적으로 강하게 결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야 한다.
  - 이를 통해 소프트웨어를 릴리스, 재검증, 배포하는 일과 관련된 작업량을 최소화할 수 있다.
- 이 원칙은 개방 폐쇄 원칙(OCP)과도 밀접하게 관련되어 있다.
  - 실제로 CCP의 폐쇄는 OCP의 폐쇄와 그 뜻이 같다.
  - 100%의 폐쇄는 불가능한데 변경 가능성이 있거나 과거에 발생했던 대다수의 공통적인 변경사항에 대해서 클래스가 닫혀있도록 설계한다.
- CCP에선 동일한 유형의 변경에 대해 닫혀있는 클래스들을 하나의 컴포넌트로 묶음으로써 OCP에서 얻은 교훈을 확대 적용한다.
  - 따라서 변경이 필요한 요구사항이 발생할 경우, 그 변경이 영향을 주는 컴포넌트들이 최소한으로 한정될 가능성이 확실히 높아진다.

#### SRP 와의 유사성
- CCP는 컴포넌트 수준의 SRP다.
- SRP에선 서로 다른 이유로 변경되는 메서드를 서로 다른 클래스로 분리하라고 말한다.
- CCP에선 서로 다른 이유로 변경되는 클래스를 서로 다른 컴포넌트로 분리하라고 말한다.
  - 두 원칙은 모두 아래와 같은 교훈으로 요약 가능하다.

> 동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.

### CRP: 공통 재사용 원칙

> 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.

- 공통 재사용 원칙 CRP도 클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정할 때 도움되는 원칙이다.
- <b>CRP에선 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다고 말한다.</b>
  - 개별 클래스가 단독으로 재사용되는 경우는 거의 없으며 대체로 재사용 가능한 클래스는 재사용 모듈의 일부로써 해당 모듈의 다른 클래스와 상호작용하는 경우가 많다. 
  - CRP 에선 이런 클래스들이 동일한 컴포넌트에 포함되어야 한다고 말한다.

- 간단한 예시로 container와 iterator 클래스는 서로 강하게 결합되어 있기 때문에 함께 재사용된다. 따라서 동일한 컴포넌트에 위치해야한다.
- 또한, CPR는 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 말해준다.
  - 어떤 컴포넌트가 다른 컴포넌트를 사용하면, 두 컴포넌트 사이에 의존성이 생긴다.
  - 사용하는 클래스에서 사용되는 클래스에서 단 하나의 클래스만 사용한다고 해도 의존성은 약해지지 않는다.
  - 이런 의존성으로 인해 사용되는 컴포넌트가 변경될 때 마다 사용하는 컴포넌트도 변경해야할 가능성이 높다.
  - <b>따라서 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다.</b>

- 따라서 CRP는 어떤 클래스를 한데 묶어도 되는지보단, 어떤 클래스를 한데 묶어선 안되는지에 대해 훨씬 더 많은 것을 이야기한다.
  - CRP는 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안 된다고 말한다.

#### ISP와의 관계
- CRP는 인터페이스 분리 원칙(ISP)의 포괄적인 버전이다.
- ISP는 사용하지 않은 메서드가 있는 클래스에 의존하지 말라고 조언한다.
- CRP는 사용하지 않은 클래스를 가진 컴포넌트에 의존하지 말라고 조언한다.
- 위 두 조언은 다음 한 문장으로 요약할 수 있다.

> 필요하지 않는 것에 의존하지 말라.

### 컴포넌트 응집도에 대한 균형 다이어그램
- 응집도에 관한 세 원칙은 서로 상충된다.
- REP와 CCP는 포함(inclusive) 원칙이며, 컴포넌트를 더욱 크게 만든다.
- CRP는 배제(exclusive)원칙이며, 컴포넌트를 더욱 작게 만든다.
- 따라서 이 원칙들이 균형을 이루는 방법을 찾아야 한다.

![image](https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/efa75162-bdc6-41c3-9d08-73c2101f1258)


- 위 균형 다이어그램에서 다이어그램의 각 변은 반대쪽 꼭지점에 있는 원칙을 포기했을 때 감수해야 할 비용을 나타낸다.
  - REP와 CRP에만 중점을 두면, 사소한 변경에 너무 많은 컴포넌트에 영향을 미친다.
  - CCP와 REP에만 과도하게 집중하면 불필요한 릴리스가 너무 빈번해진다.
  - CRP와 CCP에만 집중하게 되면 재사용성이 떨어지게 된다.
- 뛰어난 아키텍트라면 이 균형 삼각형에서 현재 개발팀이 현재 관심을 기울이는 부분을 충족시키는 위치를 찾아야 하며, 또한 시간이 흐르면서 개발팀이 주의를 기울이는 부분 역시 변한다는 사실도 이해하고 있어야 한다.
  - 예를 들어, 프로젝트 초기에는 CCP가 REP보다 훨씬 더 중요한데, 개발 가능성이 재사용성보다 더욱 중요하기 때문이다.
  - 일반적으로 프로젝트는 삼각형의 오른쪽에서 시작하는 편인데, 프로젝트가 성숙하고 그 프로젝트로부터 파생된 또 다른 플조ㅔㄱ트가 시작되면, 점차 왼쪽으로 이동해 간다.
  - <b>즉, 프로젝트 컴포넌트 구조는 시간과 성숙도에 따라 변한다는 뜻이다.</b>

### 결론
- 어느 클래스들을 묶어서 컴포넌트로 만들지를 결정할 때, 재사용성과 개발 가능성이라는 상충하는 힘을 반드시 고려해야 한다.
- 이들 사이에서 애플리케이션의 요구에 맞게 균형을 잡는 일은 중요하다. 심지어 이 균형점은 항상 유동적이다.
  - 즉, 두 힘을 현재 상황에 맞게 잘 분배했더라도, 내년엔 맞지 않을 수도 있다.
  - 결과적으로 시간이 흐름에 따라 프로젝트의 초점이 개발가능성에서 재사용성으로 바뀌고, 그에 따라 컴포넌트를 구상하는 방식도 조금씩 흐트러지고 또 진화한다.

### 논의하고 싶은 내용
- 1) 예제가 딱히 없어서 이해하기 쉽지 않은데, 이 장에서 말하는 컴포넌트는 어떤 것을 의미할까? 프론트 관점에서 보면 디자인시스템 리엑트 컴포넌트들이 담긴 위젯 레포로 보면 되는것일까?
- 2)그림13.1 에서 CCP, CRP, REP 미츠이 텍스트들이 잘 못 표시된걸까? 내가 이해가 부족한 것일까?ㅜ


## 14장 - 컴포넌트 결합
- 지금부터 다루게 될 세 가지 원칙은 컴포넌트 사이의 관계를 설명한다.
- 이 장에서도 마찬가지로 개발 가능성과 논리적 설계 사이의 균형을 다룬다.

### ADP: 의존성 비순환 원칙

> 컴포넌트의 의존성 그래프에 순환(Cycle)이 있어서는 안 된다.

- 동일한 소스코드를 여럿이 건들게 되면, 충돌이 자주 발생하게 되고 망가진 부분을 고치느라 애를 먹을 것이다.
- 이때 해결책으론 두 가지 방법이 있다.
  - 1)주단위 빌드(Weekly Build)
  - 2)의존성 비순환 원칙(Acyclic Dependencies Principle, ADP)

#### 1) 주단위 빌드(Weekly Build)
- 중간 규모 프로젝트에서 흔히 사용된다.
- 월-목엔 각자 개발 후 금요일에 통합한다.
  - 장점: 빠른 피드백 및 서로 신경 안쓰고 편하게 개발 가능
  - 단점: 프로젝트 통합시 오래걸림
- 위의 단점으로 인해 시간이 지날수록 통합에드는 시간이 계속 늘어나고 위기를 초래한다.

#### 2) 순환 의존성 제거하기(의존성 비순환 원칙 - Acyclic Dependencies Principle, ADP)
- 이 문제의 해결책은 개발 환경을 릴리스 가능한 컴포넌트 단위로 분리하여 각 컴포넌트 별로 개별 개별자 또는 단일 개발팀이 책임지는 것이다.
  - 개발자가 해당 컴포넌트가 동작하도록 만든 후, 해당 컴포넌트를 릴리스하여 다른 개발자가 사용할 수 있도록 만든다.
  - 담당 개발자는 이 컴포넌트에 릴리스 번호를 부여하고, 다른 팀에서 사용할 수 있는 디렉토리로 이동시킨다.
  - 그런 다음 개발자는 자신만의 공간에서 해당 컴포넌트를 지속적으로 수정한다.
  - 다른 팀에선 새 릴리스를 당장 적용할지 결정하여 이를 사용하거나 이전 릴리스를 그대로 유지한다.
- <b>따라서 어떤 팀도 다른 팀에 의해 좌지우지 되지 않는다. 특정 컴포넌트가 변경되더라도 다른 팀에 즉각 영향을 주지 않는다.</b>
   -  각 팀은 특정 컴포넌트가 새롭게 릴리스되면 자신의 컴포넌트를 해당 컴포넌트에 맞게 수정할 시기를 스스로 결정할 수 있다.
   -  뿐만 아니라 통합은 작고 점진적으로 이뤄진다.
   -  특정 시점에 모든 개발자가 한데 모여서 진행 중인 작업을 모두 통합하는 일은 사라진다.
- 컴포넌트 사이의 의존성 구조는 반드시 관리해야 한다.
  - 의존성 구조에 순환이 절대 생겨선 안된다. 그렇게 되면 숙취증후군이...

![image](https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/df2d13bb-8c58-4023-a9c4-1430258337d7)

- 위 이미지는 전형적인 컴포넌트 다이어그램이다.
- 컴포넌트 의존성 구조는 `방향 그래프` 임에 주의하자.
- 어느 컴포넌트에서 시작하더라도, 의존성 관계를 따라가면서 최초의 컴포넌트로 되돌아갈 수 없게 해야 한다. (비순환 방향 그래프)
  - Presenters를 담당하는 팀에서 이 컴포넌트의 새로운 릴리스를 만들면 무슨일이 벌어질지 생각해보자.
  - 이 릴리스에 영향받는 팀은 쉽게 찾을 수 있다.
  - 의존성 화살표를 거꾸로 따라가면 된다.
  - 즉, View 와 Main 컴포넌트 둘 다 영향 받는다.
  - 이 두 컴포넌트를 작업중인 개발자라면, Presenters의 새로운 릴리스와 자신의 작업물을 언제 통합할지를 반드시 결정해야 한다.
- 또한 Main은 영향 받는 컴포넌트가 전혀 없어서 쉽게 변경 가능하다.
- 시스템 전체를 릴리스해야 하면 상향식으로 진행된다.
  - Entities(컴파일, 테스트, 릴리스) → Database, Interators, → ...
- <b>컴포넌트 구성요소 간 의존성을 파악하고 있으면 시스템을 빌드하는 방법과 순서를 알 수 있다</b>

#### 순환이 컴포넌트 의존성 그래프에 미치는 영향

![image](https://github.com/jeonyoungho/jeonyoungho.github.io/assets/44339530/865f57da-a596-4727-9f10-192ce1302922)

- 컴포넌트 간의 의존성으로 인해 순환 컴포넌트와 관련된 개발자들은 모두 서로에게 얽매일 것이다.
  - Database 컴포넌트 릴리스 -> Entities 와 반드시 호환 -> Authorize 와 호환되도록 신경써야 한다. 
  - 그렇기에 릴리스하기 훨씬 어려워진다. 그러다보면 숙취증후군이...
- 테스트할때 또한 의존된 컴포넌트 체인을 따라 모두 빌드하고 통합해야 하는데 문제가 발생하게 되고 받아들이기도 힘들어진다.
- 이처럼 순환이 생기면 컴포넌트를 분리하기 상당히 어려워지고, 단위 테스트 및 릴리스도 굉장히 어려워지고 에러도 쉽게 발생한다. 게다가 모듈의 개수가 많아짐에 따라 빌드 관련 이슈는 기하급수적으로 증가한다.
- 추가적으로 컴포넌트에 대한 빌드 순서를 파악하기도 상당히 힘들어진다. 올바른 순서라는 것 자체가 없을 수 있다.

#### 순환 끊기


### 논의하고 싶은 내용
- 1) MSA 에서 어떻게 하면 마이크로서비스들을 독립적으로 배포할 수 있을까? => 찾아보기




#### Reference
- [https://wedonttalknemore.tistory.com/19](https://wedonttalknemore.tistory.com/19)
- [https://wedonttalknemore.tistory.com/20](https://wedonttalknemore.tistory.com/20)
- [https://velog.io/@ssuh0o0/Clean-Architecture-14%EC%9E%A5-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EA%B2%B0%ED%95%A9](https://velog.io/@ssuh0o0/Clean-Architecture-14%EC%9E%A5-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EA%B2%B0%ED%95%A9)