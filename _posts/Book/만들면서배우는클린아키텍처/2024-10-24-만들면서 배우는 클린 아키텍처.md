---
title: "[만들면서 배우는 클린 아키텍처] 만들면서 배우는 클린 아키텍처"
date: 2024-10-24 +0800
categories: [책, 만들면서배우는클린아키텍처]
tags: [cleanarchitecture]
toc: true
comments: true
# image: /assets/img/test.png
# pin: true
---

![image](https://github.com/user-attachments/assets/9bbf9f82-5d2b-4b68-88c0-9926dfee5c3c)

> '만들면서 배우는 클린 아키텍처' 기술 서적에 대해 학습했던 내용을 정리하기 위한 목적의 TIL 포스팅입니다.🙆‍♂️

# 시작하기전 추천사 (객체지향의 사실과 오해 저자 조영호)
- 클린아키텍처의 핵심은 의존성 방향으로 비즈니스 로직이 외부 요소에 존재하지 않고 프레젠테이션 계층과 데이터 소스 계층이 도메인 계층에 의존하도록 만들어야 한다는 것이다.
- 애플리케이션은 비즈니스 관심사를 다루는 내부(inside)와 기술적인 관심사를 다루는 외부(outside)로 분해된다. 여기서 외부에 포함된 기술적인 컴포넌트를 어댑터(adapter)라 부르고, 어댑터가 내부와 상호작용하는 접점을 포트(port)라 부른다.
- 에릭 에반스는 <<도메인 주도 설계>>에서 "도메인 주도 설계의 전제 조건은 도메인 구현을 격리시키는 것이다." 라는 말로 내부와 외부의 분리를 강조했다.도메인을 기반으로 애플리케이션을 구축하기 위해선 육각형 아키텍처처럼 경계와 의존성을 강제할 수 있는 아키텍처를 채택하는 것이 중요하다는 사실을 깨달았다.
- **즉, 육각형 아키텍처는 도메인 중심의 개발을 위해 필요한 아키텍처라고도 볼 수 있을것이다.**

# 1장 - 계층형 아키텍처의 문제는 무엇일까?
- 저자의 경험에 의하면 계층형 아키텍처의 문제점은 코드에 나쁜 습관들이 스며들기 쉽게하고 시간이 지날수록 소프트웨어를 점점 더 변경하기 어렵게 만드는 수많은 허점들을 노출한다는 것이다.

## 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.
- 웹 -> 도메인 -> 영속성 으로 흘러가는 의존성 방향은 자연스럽게 데이터베이스에 의존하게 만든다. 즉 모든 것이 영속성 계층을 토대로 만들어진다.
- ORM 프레임워크(JPA)의 사용은 비즈니스 규칙을 영속성 관점과 섞고 싶은 유혹을 쉽게 받는다.

![image](https://github.com/user-attachments/assets/0aba2105-db14-416d-8440-49c2bf819e39)
_출처: https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-1.계층형-아키텍처의-문제는-무엇일까 _

- **위 이미지에서처럼 도메인 계층에선 영속성 계층의 엔티티에 접근하여 사용하기 마련이게 된다. 그렇게 되면 두 계층 간의 강한 결합이 생기게되고 서비스는 영속성 모델을 비즈니스 모델로처럼 사용하게 되고 이로 인해 도메인 로직뿐만이 아닌 즉시로딩, DB트랜잭션 등 영속성 계층과 관련된 작업들을 해야만 한다.**

- 우리는 상태(state)가 아닌 행동(behavior)을 중심으로 모델링한다. 어떤 애플리케이션이든 상태가 중요한 요소긴하지만 행동이 상태를 바꾸는 주체이기 떄문에 행동이 비즈니스를 이끌어간다.
- 비즈니스 관점에선 영속성계층보단 도메인 로직을 먼저 만들어야 한다. 그래야만 우리가 로직을 제대로 이해했는지 확인할 수 있고 이를 기반으로 영속성 계층과 웹 계층을 만들어야 한다.
  - 나의 생각🧐: 현재 실무에서 보통 API 스펙을 먼저 정의후에 비즈니스 로직을 구현하게 되는것 같다. 그 스펙에 맞춰 클라이언트(FE, ME) 개발자들이 화면 구현을 진행하게 되는데 위의 방법으로 적용해봐도 좋을것 같다.

## 지름길을 택하기 쉬워진다.

![image](https://github.com/user-attachments/assets/f4f46189-f9fa-4bff-9b18-31c37aab9e78)
_출처: https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-1.계층형-아키텍처의-문제는-무엇일까 _

- 레이어드 아키텍처에서 만약 상위 계층에 위치한 컴포넌트에 접근해야 한다면 간단하게 해당 컴포넌트를 계층 아래로 내려버리면 된다.
- 그럼 위 이미지처럼 영속성 계층이 비대해지게 될 것이다.
- 아키텍처 관점에서 강제하지 않으면 (코드리뷰 수준이 아닌 빌드가 안되도록 하는 수준으로) 여러가지 핑계로(마감이 얼마 안남았다는 등) 아키텍처는 유지보수하기 어렵게되버릴것이다.
- 모두 그렇다. 한 번은 괜찮을것이다. 근데 한 번하게 되면 누군가 쉽게 또 하게될것이다..

## 테스트하기 어려워진다

![image](https://github.com/user-attachments/assets/c2a2ed87-c314-4675-b242-e8d3952feb1f)
_출처: https://dgle.dev/clean-arch-1/_

- 계층형 아키텍처에서 일반적으로 계층을 건너뛰는 변화가 나타난다.
  - 엔티티의 필드를 단 하나만 조작하면 되는 경우 웹 계층에서 바로 영속성 계층에 접근하는 것이다. (도메인 계층을 건너띄고)
- 두 가지 문제점이 있다.
  - 1)도메인 로직을 웹 계층에 구현하게 되는것. 유스케이스가 확장되면 웹 계층에 더 많아질것이고 애플리케이션 전반에 걸쳐 책임이 섞이고 도메인 로직들이 퍼져나가 유지보수성이 떨어지게될것
  - 2)웹 계층 테스트에서 도메인 계층뿐만 아닌 영속성 계층도 모킹하게 되어 단위 테스트 복잡도가 올라가고 테스트를 작성하지 않게되는것. 웹 컴포넌트의 규모가 커지면 다양한 영속성 컴포넌트에 의존성이 많이 쌓이며 테스트 복잡도는 더 올라갈것이다..

## 유스케이스를 숨긴다

![image](https://github.com/user-attachments/assets/f9eb59f3-c4b2-4798-ba0b-791a63eebc76)
_출처: https://dgle.dev/clean-arch-1/_

- **계층형 아키텍처는 도메인 서비스의 '너비' 에 관한 규칙을 강제하지 않다보니 위 이미지처럼 여러 개의 유스케이스를 담당하는 아주 넓은 서비스가 만들어지기도 한다.**
- 넓은 서비스는 영속성 계층에 많은 의존성을 갖게 되고, 다시 웹 레이어의 많은 컴포넌트가 이 서비스에 의존하게 된다. **그럼 서비스를 테스트하기도 어려워지고 작업해야할 유스케이스를 책임지는 서비스를 찾기도 어려워진다.**
- 고돌 특화된 좁은 도메인 서비스가 유스케이스 하나씩만 담당하게 한다면 위와 같은 작업들은 수월해질것이다. ex. UserService 에서 사용자 등록 유스케이스를 찾는 대신 RegisterUserService 를 바로 열어서 작업을 시작하는 것처럼 말이다.

## 동시 작업이 어려워진다.
- 개발 인원이 늘어난다했을때 생산성이 그만큼 늘어나려면 아키텍처가 동시 작업을 지원해야 한다. 하지만 이는 쉽지 않다.. 
- 그리고 계층형 아키텍처는 그다지 위의 관점에서 도움되지 않는다. 모든 것이 영속성 계층 위에 만들어지기에 `영속성 계층 -> 도메인 계층 -> 웹 계층` 의 순으로 이뤄져야하고 새로운 유스케이스를 추가해야한다면 동시에 한 명의 개발자만 작업할 수 있게 된다.
- DB 주도 설계는 영속성 로직이 도메인 로직과 너무 뒤섞여서 각 측면을 개별적으로 작업할수 없기 때문이다.
- 또한 코드에 넓은 서비스가 있다면 같은 서비스를 동시 편집하는 상황이 발생하는 일이 잦게될것이고 병합 충돌(merge conflict)과 잠재적으로 이전 코드로 되돌려야 하는 문제를 야기하게 된다.

## 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?
- 물론 계층형 아키텍처를 올바르게 구축후 몇가지 추가적인 규칙들을 적용하면 유지보수하기 매우 쉬워지며 코드를 쉽게 변경 or 추가할 수 있게 된다.
- 그러나 앞에서 살펴봤듯이 계층형 아키텍처는 많은것들이 잘못된 방향으로 흘러가도록 용인한다. 아주 엄격한 자기훈련 없이는 시간이 지날수록 품질이 저하되고 유지보수하기 어려워지기 쉽다. 그리고 마감일이 새로 픽스될때마다 이러한 자기훈련은 느슨해질것이다.
- 계층형 아키텍처로 만들든 다른 아키텍처 스타일로 만들든, 계층형 아키텍처의 함정을 염두에 두면 지름길을 택하지 않고 유지보수하기 더 쉬운 솔루션을 만드는데 도움이될 것이다. 

# 2장 - 의존성 역전하기
이번장에선 계층형 아키텍처 문제점에 대한 대안을 이야기한다.

## 단일 책임 원칙
- 하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다.(X)
  - 좋은 조언이지만 SRP 의 실제의도는 아니다
- 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.(O)
  - 책임은 1가지 일만 하는 것 보다 변경할 이유로 해석해야 한다.
  - 단일변경 이유 원칙(Single Reson to Change Principle) 이 적절할 수도 있다.
  - 변경 이유가 1개일때 1가지 일만 하는 것은 자동으로 따라온다.

> **note**: 컴포넌트를 변경할 이유가 1가지라면 어떤 다른 이유로 소프트웨어를 변경하더라도 이 컴포넌트에 대해서는 전혀 신경 쓸 필요가 없다. 소프트웨어가 변경되더라도 여전히 우리가 기대한 대로 동작할 것이다.

- 하지만 변경할 이유는 컴포넌트 의존성을 통해 너무 쉽게 전파된다.

![image](https://github.com/user-attachments/assets/a4f342f7-1f5f-4afc-9a7c-fea1d205fb18)
_출처: https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-1.계층형-아키텍처의-문제는-무엇일까 _

- 컴포넌트 E 의 경우 의존하는 것이 없으므로 변경할 유일한 이유가 E의 기능이 바뀔때 뿐이다
- 컴포넌트 A 의 경우 모든 컴포넌트를 의존하므로 어떤 컴포넌트가 바뀌어도 같이 바뀌어야 한다.
- SRP 위반시 변경하기가 더 어려워진다. 다른 컴포넌트의 실패요인으로 작용될 수 있다.

## 부수효과에 관한 이야기
- 저자는 클라이언트로 하여금 잘못 구조화된 소프트웨어를 변경하는데 더 많은 비용을 지불하도록 만드는 경우가 있었다.

## 의존성 역전 원칙

> **note**: 코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다.

- 사실 의존성 양쪽 코들르 모두 제어할 수 있을때만 의존성을 역전시킬 수 있따. 만약 서드파티 라이브러리에 의존성이 있다면 의존성을 역전시킬 수 없다.

![image](https://github.com/user-attachments/assets/a16c93a4-0211-4f82-b36e-091540104a90)
_출처: https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-1.계층형-아키텍처의-문제는-무엇일까 _

- 계층형 아키텍처에서 계층간 의존성은 항상 다음 계층인 아래 방향을 가리킨다. 단일 책임 원칙을 고수준에서 적용할때 상취 계층들이 하위 계층들에 비해 변경할 이유가 더 많다는것을 알 수 있다.
- 그러므로 영속성 계층에 대한 도메인 계층의 의존성 때문에 영속성 계층을 변경할때마다 잠재적으로 도메인 계층도 변경해야 한다. 그러나 도메인 코드는 애플리케이션에서 가장 중요한 영역이므로 영속성 코드가 바뀐다해서 도메인 코드까지 바꾸고 싶진 않다.
- 이 의존성을 어떻게 제거할 수 있을까? DIP를 적용(도메인 코드와 영속성 코드 간의 의존성을 역전시켜 도메인 코드를 '변경할 이유'의 개수를 줄임으로써)함으로써 가능하다.
- 엔티티를 도메인 계층으로 올리고 도메인 계층에 리포지토리 인터페이스를 만들고, 실제 리포지토리 구현체를 영속성 계층에서 구현(DIP 실제 적용)하게 하면 된다.

![image](https://github.com/user-attachments/assets/c9ac9786-9905-4ac4-805a-b3d8a994c40e)
_출처: https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-1.계층형-아키텍처의-문제는-무엇일까 _

- 이 묘수로 영속성 코드에 있는 숨막히는 의존성으로부터 도메인 로직을 해방시켰다.

## 클린 아키텍처
- 로버트 마틴은 '클린 아키텍처'라는 용어를 같은 이름의 책에서 정립했다.
- 그는 클린 아키텍처에서는 설계가 비즈니스 규칙의 테스트를 용이하게 하고, 비즈니스 규칙은 프레임워크, DB, UI기술, 그 밖의 외부 애플맄네이션이나 인터페이스로부터 독립적일수있다고 이야기했다.
- **이는 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야함을 의미한다. 대신 의존성 역전 원칙의 도움으로 모든 의존성이 안쪽(도메인 코드)을 향하고 있다.**

![image](https://github.com/user-attachments/assets/63fce979-8677-4e55-a4b0-43c1d1cd969a)
_출처: https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-1.계층형-아키텍처의-문제는-무엇일까 _

- 이 아키텍처에서 코어에는 주변 유스케이스에서 접근하는 도메인 엔티티들이 있다. 유스케이스는 앞에서 서비스라 불렀던것들인데, 단일 책임(즉, 변경할 단 한 가지의 이유)을 갖기 위해 조금 더 세분화돼 있다. 이를 통해 이전에 이야기했던 `넓은 서비스 문제`를 피할 수 있다.
- 도메인 코드에서는 어떤 영속성 프레임워크나 UI 프레임워크가 사용되는지 알 수 없기 떄문에 특정 프레임워크에 특화된 코드를 가질 수 없고 비즈니스 규칙에 집중할 수 있다.
  - 그래서 도메인 코드를 자유롭게 모델링할 수 있다.
  - 예를 들어, 도메인 주도 설계(DDD)를 가장 순수한 형태로 적용해볼수도 있다.
  - 영속성이나 UI에 특화된 문제를 신경쓰지 않아도 된다면 이렇게 하기 굉장히 수월해진다.
- 하지만 클린아키텍처에선 대가가 따른다. 도메인 계층이 영속성이나 UI 같은 외부 계층과 철저히 분리돼야 하므로 애플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수해야 한다.
  - **가령 영속성 계층에서 ORM프레임워크를 사용한다 했을떄 도메인 계층은 영속성 계층을 모르기 때문에 도메인 계층에서 사용한 엔티티 클래스를 영속성 계층에서 함께 사용할 수 없고 두 계층에서 각각 엔티티를 만들어 관리해야 한다. 즉, 도메인 계층과 영속성 계층이 데이터를 주고 받을때, 두 엔티티를 서로 변환해야 한다는 뜻이다.**
  - 이는 도메인 계층과 다른 계층들 사이에서도 마찬가지다.
  - **실제 개인적인 경험으로 매번 컨버팅 작업을 해줘야하는 번거로운 작업임에도 불구하고 이는 바람직한 일이다. 이것이 바로 도메인 코드를 프레임워크에 특화된 문제로부터 해방시키고자 했던, 결합이 제거된 상태다.**
  - **가령 JPA 에선 ORM이 관리하는 엔티티에 인자가 없는 기본 생성자를 추가하도록 강제하는데 이것이 도메인 모델에는 포함해서는 안될 프레임워크에 특화된 결합의 예이다.**
  - 8장에선 도메인 계층과 영속성 계층의 결합을 그대로 수용하는 '매핑하지 않기' 전략을 비롯한 여러 매핑 전략에 대해 살펴보겠다.
- 로버트 마틴의 클린 아키텍처는 다소 추상적이기에 조금 더 깊게 들어가서 클린 아키텍처의 원칙들을 조금 더 구체적으로 만들어주는 '육각형 아키텍처'에 대해 살펴보자.

## 육각형 아키텍처(헥사고날 아키텍처)

![image](https://github.com/user-attachments/assets/9496eb1d-bc54-4d94-860b-d42e7209231f)
_출처: https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-1.계층형-아키텍처의-문제는-무엇일까 _

- 알리스테어 콕번이 만든 용어로 애플리케이션 코어가 육각형으로 표현되다보니 붙여진 이름이다.
- 육각형에서 외부로 향하는 의존성이 없기 때문에 마틴이 클린 아키텍처에서 제시한 의존성 규칙이 그대로 적용된다는 점을 주목하자. 대신 모든 의존성은 코어를 향한다.
- 왼쪽에 있는 어댑터들은 (애플리케이션 코어를 호출하기 때문에) 애플리케이션을 주도하는 어댑터들이고, 반면 오른쪽 어댑터들은 (애플리케이션 코어에 의해 호출되기 때문에) 애플리케이션에 의해 주도되는 어댑터들이다.
- 애플리케이션 코어와 어댑터들간의 통신이 가능하려면 애플리케이션 코어가 각각의 포트를 제공해야 한다. 주도하는 어댑터(driving adapter)에게는 그러한 포트가 코어에 있는 유스케이스 클래스 중 하나에 의해 구현되고 어댑터에 의해 호출되는 인터페이스가 될것이고, 주도되는 어댑터(driven adapter)에게는 그러한 포트가 어댑터에 의해 구현되고 코어에 의해 호출되는 인터페이스가 될 것이다.
- 이러한 핵심 개념으로 '포트와 어댑터' 아키텍처로도 알려져 있다.

## 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?
- 의존성을 역전시켜 도메인 코드가 다른 바깥쪽 코드에 의존하지 않게 함으로써 영속성과 UI에 특화된 모든 문제로부터 도메인 로직의 결합을 제거하고 코드를 변경할 이유의 수를 줄일 수 있다. 그리고 변경할 이유가 적을수록 유지보수성은 좋아진다.
- 또한 도메인 코드는 비즈니스 문제 딱 맞도록 자유롭게 모델링 가능해지고, 영속성 코드와 UI코드도 영속성 문제와 UI문제에 맞게 자유롭게 모델링될 수 있다.

# 3장 - 코드 구성하기
- 코드를 구성하는 몇 가지 방법을 살펴보고, 육각형 아키텍처를 직접적으로 반영하는 표현력있는 패키지 구조를 소개한다.
- [BuckPal](https://github.com/wikibook/clean-architecture) 예제 코드를 구조화히기 위한 여러 가지 방법들을 살펴본다. 사용자가 본인 계좌에서 다른 계좌로 돈을 송금할 수 있는 '송금하기' 유스케이스를 살펴본다.

## 계층으로 구성하기

```
buckapl
|--- domain
|    |----- Account
|    |----- Activity
|    |----- AccountRepository
|    |----- AccountService
|--- persistence
|    |----- AccountRepositoryImpl
|--- web
|    |----- AccountController
```

- 계층으로 코드를 구성하면, 기능적인 측면들이 섞이기 쉽다.

### 문제점
#### 문제1 : 애플리케이션의 기능 조각(functional slice) 이나 특징(feature) 을 구분 짓는 패키지 경계가 없다
- 사용자를 관리하는 기능을 추가한다면 web패키지 domain 패키지, persistence 패키지에 관련 클래스가 추가될것이다.
- 추가적인 구조가 없다면, 아주 빠르게 서로 연관되지 않은 기능들끼리 예상하지 못한 부수효과를 일으킬 수 있는 클래스들의 묶음으로 변모할 수 있다.

#### 문제2 : 애플리케이션이 어떤 유스케이스들을 제공하는지 파악할 수 없다.
- 특정 기능을 찾기 위해 어떤 서비스가 어떤 함수에서 이에 대한 책임을 구현했는지 추측해야 한다.

#### 문제3 : 패키지 구조를 통해서는 우리의 목표로 하는 아키텍처를 파악할 수 없다.
- 어떤 기능이 웹 어댑터에서 호출되는지, 영속성 어댑터가 도메인 계층에 어떤 기능을 제공하는지 한 눈에 알 수 없다.
- 인커밍(incoming) 포트와 아웃고인(outgoing) 포트가 코드 속에 숨겨져 있다.

## 기능으로 구성하기

```
buckpal
|-- account
    |-- Account
    |-- AccountController
    |-- AccountRepository
    |-- AccountRepositoryImpl
    |-- SendMoneyService
```

- acouunt 패키지로 묶고 계층 패키지를 없앴다.
- 기능 기준으로 구조화시엔 기반 아키텍처가 명확히 보이지 않는다.

### 장점
- 패키지 외부에서 접근하면 안되는 클래스들에 대해 package-private 접근 수준을 이용해 패키지 간의 경계를 강화할 수 있다.
- 패키지 경계를 package-private 접근 수준과 결합하면 각 기능사이의 불필요한 의존성을 방지할 수 있다.
- SendMoneyService 와 같이 송금하기 기능을 구현한 클래스를 클래스명으로 바로 찾을 수 있다.(소리치는 아키텍처)

### 단점
- 아키텍처의 가시성을 계층방식보다 훨씬 더 떨어뜨린다.
  - 어댑터를 나타내는 패키지명도 없다. 인커밍 포트, 아웃고인 포트도 없다.
  - 인터페이스만 알고 구현체를 알수 없게 했지만 패키지 내부 package-private 접근 수준으로 구현체를 자유롭게 접근할 수 있다.

## 아키텍처적으로 표현력 있는 패키지 구조

```
buckpal
|-- account
    |-- adapter
    |   |-- in
    |   |   |-- web
    |   |       |-- AccountController
    |   |-- out
    |   |   |-- persistence
    |   |       |-- AccountPersistenceAdapter
    |   |       |-- SpringDataAccountRepository
    |-- domain
    |   |-- Account
    |   |-- Activity
    |-- application
        |-- SendMoneyService
        |-- port
            |-- in
            |   |-- SendMoneyUseCase
            |-- out
            |   |-- LoadAccountPort
            |   |-- UpdateAccountStatePort
```

- 육각형 아키텍처의 핵심적인요소 : 엔티티, 유스케이스, 인커밍/아웃고잉 포트, 인커밍/아웃고잉 어댑터
- 최상위에 Account 관련 유스케이스를 구현한 모듈임을 나타내는 account 패키지
- 도메인 모델에 속한 domain 패키지
- 서비스 계층(인커밍 포트 구현체)이 속한 application 패키지
- 인커밍 포트 인터페이스, 아웃고잉 포트 인터페이스가 속한 application 패키지
- 인커핑 포트를 호출하는 인커밍 어댑터와 아웃고인 포트에 대한 구현을 제공하는 아웃고잉 어댑터가 속한 adapter 패키지
- 만약 서드파티 API에 대한 클라이언트를 변경하는 작업이 추가된다면 adapter/out/{어댑터 이름} 패키지에서 바로 구현하면 되고 수정이 필요할때 바로 찾을 수 있다.

### 장점

#### 장점1: 모델-코드 갭(아키텍처-코드 갭)을 효과적으로 다룰 수 있다.
- 아키텍처를 직접적으로 매핑후 반영할 수 있다는 점이다.
- 만약 패키지 구조가 아키텍처를 반영할 수 없다면 시간이 지남에 따라 코드는 점점 목표하던 아키텍처로부터 멀어지게 된다.
- 또한, 이처럼 표현력 있는 패키지 구조는 아키텍처에 대한 적극적인 사고를 촉진한다.
  - 많은 패키지가 생기고, 현재 작업 중인 코드를 어떤 패키지에 넣어야 할지 계쏙 생각하기 때문이다.

#### 장점2: 패키지간 접근을 제어할 수 있다.
- 패키지가 아주 많다는 것은 모든것을 public 으로 만들어 패키지간 접근을 허용해야 한다는것을 의미하진 않는다.
- 적어도 adapter 패키지에 대해선 그렇지 않다. 이 패키지에 들어 있는 모든 클래스들은 application 패키지 내에 있는 포트 인터페이스를 통하지 않고는 바깥에서 호출되지 않기 때문에 package-private 접근 수준으로 둬도 된다. 그러므로 애플리케이션 계층에서 adapter 클래스로 향하는 우발적인 의존성은 있을 수 없다.
- 하지만 application 패키지와 domain 패키지 내의 일부 클래스들은 public 이어야 한다. 도메인 클래스들은 서비스, 그리고 잠재적으로 어댑터에서도 접근 가능하도록 public 이어야 한다. 서비스는 인커밍 포트 인터페이스 뒤에 숨겨질 수 있기 때문에 public 일 필요가 없다.

#### 장점3: 어댑터 교체가 용이하다
- 하나의 어댑터를 다른 구현으로 쉽게 교체할 수 있다.
- 예를 들어, 최종적으로 어떤 DB 쓸지 결정되지 않은 상태에서 간단히 키-밸류 DB로 개발을 시작했는데, RDB로 교체해야 한다면 간단히 관련 아웃고잉 포트들만 새로운 adapter 패키지에 구현하고 기존 패키지를 지우면 된다.

#### 장점4: DDD 개념에 직접적으로 대응시킬 수 있다.
- 예제 코드에서 account 같은 상위 레벨 패키지는 다른 바운디드 컨텍스트(bounded context)와 통신할 전용 진입점과 출구(포트)를 포함하는 바운디드 컨텍스트에 해당한다.
- domain 패키지 내에서는 DDD가 제공하는 모든 도구를 이용해 우리가 원하는 어떤 도메인 모델이든 만들 수 있다.

> 모든 구조와 마찬가지로 패키지 구조를 소프트웨어 프로젝트 내내 유지하기 위해서는 지켜야할 규칙이 있다. 또한 패키지 구조가 적합하지 않아서 어쩔 수 없이 아키텍처-코드 갭을 넓히고 아키텍처를 반영하지 않는 패키지를 만들어야 하는 경우도 생길 수 있다. 완벽한 방법은 없다. 그러나 표현력 있는 패키지 구조는 적어도 코드와 아키텍처 간의 갭을 줄일 수 있게 해준다.

## 의존성 주입의 역할
- 클린 아키텍처의 가장 본질적인 요건은 2장에서 나왔다시피 애플리케이션 계층이 인커밍/아웃고잉 어댑터에 의존성을 갖지 않는 것이다.
- 예제 코드의 웹 어댑터와 같이 인커밍 어댑터에 대해서는 그렇게 하기가 쉽다. 제어 흐름의 방향이 어댑터와 도메인 코드 간의 의존성 방향과 같은 방향이기 때문이다.
- 반면 영속성 어댑터와 같이 아웃고잉 adapter 에 대해서는 제어 흐름의 반대 방향으로 의존성을 돌리기 위해 의존성 역전 원칙을 이용해야 한다.
- 애플리케이션 계층에 인터페이스를 만들고 어댑터에 해당 인터페이스를 구현한 클래스를 두면 된다. 육각형 아키텍처에서는 이 인터페이스가 포트다. 아래 이미지와 같이 애플리케이션 계층은 어댑터의 기능을 실행하기 위해 이 포트 인터페이스를 호출한다.
- 그런데 포트 인터페이스를 구현한 실제 객체를 누가 애플리케이션 계층에 제공해야 할까? => 이 부분에서 의존성 주입을 활용할 수도 있다. 모든 계층에 읜존성을 가진 중림적인 컴포넌트를 하나 도입하는 것이다. 이 컴포넌트는 아키텍처를 구성하는 대부분의 클래스를 초기화하는 역할을 한다.

![image](https://github.com/user-attachments/assets/9e40f300-a0c3-4166-9bbc-5e4eb0fdae49)
_출처: https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-3.-코드-구성하기_

- `AccountController`
  - SendMoneyUseCase 인터페이스가 필요하므로 의존성 주입을 통해 SendMoneyService 클래스의 인스턴스를 주입
  - AccountController 는 SendMoneyUseCase 인터페이스의 실제 구현체가 SendMoneyService 인지 모른다.
- `SendMoneyService`
  - LoadAccount 인터페이스로 가장한 AccountPersistenceAdapter 클래스의 인스턴스 주입
  - SendMoneyService 는 SendMony LoadAccount 인터페이스의 실제 구현체가 AccountPersistenceAdapter 인지 모른다.

## 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?
- 코드에서 아키텍처의 특정 요소를 찾으려면 이제 아키텍처 다이어그램의 박스 이름을 따라 패키지 구조를 탐색하면 된다. 이로써 의사소통, 개발, 유지보수 모두가 조금 더 수월해진다.


# Reference
- [https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-1.계층형-아키텍처의-문제는-무엇일까](https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-1.계층형-아키텍처의-문제는-무엇일까)
- [https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-2.-의존성-역전하기](https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-2.-의존성-역전하기)
- [https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-3.-코드-구성하기](https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-3.-코드-구성하기)
- [https://dgle.dev/clean-arch-1/](https://dgle.dev/clean-arch-1/)