---
title: "[만들면서 배우는 클린 아키텍처] 만들면서 배우는 클린 아키텍처"
date: 2024-10-24 +0800
categories: [책, 만들면서배우는클린아키텍처]
tags: [cleanarchitecture]
toc: true
comments: true
# image: /assets/img/test.png
# pin: true
---

![image](https://github.com/user-attachments/assets/9bbf9f82-5d2b-4b68-88c0-9926dfee5c3c)

> '만들면서 배우는 클린 아키텍처' 기술 서적에 대해 학습했던 내용을 정리하기 위한 목적의 TIL 포스팅입니다.🙆‍♂️

# 시작하기전 추천사 (객체지향의 사실과 오해 저자 조영호)
- 클린아키텍처의 핵심은 의존성 방향으로 비즈니스 로직이 외부 요소에 존재하지 않고 프레젠테이션 계층과 데이터 소스 계층이 도메인 계층에 의존하도록 만들어야 한다는 것이다.
- 애플리케이션은 비즈니스 관심사를 다루는 내부(inside)와 기술적인 관심사를 다루는 외부(outside)로 분해된다. 여기서 외부에 포함된 기술적인 컴포넌트를 어댑터(adapter)라 부르고, 어댑터가 내부와 상호작용하는 접점을 포트(port)라 부른다.
- 에릭 에반스는 <<도메인 주도 설계>>에서 "도메인 주도 설계의 전제 조건은 도메인 구현을 격리시키는 것이다." 라는 말로 내부와 외부의 분리를 강조했다.도메인을 기반으로 애플리케이션을 구축하기 위해선 육각형 아키텍처처럼 경계와 의존성을 강제할 수 있는 아키텍처를 채택하는 것이 중요하다는 사실을 깨달았다.
- **즉, 육각형 아키텍처는 도메인 중심의 개발을 위해 필요한 아키텍처라고도 볼 수 있을것이다.**

# 1장 - 계층형 아키텍처의 문제는 무엇일까?
- 저자의 경험에 의하면 계층형 아키텍처의 문제점은 코드에 나쁜 습관들이 스며들기 쉽게하고 시간이 지날수록 소프트웨어를 점점 더 변경하기 어렵게 만드는 수많은 허점들을 노출한다는 것이다.

## 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.
- 웹 -> 도메인 -> 영속성 으로 흘러가는 의존성 방향은 자연스럽게 데이터베이스에 의존하게 만든다. 즉 모든 것이 영속성 계층을 토대로 만들어진다.
- ORM 프레임워크(JPA)의 사용은 비즈니스 규칙을 영속성 관점과 섞고 싶은 유혹을 쉽게 받는다.

![image](https://github.com/user-attachments/assets/0aba2105-db14-416d-8440-49c2bf819e39)
_출처: https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-1.계층형-아키텍처의-문제는-무엇일까 _

- **위 이미지에서처럼 도메인 계층에선 영속성 계층의 엔티티에 접근하여 사용하기 마련이게 된다. 그렇게 되면 두 계층 간의 강한 결합이 생기게되고 서비스는 영속성 모델을 비즈니스 모델로처럼 사용하게 되고 이로 인해 도메인 로직뿐만이 아닌 즉시로딩, DB트랜잭션 등 영속성 계층과 관련된 작업들을 해야만 한다.**

- 우리는 상태(state)가 아닌 행동(behavior)을 중심으로 모델링한다. 어떤 애플리케이션이든 상태가 중요한 요소긴하지만 행동이 상태를 바꾸는 주체이기 떄문에 행동이 비즈니스를 이끌어간다.
- 비즈니스 관점에선 영속성계층보단 도메인 로직을 먼저 만들어야 한다. 그래야만 우리가 로직을 제대로 이해했는지 확인할 수 있고 이를 기반으로 영속성 계층과 웹 계층을 만들어야 한다.

## 지름길을 택하기 쉬워진다.

![image](https://github.com/user-attachments/assets/f4f46189-f9fa-4bff-9b18-31c37aab9e78)
_출처: https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-1.계층형-아키텍처의-문제는-무엇일까 _

- 레이어드 아키텍처에서 만약 상위 계층에 위치한 컴포넌트에 접근해야 한다면 간단하게 해당 컴포넌트를 계층 아래로 내려버리면 된다.
- 그럼 위 이미지처럼 영속성 계층이 비대해지게 될 것이다.
- 아키텍처 관점에서 강제하지 않으면 (코드리뷰 수준이 아닌 빌드가 안되도록 하는 수준으로) 여러가지 핑계로(마감이 얼마 안남았다는 등) 아키텍처는 유지보수하기 어렵게되버릴것이다.
- 모두 그렇다. 한 번은 괜찮을것이다. 근데 한 번하게 되면 누군가 쉽게 또 하게될것이다..

## 테스트하기 어려워진다

![image](https://github.com/user-attachments/assets/c2a2ed87-c314-4675-b242-e8d3952feb1f)
_출처: https://dgle.dev/clean-arch-1/_

- 계층형 아키텍처에서 일반적으로 계층을 건너뛰는 변화가 나타난다.
  - 엔티티의 필드를 단 하나만 조작하면 되는 경우 웹 계층에서 바로 영속성 계층에 접근하는 것이다. (도메인 계층을 건너띄고)
- 두 가지 문제점이 있다.
  - 1)도메인 로직을 웹 계층에 구현하게 되는것. 유스케이스가 확장되면 웹 계층에 더 많아질것이고 애플리케이션 전반에 걸쳐 책임이 섞이고 도메인 로직들이 퍼져나가 유지보수성이 떨어지게될것
  - 2)웹 계층 테스트에서 도메인 계층뿐만 아닌 영속성 계층도 모킹하게 되어 단위 테스트 복잡도가 올라가고 테스트를 작성하지 않게되는것. 웹 컴포넌트의 규모가 커지면 다양한 영속성 컴포넌트에 의존성이 많이 쌓이며 테스트 복잡도는 더 올라갈것이다..

## 유스케이스를 숨긴다

![image](https://github.com/user-attachments/assets/f9eb59f3-c4b2-4798-ba0b-791a63eebc76)
_출처: https://dgle.dev/clean-arch-1/_

- **계층형 아키텍처는 도메인 서비스의 '너비' 에 관한 규칙을 강제하지 않다보니 위 이미지처럼 여러 개의 유스케이스를 담당하는 아주 넓은 서비스가 만들어지기도 한다.**
- 넓은 서비스는 영속성 계층에 많은 의존성을 갖게 되고, 다시 웹 레이어의 많은 컴포넌트가 이 서비스에 의존하게 된다. **그럼 서비스를 테스트하기도 어려워지고 작업해야할 유스케이스를 책임지는 서비스를 찾기도 어려워진다.**
- 고돌 특화된 좁은 도메인 서비스가 유스케이스 하나씩만 담당하게 한다면 위와 같은 작업들은 수월해질것이다. ex. UserService 에서 사용자 등록 유스케이스를 찾는 대신 RegisterUserService 를 바로 열어서 작업을 시작하는 것처럼 말이다.

## 동시 작업이 어려워진다.
- 개발 인원이 늘어난다했을때 생산성이 그만큼 늘어나려면 아키텍처가 동시 작업을 지원해야 한다. 하지만 이는 쉽지 않다.. 
- 그리고 계층형 아키텍처는 그다지 위의 관점에서 도움되지 않는다. 모든 것이 영속성 계층 위에 만들어지기에 `영속성 계층 -> 도메인 계층 -> 웹 계층` 의 순으로 이뤄져야하고 새로운 유스케이스를 추가해야한다면 동시에 한 명의 개발자만 작업할 수 있게 된다.
- DB 주도 설계는 영속성 로직이 도메인 로직과 너무 뒤섞여서 각 측면을 개별적으로 작업할수 없기 때문이다.
- 또한 코드에 넓은 서비스가 있다면 같은 서비스를 동시 편집하는 상황이 발생하는 일이 잦게될것이고 병합 충돌(merge conflict)과 잠재적으로 이전 코드로 되돌려야 하는 문제를 야기하게 된다.

## 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?
- 물론 계층형 아키텍처를 올바르게 구축후 몇가지 추가적인 규칙들을 적용하면 유지보수하기 매우 쉬워지며 코드를 쉽게 변경 or 추가할 수 있게 된다.
- 그러나 앞에서 살펴봤듯이 계층형 아키텍처는 많은것들이 잘못된 방향으로 흘러가도록 용인한다. 아주 엄격한 자기훈련 없이는 시간이 지날수록 품질이 저하되고 유지보수하기 어려워지기 쉽다. 그리고 마감일이 새로 픽스될때마다 이러한 자기훈련은 느슨해질것이다.
- 계층형 아키텍처로 만들든 다른 아키텍처 스타일로 만들든, 계층형 아키텍처의 함정을 염두에 두면 지름길을 택하지 않고 유지보수하기 더 쉬운 솔루션을 만드는데 도움이될 것이다. 

# 2장 - 의존성 역전하기
이번장에선 계층형 아키텍처 문제점에 대한 대안을 이야기한다.

## 단일 책임 원칙
- 하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다.(X)
  - 좋은 조언이지만 SRP 의 실제의도는 아니다
- 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.(O)
  - 책임은 1가지 일만 하는 것 보다 변경할 이유로 해석해야 한다.
  - 단일변경 이유 원칙(Single Reson to Change Principle) 이 적절할 수도 있다.
  - 변경 이유가 1개일때 1가지 일만 하는 것은 자동으로 따라온다.

> **note**: 컴포넌트를 변경할 이유가 1가지라면 어떤 다른 이유로 소프트웨어를 변경하더라도 이 컴포넌트에 대해서는 전혀 신경 쓸 필요가 없다. 소프트웨어가 변경되더라도 여전히 우리가 기대한 대로 동작할 것이다.

- 하지만 변경할 이유는 컴포넌트 의존성을 통해 너무 쉽게 전파된다.

![image](https://github.com/user-attachments/assets/a4f342f7-1f5f-4afc-9a7c-fea1d205fb18)
_출처: https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-1.계층형-아키텍처의-문제는-무엇일까 _

- 컴포넌트 E 의 경우 의존하는 것이 없으므로 변경할 유일한 이유가 E의 기능이 바뀔때 뿐이다
- 컴포넌트 A 의 경우 모든 컴포넌트를 의존하므로 어떤 컴포넌트가 바뀌어도 같이 바뀌어야 한다.
- SRP 위반시 변경하기가 더 어려워진다. 다른 컴포넌트의 실패요인으로 작용될 수 있다.

## 부수효과에 관한 이야기
- 저자는 클라이언트로 하여금 잘못 구조화된 소프트웨어를 변경하는데 더 많은 비용을 지불하도록 만드는 경우가 있었다.

## 의존성 역전 원칙

> **note**: 코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다.

- 사실 의존성 양쪽 코들르 모두 제어할 수 있을때만 의존성을 역전시킬 수 있따. 만약 서드파티 라이브러리에 의존성이 있다면 의존성을 역전시킬 수 없다.

![image](https://github.com/user-attachments/assets/a16c93a4-0211-4f82-b36e-091540104a90)
_출처: https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-1.계층형-아키텍처의-문제는-무엇일까 _

- 계층형 아키텍처에서 계층간 의존성은 항상 다음 계층인 아래 방향을 가리킨다. 단일 책임 원칙을 고수준에서 적용할때 상취 계층들이 하위 계층들에 비해 변경할 이유가 더 많다는것을 알 수 있다.
- 그러므로 영속성 계층에 대한 도메인 계층의 의존성 때문에 영속성 계층을 변경할때마다 잠재적으로 도메인 계층도 변경해야 한다. 그러나 도메인 코드는 애플리케이션에서 가장 중요한 영역이므로 영속성 코드가 바뀐다해서 도메인 코드까지 바꾸고 싶진 않다.
- 이 의존성을 어떻게 제거할 수 있을까? DIP를 적용(도메인 코드와 영속성 코드 간의 의존성을 역전시켜 도메인 코드를 '변경할 이유'의 개수를 줄임으로써)함으로써 가능하다.
- 엔티티를 도메인 계층으로 올리고 도메인 계층에 리포지토리 인터페이스를 만들고, 실제 리포지토리 구현체를 영속성 계층에서 구현(DIP 실제 적용)하게 하면 된다.

![image](https://github.com/user-attachments/assets/c9ac9786-9905-4ac4-805a-b3d8a994c40e)
_출처: https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-1.계층형-아키텍처의-문제는-무엇일까 _

- 이 묘수로 영속성 코드에 있는 숨막히는 의존성으로부터 도메인 로직을 해방시켰다.

## 클린 아키텍처
- 로버트 마틴은 '클린 아키텍처'라는 용어를 같은 이름의 책에서 정립했다.
- 그는 클린 아키텍처에서는 설계가 비즈니스 규칙의 테스트를 용이하게 하고, 비즈니스 규칙은 프레임워크, DB, UI기술, 그 밖의 외부 애플맄네이션이나 인터페이스로부터 독립적일수있다고 이야기했다.
- **이는 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야함을 의미한다. 대신 의존성 역전 원칙의 도움으로 모든 의존성이 안쪽(도메인 코드)을 향하고 있다.**

![image](https://github.com/user-attachments/assets/63fce979-8677-4e55-a4b0-43c1d1cd969a)
_출처: https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-1.계층형-아키텍처의-문제는-무엇일까 _

- 이 아키텍처에서 코어에는 주변 유스케이스에서 접근하는 도메인 엔티티들이 있다. 유스케이스는 앞에서 서비스라 불렀던것들인데, 단일 책임(즉, 변경할 단 한 가지의 이유)을 갖기 위해 조금 더 세분화돼 있다. 이를 통해 이전에 이야기했던 `넓은 서비스 문제`를 피할 수 있다.
- 도메인 코드에서는 어떤 영속성 프레임워크나 UI 프레임워크가 사용되는지 알 수 없기 떄문에 특정 프레임워크에 특화된 코드를 가질 수 없고 비즈니스 규칙에 집중할 수 있다.
  - 그래서 도메인 코드를 자유롭게 모델링할 수 있다.
  - 예를 들어, 도메인 주도 설계(DDD)를 가장 순수한 형태로 적용해볼수도 있다.
  - 영속성이나 UI에 특화된 문제를 신경쓰지 않아도 된다면 이렇게 하기 굉장히 수월해진다.
- 하지만 클린아키텍처에선 대가가 따른다. 도메인 계층이 영속성이나 UI 같은 외부 계층과 철저히 분리돼야 하므로 애플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수해야 한다.
  - **가령 영속성 계층에서 ORM프레임워크를 사용한다 했을떄 도메인 계층은 영속성 계층을 모르기 때문에 도메인 계층에서 사용한 엔티티 클래스를 영속성 계층에서 함께 사용할 수 없고 두 계층에서 각각 엔티티를 만들어 관리해야 한다. 즉, 도메인 계층과 영속성 계층이 데이터를 주고 받을때, 두 엔티티를 서로 변환해야 한다는 뜻이다.**
  - 이는 도메인 계층과 다른 계층들 사이에서도 마찬가지다.
  - **실제 개인적인 경험으로 매번 컨버팅 작업을 해줘야하는 번거로운 작업임에도 불구하고 이는 바람직한 일이다. 이것이 바로 도메인 코드를 프레임워크에 특화된 문제로부터 해방시키고자 했던, 결합이 제거된 상태다.**
  - **가령 JPA 에선 ORM이 관리하는 엔티티에 인자가 없는 기본 생성자를 추가하도록 강제하는데 이것이 도메인 모델에는 포함해서는 안될 프레임워크에 특화된 결합의 예이다.**
  - 8장에선 도메인 계층과 영속성 계층의 결합을 그대로 수용하는 '매핑하지 않기' 전략을 비롯한 여러 매핑 전략에 대해 살펴보겠다.
- 로버트 마틴의 클린 아키텍처는 다소 추상적이기에 조금 더 깊게 들어가서 클린 아키텍처의 원칙들을 조금 더 구체적으로 만들어주는 '육각형 아키텍처'에 대해 살펴보자.

## 육각형 아키텍처(헥사고날 아키텍처)

![image](https://github.com/user-attachments/assets/9496eb1d-bc54-4d94-860b-d42e7209231f)
_출처: https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-1.계층형-아키텍처의-문제는-무엇일까 _

- 알리스테어 콕번이 만든 용어로 애플리케이션 코어가 육각형으로 표현되다보니 붙여진 이름이다.
- 육각형에서 외부로 향하는 의존성이 없기 때문에 마틴이 클린 아키텍처에서 제시한 의존성 규칙이 그대로 적용된다는 점을 주목하자. 대신 모든 의존성은 코어를 향한다.
- 왼쪽에 있는 어댑터들은 (애플리케이션 코어를 호출하기 때문에) 애플리케이션을 주도하는 어댑터들이고, 반면 오른쪽 어댑터들은 (애플리케이션 코어에 의해 호출되기 때문에) 애플리케이션에 의해 주도되는 어댑터들이다.
- 애플리케이션 코어와 어댑터들간의 통신이 가능하려면 애플리케이션 코어가 각각의 포트를 제공해야 한다. 주도하는 어댑터(driving adapter)에게는 그러한 포트가 코어에 있는 유스케이스 클래스 중 하나에 의해 구현되고 어댑터에 의해 호출되는 인터페이스가 될것이고, 주도되는 어댑터(driven adapter)에게는 그러한 포트가 어댑터에 의해 구현되고 코어에 의해 호출되는 인터페이스가 될 것이다.
- 이러한 핵심 개념으로 '포트와 어댑터' 아키텍처로도 알려져 있다.

## 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?
- 의존성을 역전시켜 도메인 코드가 다른 바깥쪽 코드에 의존하지 않게 함으로써 영속성과 UI에 특화된 모든 문제로부터 도메인 로직의 결합을 제거하고 코드를 변경할 이유의 수를 줄일 수 있다. 그리고 변경할 이유가 적을수록 유지보수성은 좋아진다.
- 또한 도메인 코드는 비즈니스 문제 딱 맞도록 자유롭게 모델링 가능해지고, 영속성 코드와 UI코드도 영속성 문제와 UI문제에 맞게 자유롭게 모델링될 수 있다.

# 3장 - 코드 구성하기
- 코드를 구성하는 몇 가지 방법을 살펴보고, 육각형 아키텍처를 직접적으로 반영하는 표현력있는 패키지 구조를 소개한다.
- [BuckPal](https://github.com/wikibook/clean-architecture) 예제 코드를 구조화히기 위한 여러 가지 방법들을 살펴본다. 사용자가 본인 계좌에서 다른 계좌로 돈을 송금할 수 있는 '송금하기' 유스케이스를 살펴본다.

## 계층으로 구성하기

```
buckapl
|--- domain
|    |----- Account
|    |----- Activity
|    |----- AccountRepository
|    |----- AccountService
|--- persistence
|    |----- AccountRepositoryImpl
|--- web
|    |----- AccountController
```

- 계층으로 코드를 구성하면, 기능적인 측면들이 섞이기 쉽다.

### 문제점
#### 문제1 : 애플리케이션의 기능 조각(functional slice) 이나 특징(feature) 을 구분 짓는 패키지 경계가 없다
- 사용자를 관리하는 기능을 추가한다면 web패키지 domain 패키지, persistence 패키지에 관련 클래스가 추가될것이다.
- 추가적인 구조가 없다면, 아주 빠르게 서로 연관되지 않은 기능들끼리 예상하지 못한 부수효과를 일으킬 수 있는 클래스들의 묶음으로 변모할 수 있다.

#### 문제2 : 애플리케이션이 어떤 유스케이스들을 제공하는지 파악할 수 없다.
- 특정 기능을 찾기 위해 어떤 서비스가 어떤 함수에서 이에 대한 책임을 구현했는지 추측해야 한다.

#### 문제3 : 패키지 구조를 통해서는 우리의 목표로 하는 아키텍처를 파악할 수 없다.
- 어떤 기능이 웹 어댑터에서 호출되는지, 영속성 어댑터가 도메인 계층에 어떤 기능을 제공하는지 한 눈에 알 수 없다.
- 인커밍(incoming) 포트와 아웃고인(outgoing) 포트가 코드 속에 숨겨져 있다.

## 기능으로 구성하기

```
buckpal
|-- account
    |-- Account
    |-- AccountController
    |-- AccountRepository
    |-- AccountRepositoryImpl
    |-- SendMoneyService
```

- acouunt 패키지로 묶고 계층 패키지를 없앴다.
- 기능 기준으로 구조화시엔 기반 아키텍처가 명확히 보이지 않는다.

### 장점
- 패키지 외부에서 접근하면 안되는 클래스들에 대해 package-private 접근 수준을 이용해 패키지 간의 경계를 강화할 수 있다.
- 패키지 경계를 package-private 접근 수준과 결합하면 각 기능사이의 불필요한 의존성을 방지할 수 있다.
- SendMoneyService 와 같이 송금하기 기능을 구현한 클래스를 클래스명으로 바로 찾을 수 있다.(소리치는 아키텍처)

### 단점
- 아키텍처의 가시성을 계층방식보다 훨씬 더 떨어뜨린다.
  - 어댑터를 나타내는 패키지명도 없다. 인커밍 포트, 아웃고인 포트도 없다.
  - 인터페이스만 알고 구현체를 알수 없게 했지만 패키지 내부 package-private 접근 수준으로 구현체를 자유롭게 접근할 수 있다.

## 아키텍처적으로 표현력 있는 패키지 구조

```
buckpal
|-- account
    |-- adapter
    |   |-- in
    |   |   |-- web
    |   |       |-- AccountController
    |   |-- out
    |   |   |-- persistence
    |   |       |-- AccountPersistenceAdapter
    |   |       |-- SpringDataAccountRepository
    |-- domain
    |   |-- Account
    |   |-- Activity
    |-- application
        |-- SendMoneyService
        |-- port
            |-- in
            |   |-- SendMoneyUseCase
            |-- out
            |   |-- LoadAccountPort
            |   |-- UpdateAccountStatePort
```

- 육각형 아키텍처의 핵심적인요소 : 엔티티, 유스케이스, 인커밍/아웃고잉 포트, 인커밍/아웃고잉 어댑터
- 최상위에 Account 관련 유스케이스를 구현한 모듈임을 나타내는 account 패키지
- 도메인 모델에 속한 domain 패키지
- 서비스 계층(인커밍 포트 구현체)이 속한 application 패키지
- 인커밍 포트 인터페이스, 아웃고잉 포트 인터페이스가 속한 application 패키지
- 인커핑 포트를 호출하는 인커밍 어댑터와 아웃고인 포트에 대한 구현을 제공하는 아웃고잉 어댑터가 속한 adapter 패키지
- 만약 서드파티 API에 대한 클라이언트를 변경하는 작업이 추가된다면 adapter/out/{어댑터 이름} 패키지에서 바로 구현하면 되고 수정이 필요할때 바로 찾을 수 있다.

### 장점

#### 장점1: 모델-코드 갭(아키텍처-코드 갭)을 효과적으로 다룰 수 있다.
- 아키텍처를 직접적으로 매핑후 반영할 수 있다는 점이다.
- 만약 패키지 구조가 아키텍처를 반영할 수 없다면 시간이 지남에 따라 코드는 점점 목표하던 아키텍처로부터 멀어지게 된다.
- 또한, 이처럼 표현력 있는 패키지 구조는 아키텍처에 대한 적극적인 사고를 촉진한다.
  - 많은 패키지가 생기고, 현재 작업 중인 코드를 어떤 패키지에 넣어야 할지 계쏙 생각하기 때문이다.

#### 장점2: 패키지간 접근을 제어할 수 있다.
- 패키지가 아주 많다는 것은 모든것을 public 으로 만들어 패키지간 접근을 허용해야 한다는것을 의미하진 않는다.
- 적어도 adapter 패키지에 대해선 그렇지 않다. 이 패키지에 들어 있는 모든 클래스들은 application 패키지 내에 있는 포트 인터페이스를 통하지 않고는 바깥에서 호출되지 않기 때문에 package-private 접근 수준으로 둬도 된다. 그러므로 애플리케이션 계층에서 adapter 클래스로 향하는 우발적인 의존성은 있을 수 없다.
- 하지만 application 패키지와 domain 패키지 내의 일부 클래스들은 public 이어야 한다. 도메인 클래스들은 서비스, 그리고 잠재적으로 어댑터에서도 접근 가능하도록 public 이어야 한다. 서비스는 인커밍 포트 인터페이스 뒤에 숨겨질 수 있기 때문에 public 일 필요가 없다.

#### 장점3: 어댑터 교체가 용이하다
- 하나의 어댑터를 다른 구현으로 쉽게 교체할 수 있다.
- 예를 들어, 최종적으로 어떤 DB 쓸지 결정되지 않은 상태에서 간단히 키-밸류 DB로 개발을 시작했는데, RDB로 교체해야 한다면 간단히 관련 아웃고잉 포트들만 새로운 adapter 패키지에 구현하고 기존 패키지를 지우면 된다.

#### 장점4: DDD 개념에 직접적으로 대응시킬 수 있다.
- 예제 코드에서 account 같은 상위 레벨 패키지는 다른 바운디드 컨텍스트(bounded context)와 통신할 전용 진입점과 출구(포트)를 포함하는 바운디드 컨텍스트에 해당한다.
- domain 패키지 내에서는 DDD가 제공하는 모든 도구를 이용해 우리가 원하는 어떤 도메인 모델이든 만들 수 있다.

> 모든 구조와 마찬가지로 패키지 구조를 소프트웨어 프로젝트 내내 유지하기 위해서는 지켜야할 규칙이 있다. 또한 패키지 구조가 적합하지 않아서 어쩔 수 없이 아키텍처-코드 갭을 넓히고 아키텍처를 반영하지 않는 패키지를 만들어야 하는 경우도 생길 수 있다. 완벽한 방법은 없다. 그러나 표현력 있는 패키지 구조는 적어도 코드와 아키텍처 간의 갭을 줄일 수 있게 해준다.

## 의존성 주입의 역할
- 클린 아키텍처의 가장 본질적인 요건은 2장에서 나왔다시피 애플리케이션 계층이 인커밍/아웃고잉 어댑터에 의존성을 갖지 않는 것이다.
- 예제 코드의 웹 어댑터와 같이 인커밍 어댑터에 대해서는 그렇게 하기가 쉽다. 제어 흐름의 방향이 어댑터와 도메인 코드 간의 의존성 방향과 같은 방향이기 때문이다.
- 반면 영속성 어댑터와 같이 아웃고잉 adapter 에 대해서는 제어 흐름의 반대 방향으로 의존성을 돌리기 위해 의존성 역전 원칙을 이용해야 한다.
- 애플리케이션 계층에 인터페이스를 만들고 어댑터에 해당 인터페이스를 구현한 클래스를 두면 된다. 육각형 아키텍처에서는 이 인터페이스가 포트다. 아래 이미지와 같이 애플리케이션 계층은 어댑터의 기능을 실행하기 위해 이 포트 인터페이스를 호출한다.
- 그런데 포트 인터페이스를 구현한 실제 객체를 누가 애플리케이션 계층에 제공해야 할까? => 이 부분에서 의존성 주입을 활용할 수도 있다. 모든 계층에 읜존성을 가진 중림적인 컴포넌트를 하나 도입하는 것이다. 이 컴포넌트는 아키텍처를 구성하는 대부분의 클래스를 초기화하는 역할을 한다.

![image](https://github.com/user-attachments/assets/9e40f300-a0c3-4166-9bbc-5e4eb0fdae49)
_출처: https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-3.-코드-구성하기_

- `AccountController`
  - SendMoneyUseCase 인터페이스가 필요하므로 의존성 주입을 통해 SendMoneyService 클래스의 인스턴스를 주입
  - AccountController 는 SendMoneyUseCase 인터페이스의 실제 구현체가 SendMoneyService 인지 모른다.
- `SendMoneyService`
  - LoadAccount 인터페이스로 가장한 AccountPersistenceAdapter 클래스의 인스턴스 주입
  - SendMoneyService 는 SendMony LoadAccount 인터페이스의 실제 구현체가 AccountPersistenceAdapter 인지 모른다.

## 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?
- 코드에서 아키텍처의 특정 요소를 찾으려면 이제 아키텍처 다이어그램의 박스 이름을 따라 패키지 구조를 탐색하면 된다. 이로써 의사소통, 개발, 유지보수 모두가 조금 더 수월해진다.

# 4장 - 유스케이스 구현하기
- 위에서 설명한 내용에 따르면 애플리케이션, 웹, 영속성 계층이 현재 아키텍처에서 아주 느슨하게 결합돼 있기 때문에 필요한 대로 도메인 코드를 자유롭게 모델링할 수 있다.
- 육각형 아키텍처는 도메인 중심의 아키텍처에 적합하기에 도메인 엔티티를 만드는것으로 시작후 해당 도메인 엔티티를 중심으로 유스케이스를 구현한다.

## 도메인 모델 구현하기
- 한 계좌에서 다른 계좌로 송금하는 유스케이스를 구현한다.

```java
package buckpal.domain;

@AllArgsConstructor
@Getter
public class Account {
    private AccountId id;
    private Money baselineBalance;
    private ActivityWindow activityWindow;

    public Money calculateBalance() {
        return Money.add(
            this.baselineBalance,
            this.activityWindow.calculateBalance(this.id)
        );
    }

    public boolean withDraw(Money money, AccountId targetAccountId) {
        if (!mayWithDraw(money)) {
            return false;
        }

        Activity withDrawal = new Activity(
            this.id,
            this.id,
            targetAccountId,
            LocalDateTime.now(),
            money
        );
        this.activityWindow.addActivity(withDrawal);
        return true;
    }

    private boolean mayWithDraw(Money money) {
        return Money.add(
            this.calculateBalance(),
            money.negate()
        ).isPositive();
    }

    public boolean deposit(Money money, AccountId sourceAccountId) {
        Activity deposit = new Activity(
            this.id,
            sourceAccountId,
            this.id,
            LocalDateTime.now(),
            money
        );
        this.activityWindow.addActivity(deposit);
        return true;
    }
}
```

- Account(계좌) 엔티티는 실제 계좌의 현재 스냅숏을 제공한다.
- 계좌에 대한 모든 입출금은 Activity 엔티티에 포착한다.
- 한 계좌에 대한 모든 활동(activity)들은 항상 메모리에 한꺼번에 올리는건 현명한 방법이 아니기에 Account 엔티티는 ActivityWindow 값 객체(value object)에서 포착한 지난 며칠 혹은 몇 주간의 범위에 해당하는 활동만 보유한다.

## 유스케이스 둘러보기
- 일반적으로 유스케이스는 아래와 같은 단계를 따른다.
  - 1)입력을 받는다
  - 2)비즈니스 규칙을 검증한다
  - 3)모델 상태를 조작한다
  - 4)출력을 반환한다
- 비즈니스 규칙을 충족하면 유스케이스는 입력을 기반으로 어떤 방법으로든 모델 상태를 변경한다. 일반적으로 도메인 객체의 상태를 바꾸고 영속성 어댑터를 통해 구현된 포트로 이 상태를 전달해서 저장될 수 있게 한다. 유스케이스는 또 다른 아웃고잉 어댑터를 호출할 수도 있다.
- 마지막 단계는 아웃고잉 어댑터에서 온 출력값을, 유스케이스를 호출한 어댑터를 반환할 출력 객체로 변환하는 것이다.
- 1장에서 이야기한 넓은 서비스 문제를 피하기 위해 모든 유스케이스를 각 분리된 서비스로 만든다.

```java
package buckpal.application.service;  

import buckpal.application.port.in.SendMoneyCommand;
import buckpal.application.port.in.SendMoneyUseCase;
import buckpal.application.port.out.AccountLock;
import buckpal.application.port.out.LoadAccountPort;
import buckpal.application.port.out.UpdateAccountStatePort;
import lombok.RequiredArgsConstructor;
import org.springframework.transaction.annotation.Transactional;

@RequiredArgsConstructor
@Transactional(readOnly = true)
public class SendMoneyService implements SendMoneyUseCase {
  private final LoadAccountPort loadAccountPort;
  private final AccountLock accountLock;
  private final UpdateAccountStatePort updateAccountStatePort;

  @Transactional
  @Override
  public boolean sendMoney(SendMoneyCommand command) {

      //TODO: 비즈니스 규칙 검증
      //TODO: 모델 상태 조작
      //TODO: 출력 값 반환

      return false;
  }
}
```

- 서비스는 인커밍 포트 인터페이스인 SendMoneyUseCase를 구현하고, 계좌를 불러오기 위해 아웃고잉 포트 인터페이스인 LoadAccountPort 를 호출한다. 그리고 DB의 계좌상태 업데이트를 위해 UpdateAccountStatePort 를 호출한다.

![image](https://github.com/user-attachments/assets/c67d5dc9-139c-4027-91d9-41c3a6566021)
_출처: https://kimdonghyungsoo.tistory.com/13_

## 입력 유효성 검증
- 저자는 유스케이스 코드가 도메인 로직에만 신경써야 하고 입력 유효성 검증으로 오염되면 안된다 생각한다
- 그러나 유스케이스는 비즈니스 규칙(business rule)을 검증할 책임이 있다.
- 과연 유스케이스에서 필요로 하는것을 호출자가 모두 검증했다고 믿을수있을까? 또 해당 유스케이스를 호출하는 모든 각 어댑터에서 유효성검증을 해야할텐데 실수할수도 있고 잊을수도 있다.
- **애플리케이션 계층에서 입력 유효성을 검증하는 이유는, 그렇게 하지 않을 경우 애플리케이션 코어의 바깥쪽으로부터 유효하지 않은 입력값을 받게 되고, 모델 상태를 해칠수 있기 때문이다.**
- 그러면 **어디서 입력유효성 검증을 해야할까? 입력 모델(input model)이 이 문제를 다루도록 해보자.** '송금하기' 유스케이스에선 SendMoneyCommand 클래스다. 더 정확히는 **생성자**내에서다.

```java
package buckpal.application.port.in;

import buckpal.common.SelfValidating;
import buckpal.domain.Account.AccountId;
import buckpal.domain.Money;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.Value;

import javax.validation.constraints.NotNull;

@Value
@Getter
@EqualsAndHashCode(callSuper = false)
public class SendMoneyCommand extends SelfValidating<SendMoneyCommand> {

    @NotNull
    private final AccountId sourceAccountId;

    @NotNull
    private final AccountId targetAccountId;

    @NotNull
    private final Money money;

    public SendMoneyCommand(
            AccountId sourceAccountId,
            AccountId targetAccountId,
            Money money) {
        this.sourceAccountId = sourceAccountId;
        this.targetAccountId = targetAccountId;
        this.money = money;
        this.validateSelf();
    }
}
```
- 객체 생성시 예외를 던져서 객체 생성을 막으면 된다.
- SendMoneyCommand 필드에 final 을 지정해 불변 필드로 만들면 안정적으로 유효한 불변 객체를 유지할 수 있다.
- SendMoneyCommand는 유스케이스 API의 일부이기에 인커밍 포트 패키지에 위치한다. 그러므로 유효성 검증이 애플리케이션 코어(육각형 아키텍처 내부)에 남아있지만 신성한 유스케이스 코드를 오염시키지 않게된다.
- 자바에선 Bean Validation API(spring-boot-starter-validation)가 필요한 유효성 규칙들을 필드 애너테이션으로 표현 가능하다.

```java
class SendMoneyCommand extends SelfValidating<SendMoneyCommand> {

  @NotNull
  private final AccountId sourceAccountId;

  @NotNull
  private final AccountId targetAccountId;

  @NotNull
  private final Money money;

  public SendMoneyCommand(
    AccountId sourceAccountId,
    AccountId targetAccountId,
    Money money) {
    this.sourceAccountId = sourceAccountId;
    this.targetAccountId = targetAccountId;
    this.money = money;
    this.validateSelf();
  }
}

public abstract class SelfValidating<T> {

  private Validator validator;

  public SelfValidating() {
    ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
    validator = factory.getValidator();
  }

  /**
   * Evaluates all Bean Validations on the attributes of this
   * instance.
   */
  protected void validateSelf() {
    Set<ConstraintViolation<T>> violations = validator.validate((T) this);
    if (!violations.isEmpty()) {
      throw new ConstraintViolationException(violations);
    }
  }
}
```

- 커맨트 모델은 SelfValidating.validateSelf() 함수를 호출함으로써, 유효성 검증을 수행하고 예외를 던지게 된다.
- 유스케이스 로직 내부에 구현하지 않고 커맨드 모델 생성자를 통해 입력 유효성 검증을 수행함으로써 오류 방지 계층을 만든것이다.

## 생성자의 힘
- 빌더 패턴 활용하여 커맨드 모델을 생성하는 경우 입력 유효성 검증에 대한 누락이 발생할수 있게 된다.
- 요즘 IDE 는 생성자 파라미터 힌트를 제공해주기도 한다.

## 유스케이스마다 다른 입력 모델
- 두 유스케이스에 동일한 입력 모델을 사용하고 싶은 생각이 들때가 있다. '계좌 등록하기'와 '계좌 정보 업데이트하기' 유스케이스처럼 말이다.
  - '계좌 등록하기'는 소유자 ID가 필요하고, '계좌 정보 업데이트' 유스케이스는 업데이트칠 계좌 ID가 필요하다.
  - 그러다보면 '계좌 등록하기'에선 계좌 ID가 null을 허용해야 하고, '계좌 정보 업데이트' 에선 소유자 ID에 null을 허용해야 한다.
  - **불변 커맨드 객체 필드에 null을 유효한 상태로 받아들이는 것은 그 자체로 코드 냄새다.**
  - 하지만 더 문제되는 부분은 이제 입력 유효성을 어떻게 검증하느냐다. 등록 유스케이스와 업데이트 유스케이스는 서로 다른 유효성 검증 로직이 필요할텐데 아마 유효성 검증 로직을 분기처리하여 관리되고 유지보수에 좋지 못할것이다.
- 각 유스케이스 전용 입력 모델은 유스케이스를 훨씬 명확하게 만들고 다른 유스케이스와의 결합도 제거해서 불필요한 부수효과가 발생하지 않게 한다. 들어오는 데이터를 각 유스케이스에 해당하는 입력모델로 매핑해야 하기 때문에 물론 비용이 안 드는 것은 아니다.

## 비즈니스 규칙 검증하기
- 입력 유효성 검증은 구문상의 유효성을 검증하는 것이고, 비즈니스 규칙은 유스케이스 맥락에서 의미적인(semantical) 유효성 검증이라 할 수 있다. 
  - 좀 더 쉽게 설명하면 입력 유효성 검증은 논리적인 수준의 검증 없이 단순한 필드에 대한 검증이고 비즈니스 규칙 검증은 모델의 현재 상태를 기반으로 하는 논리적인 수준의 검증이라 할 수 있다.
- "송금되는 금액은 0보다 커야 한다"라는 규칙은 모델에 접근하지 않고도 검증될 수 있기에 입력 유효성 검증으로 구현할 수 있다. 하지만 논란의 여지는 있다. 송금액은 매우 중요하므로 비즈니스 규칙으로도 다룰수 있다는 것이다.
- 하지만 맨 처음 정의대로 구현하게 되면 장점이 있다. 코드 상의 어느 위치에 둘지 결정하고 나중에 더 쉽게 찾을 수 있다. 현재 모델 상태에 접근해야 하는지 여부만 확인하면 되기 떄문이다. 그러면 유지보수하기 쉬워진다.
- 비즈니스 규칙 검증은 도메인 모델 안에 유효성 검증 로직을 넣는것이 베스트하다. 그러면 위치를 정하기도 쉽고 추론하기도 쉽다.

```java
public class Account {

  // ...

  public boolean withDraw(Money money, AccountId targetAccountId) {
      if (!mayWithDraw(money)) {
          return false;
      }

      ...
  }

  ...
}
```

- 만약 도메인 엔티티에서 비즈니스 규칙을 검증하기 여의치 않다면 유스케이스 코드에서 도메인 엔티티를 사용하기 전에 해도 된다. (ex. 단순 ID 값에 해당하는 데이터가 DB에 있는지 확인이 필요할 경우)

## 풍부한 도메인 모델 vs 빈약한 도메인 모델
- 풍부한 도메인 모델은 애플리케이션 코어 있는 엔티티에서 가능한 많은 도메인 로직이 구현된다. 엔티티들은 상태를 변경하는 메서드를 제공하고, 비즈니스 규칙에 맞는 유효한 변경만을 허용하면 된다.
- 빈약한 도메인 모델은 상태를 표현하는 필드와 getter, setter 메서드만 포함하며 어떤 도메인 로직도 가지고 있지 않다. 즉, 도메인 로직이 유스케이스 클래스에 구현되있다는것이다.
- 위 두 가지중 각자 스타일에 맞게 선택해서 사용하면 된다.

## 유스케이스마다 다른 출력 모델
- 입력과 마찬가지로 출력도 가능하면 각 유스케이스에 맞게 구체적일수록 좋고, 출력은 호출자에게 꼭 필요한 데이터만 들고 이썽야 한다.
- 유스케이스들 간에 출력 모델을 공유하면 강한 결합이 생기게되고 유지보수하기 어려워진다. (한 유스케이스에만 필요한 필드들이 계속 늘어나게되는 등..)

## 읽기 전용 유스케이스
- 읽기 전용 작업을 유스케이스라 언급하는것은 조금 이상하다.
- 예를 들어 UI에 계좌 잔액을 표시한다고 할때 애플리케이션 코어 관점에선 간단한 데이터 쿼리다.
- 이를 구현하는 한 가지 방법은 쿼리를 위한 인커밍 전용 포트를 만들어 이를 '쿼리 서비스'로 구현하는 것이다.

```java
package buckpal.application.service;

@RequiredArgsConstructor
class GetAccountBalanceService implements GetAccountBalanceQuery {

	private final LoadAccountPort loadAccountPort;

	@Override
	public Money getAccountBalance(AccountId accountId) {
		return loadAccountPort.loadAccount(accountId, LocalDateTime.now())
				.calculateBalance();
	}
}
```

<img width="328" alt="image" src="https://github.com/user-attachments/assets/326159a9-67bd-4ecf-88ad-08d9a42d9891">

- 여러 계층에 걸쳐 같은 모델을 사용한다면 지름길을 써서 클라이언트가 아웃고잉 포트를 직접 호출하게 할 수도 있다.

## 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?
- 입출력 모델을 독립적으로 모델링한다면 원치 않는 부수효과를 피할수 있다.
- 유스케이스별 모델을 명확히 이해할수 있고, 여러 개발자가 협엽시 다른 사람이 작업중인 유스케이스를 건들지 않는채로 동시 작업을 할 수 있게 된다.

# 5장 - 웹 어댑터 구현하기

![image](https://github.com/user-attachments/assets/3631e854-036d-4706-8cde-e026e2b0237f)
_출처: https://kimdonghyungsoo.tistory.com/14_

- 애플리케이션 계층은 웹 어댑터가 통신할 수 있는 특정 포트를 제공하고 웹 어댑터는 이 포트를 호출하고 서비스는 이 포트를 구현한다. 의존성 역전 원칙이 적용되었다.

![image](https://github.com/user-attachments/assets/31ce7ba4-b590-447b-bef9-8553d19b5997)
_출처: https://kimdonghyungsoo.tistory.com/14_

- 왜 어댑터와 유스케이스 사이에 포트라는 간접 계층을 넣어야 할까? 애플리케이션 코어가 외부 세계와 통신할수 있는 곳에 대한 명세가 포트이고 외부와 어떤 통신이 일어나는지를 정확히 알 수 있기 떄문이다. (또한 유스케이스 로직을 순수하게 보호하기 위해서)
- 웹 소켓으로 실시간 데이터를 사용자의 브라우저로 보낸다할땐 반드시 포트가 필요하다. 아래 이미지와 같이 웹 어댑터에서 구현하고 애플리케이션 코어에서 호출해야 한다.(p.55 이미지 5.3 참고)
- 이 포트는 아웃고잉 포트이기에 이제 웹 어댑터는 인커밍 어댑터인 동시에 아웃고잉 어댑터가 된다. 한 어댑터가 두 가지 역할을 하지 못할 이유는 없다.

## 웹 어댑터의 책임

01. HTTP 요청을 자바 객체로 매핑
02. 권한검사
03. 입력유효성 검증
04. 입력을 유스케이스의 입력 모델로 매핑
05. 유스케이스호출
06. 유스케이스의 출력을 HTTP로 매핑
07. HTTP 응답을 반환

- 입력유효성 검증은 유스케이스의 입력 모델과는 구조나 의미가 완전히 다를 수 있으므로 또 다른 유효성 검증을 수행해야 한다.
- 유스케이스 입력 모델에서 했던것과 똑같이 구현해야하는 것이 아니라 **웹 어댑터의 입력 모델을 유스케이스 입력 모델로 변환할 수 있다는 것을 검증해야 한다. 이 변환을 방해하는 모든것이 유효성 검증에러다.**
- 위 1부터 8까지의 과정중 하나라도 문제가 생기면 예외를 던지고, 웹 어댑터는 에러를 호출자에게 보여줄 메시지로 변환해야 한다.
- 하지만 이책임들은 애플리케이션 계층에서 신경쓰면 안되는 것들이기도 하다. HTTP와 관련된것은 애플리케이션 계층으로 침투해선 안된다. 우리가 바깥 계층에서 HTTP를 다루고 있다는 것을 애플리케이션 계층이 알게되면 HTTP를 사용하지 않는 또 다른 인커밍 어댑터는 애플리케이션 계층을 사용하지 못하게 된다. 좋은 아키텍처는 선택의 여지를 남겨둔다.
- 웹 어댑터와 애플리케이션 계층 간의 이 같은 경계는 도메인과 애플리케이션 계층부터 개발하기 시작하면 자연스레 생긴다.
- 특정 인커밍 어댑터를 생각할 필요 없이 유스케이스 먼저 구현하면 경계를 흐리게 만들 유혹에 빠지지 않을 수 있다.

## 컨트롤러 나누기
- 클래스마다 코드는 적을수록 좋다. 특정 프로덕션 코드에 해당하는 테스트 코드를 찾기도 쉽다.
- 저자는 각 연산에 대해 가급적이면 별도 패키지 안에 별도 컨트롤러를 만드는 방식을 선호한다.(ex. `SendMoneyController`)
- 또한 컨트롤러명과 서비스명에 대해서도 잘 고려하는게 중요하다. 책 예제에선 계좌를 생성하는 유일한 방법은 사용자가 계좌를 등록하는 방법뿐이므로 CreateAccount 보단 RegisterAccount 라는 네이밍이 더 명확하다.
- 위처럼 나누게 되면 서로 다른 연산에 대한 동시작업이 쉬워진다. 여러 개발자가 병렬적으로 작업해도 병합 충돌이 일어나지 않을것이다.

## 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?
- 애플리케이션 계층은 HTTP 에 대한 상세 정보를 노출시키지 않도록하면 웹 어댑터를 다른 어댑터로 쉽게 교체 가능하게 된다.
- 웹 컨트롤러는 단위가 더 작을수록 파악하기 수월해지고 테스트하기도 쉬워지며 동시작업을 효율적으로 만든다. 세분화된 컨트롤러는 초기엔 공수가 더 들지라도 유지보수 관점에선 훨씬 더 좋다.


# Reference
- [https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-1.계층형-아키텍처의-문제는-무엇일까](https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-1.계층형-아키텍처의-문제는-무엇일까)
- [https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-2.-의존성-역전하기](https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-2.-의존성-역전하기)
- [https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-3.-코드-구성하기](https://velog.io/@yhlee9753/만들면서-배우는-클린-아키텍처-3.-코드-구성하기)
- [https://dgle.dev/clean-arch-1/](https://dgle.dev/clean-arch-1/)
- [https://rudaks.tistory.com/entry/만들면서-배우는-클린-아키텍처-4-유스케이스-구현하기](https://rudaks.tistory.com/entry/만들면서-배우는-클린-아키텍처-4-유스케이스-구현하기)
- [https://kimdonghyungsoo.tistory.com/13](https://kimdonghyungsoo.tistory.com/13)